// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// Code generated by generators/singular-data-source/main.go; DO NOT EDIT.

package ssm

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-provider-awscc/internal/generic"
	"github.com/hashicorp/terraform-provider-awscc/internal/registry"
)

func init() {
	registry.AddDataSourceFactory("awscc_ssm_document", documentDataSource)
}

// documentDataSource returns the Terraform awscc_ssm_document data source.
// This Terraform data source corresponds to the CloudFormation AWS::SSM::Document resource.
func documentDataSource(ctx context.Context) (datasource.DataSource, error) {
	attributes := map[string]schema.Attribute{ /*START SCHEMA*/
		// Property: Attachments
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A list of key and value pairs that describe attachments to a version of a document.",
		//	  "insertionOrder": false,
		//	  "items": {
		//	    "additionalProperties": false,
		//	    "properties": {
		//	      "Key": {
		//	        "description": "The key of a key-value pair that identifies the location of an attachment to a document.",
		//	        "enum": [
		//	          "SourceUrl",
		//	          "S3FileUrl",
		//	          "AttachmentReference"
		//	        ],
		//	        "type": "string"
		//	      },
		//	      "Name": {
		//	        "description": "The name of the document attachment file.",
		//	        "maxLength": 128,
		//	        "minLength": 1,
		//	        "pattern": "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$",
		//	        "type": "string"
		//	      },
		//	      "Values": {
		//	        "description": "The value of a key-value pair that identifies the location of an attachment to a document. The format for Value depends on the type of key you specify.",
		//	        "insertionOrder": false,
		//	        "items": {
		//	          "maxLength": 100000,
		//	          "minLength": 1,
		//	          "type": "string"
		//	        },
		//	        "maxItems": 1,
		//	        "minItems": 1,
		//	        "type": "array"
		//	      }
		//	    },
		//	    "type": "object"
		//	  },
		//	  "maxItems": 20,
		//	  "minItems": 0,
		//	  "type": "array"
		//	}
		"attachments": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: Key
					"key": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The key of a key-value pair that identifies the location of an attachment to a document.",
						Computed:    true,
					}, /*END ATTRIBUTE*/
					// Property: Name
					"name": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The name of the document attachment file.",
						Computed:    true,
					}, /*END ATTRIBUTE*/
					// Property: Values
					"values": schema.ListAttribute{ /*START ATTRIBUTE*/
						ElementType: types.StringType,
						Description: "The value of a key-value pair that identifies the location of an attachment to a document. The format for Value depends on the type of key you specify.",
						Computed:    true,
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Description: "A list of key and value pairs that describe attachments to a version of a document.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: Content
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The content for the Systems Manager document in JSON, YAML or String format.",
		//	  "type": "string"
		//	}
		"content": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The content for the Systems Manager document in JSON, YAML or String format.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: DocumentFormat
		// CloudFormation resource type schema:
		//
		//	{
		//	  "default": "JSON",
		//	  "description": "Specify the document format for the request. The document format can be either JSON or YAML. JSON is the default format.",
		//	  "enum": [
		//	    "YAML",
		//	    "JSON",
		//	    "TEXT"
		//	  ],
		//	  "type": "string"
		//	}
		"document_format": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "Specify the document format for the request. The document format can be either JSON or YAML. JSON is the default format.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: DocumentType
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The type of document to create.",
		//	  "enum": [
		//	    "ApplicationConfiguration",
		//	    "ApplicationConfigurationSchema",
		//	    "Automation",
		//	    "Automation.ChangeTemplate",
		//	    "AutoApprovalPolicy",
		//	    "ChangeCalendar",
		//	    "CloudFormation",
		//	    "Command",
		//	    "DeploymentStrategy",
		//	    "ManualApprovalPolicy",
		//	    "Package",
		//	    "Policy",
		//	    "ProblemAnalysis",
		//	    "ProblemAnalysisTemplate",
		//	    "Session"
		//	  ],
		//	  "type": "string"
		//	}
		"document_type": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The type of document to create.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: Name
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A name for the Systems Manager document.",
		//	  "pattern": "^[a-zA-Z0-9_\\-.]{3,128}$",
		//	  "type": "string"
		//	}
		"name": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "A name for the Systems Manager document.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: Requires
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A list of SSM documents required by a document. For example, an ApplicationConfiguration document requires an ApplicationConfigurationSchema document.",
		//	  "insertionOrder": false,
		//	  "items": {
		//	    "additionalProperties": false,
		//	    "properties": {
		//	      "Name": {
		//	        "description": "The name of the required SSM document. The name can be an Amazon Resource Name (ARN).",
		//	        "maxLength": 200,
		//	        "pattern": "^[a-zA-Z0-9_\\-.:/]{3,200}$",
		//	        "type": "string"
		//	      },
		//	      "Version": {
		//	        "description": "The document version required by the current document.",
		//	        "maxLength": 8,
		//	        "pattern": "([$]LATEST|[$]DEFAULT|^[1-9][0-9]*$)",
		//	        "type": "string"
		//	      }
		//	    },
		//	    "type": "object"
		//	  },
		//	  "minItems": 1,
		//	  "type": "array"
		//	}
		"requires": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: Name
					"name": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The name of the required SSM document. The name can be an Amazon Resource Name (ARN).",
						Computed:    true,
					}, /*END ATTRIBUTE*/
					// Property: Version
					"version": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The document version required by the current document.",
						Computed:    true,
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Description: "A list of SSM documents required by a document. For example, an ApplicationConfiguration document requires an ApplicationConfigurationSchema document.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: Tags
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "Optional metadata that you assign to a resource. Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment.",
		//	  "insertionOrder": false,
		//	  "items": {
		//	    "additionalProperties": false,
		//	    "properties": {
		//	      "Key": {
		//	        "description": "The name of the tag.",
		//	        "maxLength": 128,
		//	        "minLength": 1,
		//	        "pattern": "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$",
		//	        "type": "string"
		//	      },
		//	      "Value": {
		//	        "description": "The value of the tag.",
		//	        "maxLength": 256,
		//	        "minLength": 1,
		//	        "pattern": "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$",
		//	        "type": "string"
		//	      }
		//	    },
		//	    "type": "object"
		//	  },
		//	  "maxItems": 1000,
		//	  "type": "array"
		//	}
		"tags": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: Key
					"key": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The name of the tag.",
						Computed:    true,
					}, /*END ATTRIBUTE*/
					// Property: Value
					"value": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The value of the tag.",
						Computed:    true,
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Description: "Optional metadata that you assign to a resource. Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: TargetType
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "Specify a target type to define the kinds of resources the document can run on.",
		//	  "pattern": "^\\/[\\w\\.\\-\\:\\/]*$",
		//	  "type": "string"
		//	}
		"target_type": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "Specify a target type to define the kinds of resources the document can run on.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: UpdateMethod
		// CloudFormation resource type schema:
		//
		//	{
		//	  "default": "Replace",
		//	  "description": "Update method - when set to 'Replace', the update will replace the existing document; when set to 'NewVersion', the update will create a new version.",
		//	  "enum": [
		//	    "Replace",
		//	    "NewVersion"
		//	  ],
		//	  "type": "string"
		//	}
		"update_method": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "Update method - when set to 'Replace', the update will replace the existing document; when set to 'NewVersion', the update will create a new version.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: VersionName
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "An optional field specifying the version of the artifact you are creating with the document. This value is unique across all versions of a document, and cannot be changed.",
		//	  "pattern": "^[a-zA-Z0-9_\\-.]{1,128}$",
		//	  "type": "string"
		//	}
		"version_name": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "An optional field specifying the version of the artifact you are creating with the document. This value is unique across all versions of a document, and cannot be changed.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
	} /*END SCHEMA*/

	attributes["id"] = schema.StringAttribute{
		Description: "Uniquely identifies the resource.",
		Required:    true,
	}

	schema := schema.Schema{
		Description: "Data Source schema for AWS::SSM::Document",
		Attributes:  attributes,
	}

	var opts generic.DataSourceOptions

	opts = opts.WithCloudFormationTypeName("AWS::SSM::Document").WithTerraformTypeName("awscc_ssm_document")
	opts = opts.WithTerraformSchema(schema)
	opts = opts.WithAttributeNameMap(map[string]string{
		"attachments":     "Attachments",
		"content":         "Content",
		"document_format": "DocumentFormat",
		"document_type":   "DocumentType",
		"key":             "Key",
		"name":            "Name",
		"requires":        "Requires",
		"tags":            "Tags",
		"target_type":     "TargetType",
		"update_method":   "UpdateMethod",
		"value":           "Value",
		"values":          "Values",
		"version":         "Version",
		"version_name":    "VersionName",
	})

	v, err := generic.NewSingularDataSource(ctx, opts...)

	if err != nil {
		return nil, err
	}

	return v, nil
}
