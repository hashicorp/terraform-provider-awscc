// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// Code generated by generators/resource/main.go; DO NOT EDIT.

package scheduler

import (
	"context"
	"regexp"

	"github.com/hashicorp/terraform-plugin-framework-timetypes/timetypes"
	"github.com/hashicorp/terraform-plugin-framework-validators/float64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/float64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/float64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-provider-awscc/internal/generic"
	"github.com/hashicorp/terraform-provider-awscc/internal/registry"
	fwvalidators "github.com/hashicorp/terraform-provider-awscc/internal/validators"
)

func init() {
	registry.AddResourceFactory("awscc_scheduler_schedule", scheduleResource)
}

// scheduleResource returns the Terraform awscc_scheduler_schedule resource.
// This Terraform resource corresponds to the CloudFormation AWS::Scheduler::Schedule resource.
func scheduleResource(ctx context.Context) (resource.Resource, error) {
	attributes := map[string]schema.Attribute{ /*START SCHEMA*/
		// Property: Arn
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The Amazon Resource Name (ARN) of the schedule.",
		//	  "maxLength": 1224,
		//	  "minLength": 1,
		//	  "pattern": "^arn:aws[a-z-]*:scheduler:[a-z0-9\\-]+:\\d{12}:schedule\\/[0-9a-zA-Z-_.]+\\/[0-9a-zA-Z-_.]+$",
		//	  "type": "string"
		//	}
		"arn": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The Amazon Resource Name (ARN) of the schedule.",
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Description
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The description of the schedule.",
		//	  "maxLength": 512,
		//	  "minLength": 0,
		//	  "type": "string"
		//	}
		"description": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The description of the schedule.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.LengthBetween(0, 512),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: EndDate
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The date, in UTC, before which the schedule can invoke its target. Depending on the schedule's recurrence expression, invocations might stop on, or before, the EndDate you specify.",
		//	  "format": "date-time",
		//	  "type": "string"
		//	}
		"end_date": schema.StringAttribute{ /*START ATTRIBUTE*/
			CustomType:  timetypes.RFC3339Type{},
			Description: "The date, in UTC, before which the schedule can invoke its target. Depending on the schedule's recurrence expression, invocations might stop on, or before, the EndDate you specify.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: FlexibleTimeWindow
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "Flexible time window allows configuration of a window within which a schedule can be invoked",
		//	  "properties": {
		//	    "MaximumWindowInMinutes": {
		//	      "description": "The maximum time window during which a schedule can be invoked.",
		//	      "maximum": 1440,
		//	      "minimum": 1,
		//	      "type": "number"
		//	    },
		//	    "Mode": {
		//	      "description": "Determines whether the schedule is executed within a flexible time window.",
		//	      "enum": [
		//	        "OFF",
		//	        "FLEXIBLE"
		//	      ],
		//	      "type": "string"
		//	    }
		//	  },
		//	  "required": [
		//	    "Mode"
		//	  ],
		//	  "type": "object"
		//	}
		"flexible_time_window": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: MaximumWindowInMinutes
				"maximum_window_in_minutes": schema.Float64Attribute{ /*START ATTRIBUTE*/
					Description: "The maximum time window during which a schedule can be invoked.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.Float64{ /*START VALIDATORS*/
						float64validator.Between(1.000000, 1440.000000),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.Float64{ /*START PLAN MODIFIERS*/
						float64planmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: Mode
				"mode": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "Determines whether the schedule is executed within a flexible time window.",
					Required:    true,
					Validators: []validator.String{ /*START VALIDATORS*/
						stringvalidator.OneOf(
							"OFF",
							"FLEXIBLE",
						),
					}, /*END VALIDATORS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "Flexible time window allows configuration of a window within which a schedule can be invoked",
			Required:    true,
		}, /*END ATTRIBUTE*/
		// Property: GroupName
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The name of the schedule group to associate with this schedule. If you omit this, the default schedule group is used.",
		//	  "maxLength": 64,
		//	  "minLength": 1,
		//	  "pattern": "^[0-9a-zA-Z-_.]+$",
		//	  "type": "string"
		//	}
		"group_name": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The name of the schedule group to associate with this schedule. If you omit this, the default schedule group is used.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.LengthBetween(1, 64),
				stringvalidator.RegexMatches(regexp.MustCompile("^[0-9a-zA-Z-_.]+$"), ""),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: KmsKeyArn
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The ARN for a KMS Key that will be used to encrypt customer data.",
		//	  "maxLength": 2048,
		//	  "minLength": 1,
		//	  "pattern": "^arn:aws[a-z-]*:kms:[a-z0-9\\-]+:\\d{12}:(key|alias)\\/[0-9a-zA-Z-_]*$",
		//	  "type": "string"
		//	}
		"kms_key_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The ARN for a KMS Key that will be used to encrypt customer data.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.LengthBetween(1, 2048),
				stringvalidator.RegexMatches(regexp.MustCompile("^arn:aws[a-z-]*:kms:[a-z0-9\\-]+:\\d{12}:(key|alias)\\/[0-9a-zA-Z-_]*$"), ""),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Name
		// CloudFormation resource type schema:
		//
		//	{
		//	  "maxLength": 64,
		//	  "minLength": 1,
		//	  "pattern": "^[0-9a-zA-Z-_.]+$",
		//	  "type": "string"
		//	}
		"name": schema.StringAttribute{ /*START ATTRIBUTE*/
			Optional: true,
			Computed: true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.LengthBetween(1, 64),
				stringvalidator.RegexMatches(regexp.MustCompile("^[0-9a-zA-Z-_.]+$"), ""),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
				stringplanmodifier.RequiresReplaceIfConfigured(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: ScheduleExpression
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The scheduling expression.",
		//	  "maxLength": 256,
		//	  "minLength": 1,
		//	  "type": "string"
		//	}
		"schedule_expression": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The scheduling expression.",
			Required:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.LengthBetween(1, 256),
			}, /*END VALIDATORS*/
		}, /*END ATTRIBUTE*/
		// Property: ScheduleExpressionTimezone
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The timezone in which the scheduling expression is evaluated.",
		//	  "maxLength": 50,
		//	  "minLength": 1,
		//	  "type": "string"
		//	}
		"schedule_expression_timezone": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The timezone in which the scheduling expression is evaluated.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.LengthBetween(1, 50),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: StartDate
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The date, in UTC, after which the schedule can begin invoking its target. Depending on the schedule's recurrence expression, invocations might occur on, or after, the StartDate you specify.",
		//	  "format": "date-time",
		//	  "type": "string"
		//	}
		"start_date": schema.StringAttribute{ /*START ATTRIBUTE*/
			CustomType:  timetypes.RFC3339Type{},
			Description: "The date, in UTC, after which the schedule can begin invoking its target. Depending on the schedule's recurrence expression, invocations might occur on, or after, the StartDate you specify.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: State
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "Specifies whether the schedule is enabled or disabled.",
		//	  "enum": [
		//	    "ENABLED",
		//	    "DISABLED"
		//	  ],
		//	  "type": "string"
		//	}
		"state": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "Specifies whether the schedule is enabled or disabled.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.OneOf(
					"ENABLED",
					"DISABLED",
				),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Target
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "The schedule target.",
		//	  "properties": {
		//	    "Arn": {
		//	      "description": "The Amazon Resource Name (ARN) of the target.",
		//	      "maxLength": 1600,
		//	      "minLength": 1,
		//	      "type": "string"
		//	    },
		//	    "DeadLetterConfig": {
		//	      "additionalProperties": false,
		//	      "description": "A DeadLetterConfig object that contains information about a dead-letter queue configuration.",
		//	      "properties": {
		//	        "Arn": {
		//	          "description": "The ARN of the SQS queue specified as the target for the dead-letter queue.",
		//	          "maxLength": 1600,
		//	          "minLength": 1,
		//	          "pattern": "^arn:aws[a-z-]*:sqs:[a-z0-9\\-]+:\\d{12}:[a-zA-Z0-9\\-_]+$",
		//	          "type": "string"
		//	        }
		//	      },
		//	      "type": "object"
		//	    },
		//	    "EcsParameters": {
		//	      "additionalProperties": false,
		//	      "description": "The custom parameters to be used when the target is an Amazon ECS task.",
		//	      "properties": {
		//	        "CapacityProviderStrategy": {
		//	          "description": "The capacity provider strategy to use for the task.",
		//	          "insertionOrder": false,
		//	          "items": {
		//	            "additionalProperties": false,
		//	            "description": "The details of a capacity provider strategy.",
		//	            "properties": {
		//	              "Base": {
		//	                "default": 0,
		//	                "description": "The base value designates how many tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined. If no value is specified, the default value of 0 is used.",
		//	                "maximum": 100000,
		//	                "minimum": 0,
		//	                "type": "number"
		//	              },
		//	              "CapacityProvider": {
		//	                "description": "The short name of the capacity provider.",
		//	                "maxLength": 255,
		//	                "minLength": 1,
		//	                "type": "string"
		//	              },
		//	              "Weight": {
		//	                "default": 0,
		//	                "description": "The weight value designates the relative percentage of the total number of tasks launched that should use the specified capacity provider. The weight value is taken into consideration after the base value, if defined, is satisfied.",
		//	                "maximum": 1000,
		//	                "minimum": 0,
		//	                "type": "number"
		//	              }
		//	            },
		//	            "required": [
		//	              "CapacityProvider"
		//	            ],
		//	            "type": "object"
		//	          },
		//	          "maxItems": 6,
		//	          "type": "array"
		//	        },
		//	        "EnableECSManagedTags": {
		//	          "description": "Specifies whether to enable Amazon ECS managed tags for the task. For more information, see Tagging Your Amazon ECS Resources in the Amazon Elastic Container Service Developer Guide.",
		//	          "type": "boolean"
		//	        },
		//	        "EnableExecuteCommand": {
		//	          "description": "Whether or not to enable the execute command functionality for the containers in this task. If true, this enables execute command functionality on all containers in the task.",
		//	          "type": "boolean"
		//	        },
		//	        "Group": {
		//	          "description": "Specifies an ECS task group for the task. The maximum length is 255 characters.",
		//	          "maxLength": 255,
		//	          "minLength": 1,
		//	          "type": "string"
		//	        },
		//	        "LaunchType": {
		//	          "description": "Specifies the launch type on which your task is running. The launch type that you specify here must match one of the launch type (compatibilities) of the target task. The FARGATE value is supported only in the Regions where AWS Fargate with Amazon ECS is supported. For more information, see AWS Fargate on Amazon ECS in the Amazon Elastic Container Service Developer Guide.",
		//	          "enum": [
		//	            "EC2",
		//	            "FARGATE",
		//	            "EXTERNAL"
		//	          ],
		//	          "type": "string"
		//	        },
		//	        "NetworkConfiguration": {
		//	          "additionalProperties": false,
		//	          "description": "This structure specifies the network configuration for an ECS task.",
		//	          "properties": {
		//	            "AwsvpcConfiguration": {
		//	              "additionalProperties": false,
		//	              "description": "This structure specifies the VPC subnets and security groups for the task, and whether a public IP address is to be used. This structure is relevant only for ECS tasks that use the awsvpc network mode.",
		//	              "properties": {
		//	                "AssignPublicIp": {
		//	                  "description": "Specifies whether the task's elastic network interface receives a public IP address. You can specify ENABLED only when LaunchType in EcsParameters is set to FARGATE.",
		//	                  "enum": [
		//	                    "ENABLED",
		//	                    "DISABLED"
		//	                  ],
		//	                  "type": "string"
		//	                },
		//	                "SecurityGroups": {
		//	                  "description": "Specifies the security groups associated with the task. These security groups must all be in the same VPC. You can specify as many as five security groups. If you do not specify a security group, the default security group for the VPC is used.",
		//	                  "insertionOrder": false,
		//	                  "items": {
		//	                    "description": "Specifies the security group associated with the task.",
		//	                    "maxLength": 1000,
		//	                    "minLength": 1,
		//	                    "type": "string"
		//	                  },
		//	                  "maxItems": 5,
		//	                  "minItems": 1,
		//	                  "type": "array"
		//	                },
		//	                "Subnets": {
		//	                  "description": "Specifies the subnets associated with the task. These subnets must all be in the same VPC. You can specify as many as 16 subnets.",
		//	                  "insertionOrder": false,
		//	                  "items": {
		//	                    "description": "Specifies the subnet associated with the task.",
		//	                    "maxLength": 1000,
		//	                    "minLength": 1,
		//	                    "type": "string"
		//	                  },
		//	                  "maxItems": 16,
		//	                  "minItems": 1,
		//	                  "type": "array"
		//	                }
		//	              },
		//	              "required": [
		//	                "Subnets"
		//	              ],
		//	              "type": "object"
		//	            }
		//	          },
		//	          "type": "object"
		//	        },
		//	        "PlacementConstraints": {
		//	          "description": "An array of placement constraint objects to use for the task. You can specify up to 10 constraints per task (including constraints in the task definition and those specified at runtime).",
		//	          "insertionOrder": false,
		//	          "items": {
		//	            "additionalProperties": false,
		//	            "description": "An object representing a constraint on task placement.",
		//	            "properties": {
		//	              "Expression": {
		//	                "description": "A cluster query language expression to apply to the constraint. You cannot specify an expression if the constraint type is distinctInstance. To learn more, see Cluster Query Language in the Amazon Elastic Container Service Developer Guide.",
		//	                "maxLength": 2000,
		//	                "type": "string"
		//	              },
		//	              "Type": {
		//	                "description": "The type of constraint. Use distinctInstance to ensure that each task in a particular group is running on a different container instance. Use memberOf to restrict the selection to a group of valid candidates.",
		//	                "enum": [
		//	                  "distinctInstance",
		//	                  "memberOf"
		//	                ],
		//	                "type": "string"
		//	              }
		//	            },
		//	            "type": "object"
		//	          },
		//	          "maxItems": 10,
		//	          "type": "array"
		//	        },
		//	        "PlacementStrategy": {
		//	          "description": "The placement strategy objects to use for the task. You can specify a maximum of five strategy rules per task.",
		//	          "insertionOrder": false,
		//	          "items": {
		//	            "additionalProperties": false,
		//	            "description": "The task placement strategy for a task or service.",
		//	            "properties": {
		//	              "Field": {
		//	                "description": "The field to apply the placement strategy against. For the spread placement strategy, valid values are instanceId (or host, which has the same effect), or any platform or custom attribute that is applied to a container instance, such as attribute:ecs.availability-zone. For the binpack placement strategy, valid values are cpu and memory. For the random placement strategy, this field is not used.",
		//	                "maxLength": 255,
		//	                "type": "string"
		//	              },
		//	              "Type": {
		//	                "description": "The type of placement strategy. The random placement strategy randomly places tasks on available candidates. The spread placement strategy spreads placement across available candidates evenly based on the field parameter. The binpack strategy places tasks on available candidates that have the least available amount of the resource that is specified with the field parameter. For example, if you binpack on memory, a task is placed on the instance with the least amount of remaining memory (but still enough to run the task).",
		//	                "enum": [
		//	                  "random",
		//	                  "spread",
		//	                  "binpack"
		//	                ],
		//	                "type": "string"
		//	              }
		//	            },
		//	            "type": "object"
		//	          },
		//	          "maxItems": 5,
		//	          "type": "array"
		//	        },
		//	        "PlatformVersion": {
		//	          "description": "Specifies the platform version for the task. Specify only the numeric portion of the platform version, such as 1.1.0.",
		//	          "maxLength": 64,
		//	          "minLength": 1,
		//	          "type": "string"
		//	        },
		//	        "PropagateTags": {
		//	          "description": "Specifies whether to propagate the tags from the task definition to the task. If no value is specified, the tags are not propagated. Tags can only be propagated to the task during task creation. To add tags to a task after task creation, use the TagResource API action.",
		//	          "enum": [
		//	            "TASK_DEFINITION"
		//	          ],
		//	          "type": "string"
		//	        },
		//	        "ReferenceId": {
		//	          "description": "The reference ID to use for the task.",
		//	          "maxLength": 1024,
		//	          "type": "string"
		//	        },
		//	        "Tags": {
		//	          "description": "The metadata that you apply to the task to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. To learn more, see RunTask in the Amazon ECS API Reference.",
		//	          "insertionOrder": false,
		//	          "items": {
		//	            "additionalProperties": false,
		//	            "patternProperties": {
		//	              "": {
		//	                "maxLength": 256,
		//	                "minLength": 1,
		//	                "type": "string"
		//	              }
		//	            },
		//	            "type": "object"
		//	          },
		//	          "maxItems": 50,
		//	          "minItems": 0,
		//	          "type": "array"
		//	        },
		//	        "TaskCount": {
		//	          "description": "The number of tasks to create based on TaskDefinition. The default is 1.",
		//	          "maximum": 10,
		//	          "minimum": 1,
		//	          "type": "number"
		//	        },
		//	        "TaskDefinitionArn": {
		//	          "description": "The ARN of the task definition to use if the event target is an Amazon ECS task.",
		//	          "maxLength": 1600,
		//	          "minLength": 1,
		//	          "type": "string"
		//	        }
		//	      },
		//	      "required": [
		//	        "TaskDefinitionArn"
		//	      ],
		//	      "type": "object"
		//	    },
		//	    "EventBridgeParameters": {
		//	      "additionalProperties": false,
		//	      "description": "EventBridge PutEvent predefined target type.",
		//	      "properties": {
		//	        "DetailType": {
		//	          "description": "Free-form string, with a maximum of 128 characters, used to decide what fields to expect in the event detail.",
		//	          "maxLength": 128,
		//	          "minLength": 1,
		//	          "type": "string"
		//	        },
		//	        "Source": {
		//	          "description": "The source of the event.",
		//	          "maxLength": 256,
		//	          "minLength": 1,
		//	          "pattern": "",
		//	          "type": "string"
		//	        }
		//	      },
		//	      "required": [
		//	        "DetailType",
		//	        "Source"
		//	      ],
		//	      "type": "object"
		//	    },
		//	    "Input": {
		//	      "description": "The text, or well-formed JSON, passed to the target. If you are configuring a templated Lambda, AWS Step Functions, or Amazon EventBridge target, the input must be a well-formed JSON. For all other target types, a JSON is not required. If you do not specify anything for this field, EventBridge Scheduler delivers a default notification to the target.",
		//	      "minLength": 1,
		//	      "type": "string"
		//	    },
		//	    "KinesisParameters": {
		//	      "additionalProperties": false,
		//	      "description": "The custom parameter you can use to control the shard to which EventBridge Scheduler sends the event.",
		//	      "properties": {
		//	        "PartitionKey": {
		//	          "description": "The custom parameter used as the Kinesis partition key. For more information, see Amazon Kinesis Streams Key Concepts in the Amazon Kinesis Streams Developer Guide.",
		//	          "maxLength": 256,
		//	          "minLength": 1,
		//	          "type": "string"
		//	        }
		//	      },
		//	      "required": [
		//	        "PartitionKey"
		//	      ],
		//	      "type": "object"
		//	    },
		//	    "RetryPolicy": {
		//	      "additionalProperties": false,
		//	      "description": "A RetryPolicy object that includes information about the retry policy settings.",
		//	      "properties": {
		//	        "MaximumEventAgeInSeconds": {
		//	          "description": "The maximum amount of time, in seconds, to continue to make retry attempts.",
		//	          "maximum": 86400,
		//	          "minimum": 60,
		//	          "type": "number"
		//	        },
		//	        "MaximumRetryAttempts": {
		//	          "description": "The maximum number of retry attempts to make before the request fails. Retry attempts with exponential backoff continue until either the maximum number of attempts is made or until the duration of the MaximumEventAgeInSeconds is reached.",
		//	          "maximum": 185,
		//	          "minimum": 0,
		//	          "type": "number"
		//	        }
		//	      },
		//	      "type": "object"
		//	    },
		//	    "RoleArn": {
		//	      "description": "The Amazon Resource Name (ARN) of the IAM role to be used for this target when the schedule is triggered.",
		//	      "maxLength": 1600,
		//	      "minLength": 1,
		//	      "pattern": "^arn:aws[a-z-]*:iam::\\d{12}:role\\/[\\w+=,.@\\/-]+$",
		//	      "type": "string"
		//	    },
		//	    "SageMakerPipelineParameters": {
		//	      "additionalProperties": false,
		//	      "description": "These are custom parameters to use when the target is a SageMaker Model Building Pipeline that starts based on AWS EventBridge Scheduler schedules.",
		//	      "properties": {
		//	        "PipelineParameterList": {
		//	          "description": "List of Parameter names and values for SageMaker Model Building Pipeline execution.",
		//	          "insertionOrder": false,
		//	          "items": {
		//	            "additionalProperties": false,
		//	            "description": "Name/Value pair of a parameter to start execution of a SageMaker Model Building Pipeline.",
		//	            "properties": {
		//	              "Name": {
		//	                "description": "Name of parameter to start execution of a SageMaker Model Building Pipeline.",
		//	                "maxLength": 256,
		//	                "minLength": 1,
		//	                "pattern": "^[A-Za-z0-9\\-_]*$",
		//	                "type": "string"
		//	              },
		//	              "Value": {
		//	                "description": "Value of parameter to start execution of a SageMaker Model Building Pipeline.",
		//	                "maxLength": 1024,
		//	                "minLength": 1,
		//	                "type": "string"
		//	              }
		//	            },
		//	            "required": [
		//	              "Name",
		//	              "Value"
		//	            ],
		//	            "type": "object"
		//	          },
		//	          "maxItems": 200,
		//	          "minItems": 0,
		//	          "type": "array"
		//	        }
		//	      },
		//	      "type": "object"
		//	    },
		//	    "SqsParameters": {
		//	      "additionalProperties": false,
		//	      "description": "Contains the message group ID to use when the target is a FIFO queue. If you specify an SQS FIFO queue as a target, the queue must have content-based deduplication enabled.",
		//	      "properties": {
		//	        "MessageGroupId": {
		//	          "description": "The FIFO message group ID to use as the target.",
		//	          "maxLength": 128,
		//	          "minLength": 1,
		//	          "type": "string"
		//	        }
		//	      },
		//	      "type": "object"
		//	    }
		//	  },
		//	  "required": [
		//	    "Arn",
		//	    "RoleArn"
		//	  ],
		//	  "type": "object"
		//	}
		"target": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: Arn
				"arn": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "The Amazon Resource Name (ARN) of the target.",
					Required:    true,
					Validators: []validator.String{ /*START VALIDATORS*/
						stringvalidator.LengthBetween(1, 1600),
					}, /*END VALIDATORS*/
				}, /*END ATTRIBUTE*/
				// Property: DeadLetterConfig
				"dead_letter_config": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
					Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
						// Property: Arn
						"arn": schema.StringAttribute{ /*START ATTRIBUTE*/
							Description: "The ARN of the SQS queue specified as the target for the dead-letter queue.",
							Optional:    true,
							Computed:    true,
							Validators: []validator.String{ /*START VALIDATORS*/
								stringvalidator.LengthBetween(1, 1600),
								stringvalidator.RegexMatches(regexp.MustCompile("^arn:aws[a-z-]*:sqs:[a-z0-9\\-]+:\\d{12}:[a-zA-Z0-9\\-_]+$"), ""),
							}, /*END VALIDATORS*/
							PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
								stringplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
					}, /*END SCHEMA*/
					Description: "A DeadLetterConfig object that contains information about a dead-letter queue configuration.",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
						objectplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: EcsParameters
				"ecs_parameters": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
					Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
						// Property: CapacityProviderStrategy
						"capacity_provider_strategy": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
							NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
								Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
									// Property: Base
									"base": schema.Float64Attribute{ /*START ATTRIBUTE*/
										Description: "The base value designates how many tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined. If no value is specified, the default value of 0 is used.",
										Optional:    true,
										Computed:    true,
										Default:     float64default.StaticFloat64(0.000000),
										Validators: []validator.Float64{ /*START VALIDATORS*/
											float64validator.Between(0.000000, 100000.000000),
										}, /*END VALIDATORS*/
										PlanModifiers: []planmodifier.Float64{ /*START PLAN MODIFIERS*/
											float64planmodifier.UseStateForUnknown(),
										}, /*END PLAN MODIFIERS*/
									}, /*END ATTRIBUTE*/
									// Property: CapacityProvider
									"capacity_provider": schema.StringAttribute{ /*START ATTRIBUTE*/
										Description: "The short name of the capacity provider.",
										Optional:    true,
										Computed:    true,
										Validators: []validator.String{ /*START VALIDATORS*/
											stringvalidator.LengthBetween(1, 255),
											fwvalidators.NotNullString(),
										}, /*END VALIDATORS*/
										PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
											stringplanmodifier.UseStateForUnknown(),
										}, /*END PLAN MODIFIERS*/
									}, /*END ATTRIBUTE*/
									// Property: Weight
									"weight": schema.Float64Attribute{ /*START ATTRIBUTE*/
										Description: "The weight value designates the relative percentage of the total number of tasks launched that should use the specified capacity provider. The weight value is taken into consideration after the base value, if defined, is satisfied.",
										Optional:    true,
										Computed:    true,
										Default:     float64default.StaticFloat64(0.000000),
										Validators: []validator.Float64{ /*START VALIDATORS*/
											float64validator.Between(0.000000, 1000.000000),
										}, /*END VALIDATORS*/
										PlanModifiers: []planmodifier.Float64{ /*START PLAN MODIFIERS*/
											float64planmodifier.UseStateForUnknown(),
										}, /*END PLAN MODIFIERS*/
									}, /*END ATTRIBUTE*/
								}, /*END SCHEMA*/
							}, /*END NESTED OBJECT*/
							Description: "The capacity provider strategy to use for the task.",
							Optional:    true,
							Computed:    true,
							Validators: []validator.List{ /*START VALIDATORS*/
								listvalidator.SizeAtMost(6),
							}, /*END VALIDATORS*/
							PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
								generic.Multiset(),
								listplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
						// Property: EnableECSManagedTags
						"enable_ecs_managed_tags": schema.BoolAttribute{ /*START ATTRIBUTE*/
							Description: "Specifies whether to enable Amazon ECS managed tags for the task. For more information, see Tagging Your Amazon ECS Resources in the Amazon Elastic Container Service Developer Guide.",
							Optional:    true,
							Computed:    true,
							PlanModifiers: []planmodifier.Bool{ /*START PLAN MODIFIERS*/
								boolplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
						// Property: EnableExecuteCommand
						"enable_execute_command": schema.BoolAttribute{ /*START ATTRIBUTE*/
							Description: "Whether or not to enable the execute command functionality for the containers in this task. If true, this enables execute command functionality on all containers in the task.",
							Optional:    true,
							Computed:    true,
							PlanModifiers: []planmodifier.Bool{ /*START PLAN MODIFIERS*/
								boolplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
						// Property: Group
						"group": schema.StringAttribute{ /*START ATTRIBUTE*/
							Description: "Specifies an ECS task group for the task. The maximum length is 255 characters.",
							Optional:    true,
							Computed:    true,
							Validators: []validator.String{ /*START VALIDATORS*/
								stringvalidator.LengthBetween(1, 255),
							}, /*END VALIDATORS*/
							PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
								stringplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
						// Property: LaunchType
						"launch_type": schema.StringAttribute{ /*START ATTRIBUTE*/
							Description: "Specifies the launch type on which your task is running. The launch type that you specify here must match one of the launch type (compatibilities) of the target task. The FARGATE value is supported only in the Regions where AWS Fargate with Amazon ECS is supported. For more information, see AWS Fargate on Amazon ECS in the Amazon Elastic Container Service Developer Guide.",
							Optional:    true,
							Computed:    true,
							Validators: []validator.String{ /*START VALIDATORS*/
								stringvalidator.OneOf(
									"EC2",
									"FARGATE",
									"EXTERNAL",
								),
							}, /*END VALIDATORS*/
							PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
								stringplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
						// Property: NetworkConfiguration
						"network_configuration": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: AwsvpcConfiguration
								"awsvpc_configuration": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
									Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
										// Property: AssignPublicIp
										"assign_public_ip": schema.StringAttribute{ /*START ATTRIBUTE*/
											Description: "Specifies whether the task's elastic network interface receives a public IP address. You can specify ENABLED only when LaunchType in EcsParameters is set to FARGATE.",
											Optional:    true,
											Computed:    true,
											Validators: []validator.String{ /*START VALIDATORS*/
												stringvalidator.OneOf(
													"ENABLED",
													"DISABLED",
												),
											}, /*END VALIDATORS*/
											PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
												stringplanmodifier.UseStateForUnknown(),
											}, /*END PLAN MODIFIERS*/
										}, /*END ATTRIBUTE*/
										// Property: SecurityGroups
										"security_groups": schema.ListAttribute{ /*START ATTRIBUTE*/
											ElementType: types.StringType,
											Description: "Specifies the security groups associated with the task. These security groups must all be in the same VPC. You can specify as many as five security groups. If you do not specify a security group, the default security group for the VPC is used.",
											Optional:    true,
											Computed:    true,
											Validators: []validator.List{ /*START VALIDATORS*/
												listvalidator.SizeBetween(1, 5),
												listvalidator.ValueStringsAre(
													stringvalidator.LengthBetween(1, 1000),
												),
											}, /*END VALIDATORS*/
											PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
												generic.Multiset(),
												listplanmodifier.UseStateForUnknown(),
											}, /*END PLAN MODIFIERS*/
										}, /*END ATTRIBUTE*/
										// Property: Subnets
										"subnets": schema.ListAttribute{ /*START ATTRIBUTE*/
											ElementType: types.StringType,
											Description: "Specifies the subnets associated with the task. These subnets must all be in the same VPC. You can specify as many as 16 subnets.",
											Optional:    true,
											Computed:    true,
											Validators: []validator.List{ /*START VALIDATORS*/
												listvalidator.SizeBetween(1, 16),
												listvalidator.ValueStringsAre(
													stringvalidator.LengthBetween(1, 1000),
												),
												fwvalidators.NotNullList(),
											}, /*END VALIDATORS*/
											PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
												generic.Multiset(),
												listplanmodifier.UseStateForUnknown(),
											}, /*END PLAN MODIFIERS*/
										}, /*END ATTRIBUTE*/
									}, /*END SCHEMA*/
									Description: "This structure specifies the VPC subnets and security groups for the task, and whether a public IP address is to be used. This structure is relevant only for ECS tasks that use the awsvpc network mode.",
									Optional:    true,
									Computed:    true,
									PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
										objectplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
							Description: "This structure specifies the network configuration for an ECS task.",
							Optional:    true,
							Computed:    true,
							PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
								objectplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
						// Property: PlacementConstraints
						"placement_constraints": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
							NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
								Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
									// Property: Expression
									"expression": schema.StringAttribute{ /*START ATTRIBUTE*/
										Description: "A cluster query language expression to apply to the constraint. You cannot specify an expression if the constraint type is distinctInstance. To learn more, see Cluster Query Language in the Amazon Elastic Container Service Developer Guide.",
										Optional:    true,
										Computed:    true,
										Validators: []validator.String{ /*START VALIDATORS*/
											stringvalidator.LengthAtMost(2000),
										}, /*END VALIDATORS*/
										PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
											stringplanmodifier.UseStateForUnknown(),
										}, /*END PLAN MODIFIERS*/
									}, /*END ATTRIBUTE*/
									// Property: Type
									"type": schema.StringAttribute{ /*START ATTRIBUTE*/
										Description: "The type of constraint. Use distinctInstance to ensure that each task in a particular group is running on a different container instance. Use memberOf to restrict the selection to a group of valid candidates.",
										Optional:    true,
										Computed:    true,
										Validators: []validator.String{ /*START VALIDATORS*/
											stringvalidator.OneOf(
												"distinctInstance",
												"memberOf",
											),
										}, /*END VALIDATORS*/
										PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
											stringplanmodifier.UseStateForUnknown(),
										}, /*END PLAN MODIFIERS*/
									}, /*END ATTRIBUTE*/
								}, /*END SCHEMA*/
							}, /*END NESTED OBJECT*/
							Description: "An array of placement constraint objects to use for the task. You can specify up to 10 constraints per task (including constraints in the task definition and those specified at runtime).",
							Optional:    true,
							Computed:    true,
							Validators: []validator.List{ /*START VALIDATORS*/
								listvalidator.SizeAtMost(10),
							}, /*END VALIDATORS*/
							PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
								generic.Multiset(),
								listplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
						// Property: PlacementStrategy
						"placement_strategy": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
							NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
								Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
									// Property: Field
									"field": schema.StringAttribute{ /*START ATTRIBUTE*/
										Description: "The field to apply the placement strategy against. For the spread placement strategy, valid values are instanceId (or host, which has the same effect), or any platform or custom attribute that is applied to a container instance, such as attribute:ecs.availability-zone. For the binpack placement strategy, valid values are cpu and memory. For the random placement strategy, this field is not used.",
										Optional:    true,
										Computed:    true,
										Validators: []validator.String{ /*START VALIDATORS*/
											stringvalidator.LengthAtMost(255),
										}, /*END VALIDATORS*/
										PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
											stringplanmodifier.UseStateForUnknown(),
										}, /*END PLAN MODIFIERS*/
									}, /*END ATTRIBUTE*/
									// Property: Type
									"type": schema.StringAttribute{ /*START ATTRIBUTE*/
										Description: "The type of placement strategy. The random placement strategy randomly places tasks on available candidates. The spread placement strategy spreads placement across available candidates evenly based on the field parameter. The binpack strategy places tasks on available candidates that have the least available amount of the resource that is specified with the field parameter. For example, if you binpack on memory, a task is placed on the instance with the least amount of remaining memory (but still enough to run the task).",
										Optional:    true,
										Computed:    true,
										Validators: []validator.String{ /*START VALIDATORS*/
											stringvalidator.OneOf(
												"random",
												"spread",
												"binpack",
											),
										}, /*END VALIDATORS*/
										PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
											stringplanmodifier.UseStateForUnknown(),
										}, /*END PLAN MODIFIERS*/
									}, /*END ATTRIBUTE*/
								}, /*END SCHEMA*/
							}, /*END NESTED OBJECT*/
							Description: "The placement strategy objects to use for the task. You can specify a maximum of five strategy rules per task.",
							Optional:    true,
							Computed:    true,
							Validators: []validator.List{ /*START VALIDATORS*/
								listvalidator.SizeAtMost(5),
							}, /*END VALIDATORS*/
							PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
								generic.Multiset(),
								listplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
						// Property: PlatformVersion
						"platform_version": schema.StringAttribute{ /*START ATTRIBUTE*/
							Description: "Specifies the platform version for the task. Specify only the numeric portion of the platform version, such as 1.1.0.",
							Optional:    true,
							Computed:    true,
							Validators: []validator.String{ /*START VALIDATORS*/
								stringvalidator.LengthBetween(1, 64),
							}, /*END VALIDATORS*/
							PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
								stringplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
						// Property: PropagateTags
						"propagate_tags": schema.StringAttribute{ /*START ATTRIBUTE*/
							Description: "Specifies whether to propagate the tags from the task definition to the task. If no value is specified, the tags are not propagated. Tags can only be propagated to the task during task creation. To add tags to a task after task creation, use the TagResource API action.",
							Optional:    true,
							Computed:    true,
							Validators: []validator.String{ /*START VALIDATORS*/
								stringvalidator.OneOf(
									"TASK_DEFINITION",
								),
							}, /*END VALIDATORS*/
							PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
								stringplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
						// Property: ReferenceId
						"reference_id": schema.StringAttribute{ /*START ATTRIBUTE*/
							Description: "The reference ID to use for the task.",
							Optional:    true,
							Computed:    true,
							Validators: []validator.String{ /*START VALIDATORS*/
								stringvalidator.LengthAtMost(1024),
							}, /*END VALIDATORS*/
							PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
								stringplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
						// Property: Tags
						"tags": schema.ListAttribute{ /*START ATTRIBUTE*/
							ElementType: types.ListType{ElemType: types.StringType},
							Description: "The metadata that you apply to the task to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. To learn more, see RunTask in the Amazon ECS API Reference.",
							Optional:    true,
							Computed:    true,
							Validators: []validator.List{ /*START VALIDATORS*/
								listvalidator.SizeBetween(0, 50),
							}, /*END VALIDATORS*/
							PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
								generic.Multiset(),
								listplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
						// Property: TaskCount
						"task_count": schema.Float64Attribute{ /*START ATTRIBUTE*/
							Description: "The number of tasks to create based on TaskDefinition. The default is 1.",
							Optional:    true,
							Computed:    true,
							Validators: []validator.Float64{ /*START VALIDATORS*/
								float64validator.Between(1.000000, 10.000000),
							}, /*END VALIDATORS*/
							PlanModifiers: []planmodifier.Float64{ /*START PLAN MODIFIERS*/
								float64planmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
						// Property: TaskDefinitionArn
						"task_definition_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
							Description: "The ARN of the task definition to use if the event target is an Amazon ECS task.",
							Optional:    true,
							Computed:    true,
							Validators: []validator.String{ /*START VALIDATORS*/
								stringvalidator.LengthBetween(1, 1600),
								fwvalidators.NotNullString(),
							}, /*END VALIDATORS*/
							PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
								stringplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
					}, /*END SCHEMA*/
					Description: "The custom parameters to be used when the target is an Amazon ECS task.",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
						objectplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: EventBridgeParameters
				"event_bridge_parameters": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
					Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
						// Property: DetailType
						"detail_type": schema.StringAttribute{ /*START ATTRIBUTE*/
							Description: "Free-form string, with a maximum of 128 characters, used to decide what fields to expect in the event detail.",
							Optional:    true,
							Computed:    true,
							Validators: []validator.String{ /*START VALIDATORS*/
								stringvalidator.LengthBetween(1, 128),
								fwvalidators.NotNullString(),
							}, /*END VALIDATORS*/
							PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
								stringplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
						// Property: Source
						"source": schema.StringAttribute{ /*START ATTRIBUTE*/
							Description: "The source of the event.",
							Optional:    true,
							Computed:    true,
							Validators: []validator.String{ /*START VALIDATORS*/
								stringvalidator.LengthBetween(1, 256),
								fwvalidators.NotNullString(),
							}, /*END VALIDATORS*/
							PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
								stringplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
					}, /*END SCHEMA*/
					Description: "EventBridge PutEvent predefined target type.",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
						objectplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: Input
				"input": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "The text, or well-formed JSON, passed to the target. If you are configuring a templated Lambda, AWS Step Functions, or Amazon EventBridge target, the input must be a well-formed JSON. For all other target types, a JSON is not required. If you do not specify anything for this field, EventBridge Scheduler delivers a default notification to the target.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.String{ /*START VALIDATORS*/
						stringvalidator.LengthAtLeast(1),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: KinesisParameters
				"kinesis_parameters": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
					Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
						// Property: PartitionKey
						"partition_key": schema.StringAttribute{ /*START ATTRIBUTE*/
							Description: "The custom parameter used as the Kinesis partition key. For more information, see Amazon Kinesis Streams Key Concepts in the Amazon Kinesis Streams Developer Guide.",
							Optional:    true,
							Computed:    true,
							Validators: []validator.String{ /*START VALIDATORS*/
								stringvalidator.LengthBetween(1, 256),
								fwvalidators.NotNullString(),
							}, /*END VALIDATORS*/
							PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
								stringplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
					}, /*END SCHEMA*/
					Description: "The custom parameter you can use to control the shard to which EventBridge Scheduler sends the event.",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
						objectplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: RetryPolicy
				"retry_policy": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
					Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
						// Property: MaximumEventAgeInSeconds
						"maximum_event_age_in_seconds": schema.Float64Attribute{ /*START ATTRIBUTE*/
							Description: "The maximum amount of time, in seconds, to continue to make retry attempts.",
							Optional:    true,
							Computed:    true,
							Validators: []validator.Float64{ /*START VALIDATORS*/
								float64validator.Between(60.000000, 86400.000000),
							}, /*END VALIDATORS*/
							PlanModifiers: []planmodifier.Float64{ /*START PLAN MODIFIERS*/
								float64planmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
						// Property: MaximumRetryAttempts
						"maximum_retry_attempts": schema.Float64Attribute{ /*START ATTRIBUTE*/
							Description: "The maximum number of retry attempts to make before the request fails. Retry attempts with exponential backoff continue until either the maximum number of attempts is made or until the duration of the MaximumEventAgeInSeconds is reached.",
							Optional:    true,
							Computed:    true,
							Validators: []validator.Float64{ /*START VALIDATORS*/
								float64validator.Between(0.000000, 185.000000),
							}, /*END VALIDATORS*/
							PlanModifiers: []planmodifier.Float64{ /*START PLAN MODIFIERS*/
								float64planmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
					}, /*END SCHEMA*/
					Description: "A RetryPolicy object that includes information about the retry policy settings.",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
						objectplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: RoleArn
				"role_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "The Amazon Resource Name (ARN) of the IAM role to be used for this target when the schedule is triggered.",
					Required:    true,
					Validators: []validator.String{ /*START VALIDATORS*/
						stringvalidator.LengthBetween(1, 1600),
						stringvalidator.RegexMatches(regexp.MustCompile("^arn:aws[a-z-]*:iam::\\d{12}:role\\/[\\w+=,.@\\/-]+$"), ""),
					}, /*END VALIDATORS*/
				}, /*END ATTRIBUTE*/
				// Property: SageMakerPipelineParameters
				"sage_maker_pipeline_parameters": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
					Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
						// Property: PipelineParameterList
						"pipeline_parameter_list": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
							NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
								Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
									// Property: Name
									"name": schema.StringAttribute{ /*START ATTRIBUTE*/
										Description: "Name of parameter to start execution of a SageMaker Model Building Pipeline.",
										Optional:    true,
										Computed:    true,
										Validators: []validator.String{ /*START VALIDATORS*/
											stringvalidator.LengthBetween(1, 256),
											stringvalidator.RegexMatches(regexp.MustCompile("^[A-Za-z0-9\\-_]*$"), ""),
											fwvalidators.NotNullString(),
										}, /*END VALIDATORS*/
										PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
											stringplanmodifier.UseStateForUnknown(),
										}, /*END PLAN MODIFIERS*/
									}, /*END ATTRIBUTE*/
									// Property: Value
									"value": schema.StringAttribute{ /*START ATTRIBUTE*/
										Description: "Value of parameter to start execution of a SageMaker Model Building Pipeline.",
										Optional:    true,
										Computed:    true,
										Validators: []validator.String{ /*START VALIDATORS*/
											stringvalidator.LengthBetween(1, 1024),
											fwvalidators.NotNullString(),
										}, /*END VALIDATORS*/
										PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
											stringplanmodifier.UseStateForUnknown(),
										}, /*END PLAN MODIFIERS*/
									}, /*END ATTRIBUTE*/
								}, /*END SCHEMA*/
							}, /*END NESTED OBJECT*/
							Description: "List of Parameter names and values for SageMaker Model Building Pipeline execution.",
							Optional:    true,
							Computed:    true,
							Validators: []validator.List{ /*START VALIDATORS*/
								listvalidator.SizeBetween(0, 200),
							}, /*END VALIDATORS*/
							PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
								generic.Multiset(),
								listplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
					}, /*END SCHEMA*/
					Description: "These are custom parameters to use when the target is a SageMaker Model Building Pipeline that starts based on AWS EventBridge Scheduler schedules.",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
						objectplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: SqsParameters
				"sqs_parameters": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
					Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
						// Property: MessageGroupId
						"message_group_id": schema.StringAttribute{ /*START ATTRIBUTE*/
							Description: "The FIFO message group ID to use as the target.",
							Optional:    true,
							Computed:    true,
							Validators: []validator.String{ /*START VALIDATORS*/
								stringvalidator.LengthBetween(1, 128),
							}, /*END VALIDATORS*/
							PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
								stringplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
					}, /*END SCHEMA*/
					Description: "Contains the message group ID to use when the target is a FIFO queue. If you specify an SQS FIFO queue as a target, the queue must have content-based deduplication enabled.",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
						objectplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "The schedule target.",
			Required:    true,
		}, /*END ATTRIBUTE*/
	} /*END SCHEMA*/

	// Corresponds to CloudFormation primaryIdentifier.
	attributes["id"] = schema.StringAttribute{
		Description: "Uniquely identifies the resource.",
		Computed:    true,
		PlanModifiers: []planmodifier.String{
			stringplanmodifier.UseStateForUnknown(),
		},
	}

	schema := schema.Schema{
		Description: "Definition of AWS::Scheduler::Schedule Resource Type",
		Version:     1,
		Attributes:  attributes,
	}

	var opts generic.ResourceOptions

	opts = opts.WithCloudFormationTypeName("AWS::Scheduler::Schedule").WithTerraformTypeName("awscc_scheduler_schedule")
	opts = opts.WithTerraformSchema(schema)
	opts = opts.WithAttributeNameMap(map[string]string{
		"arn":                            "Arn",
		"assign_public_ip":               "AssignPublicIp",
		"awsvpc_configuration":           "AwsvpcConfiguration",
		"base":                           "Base",
		"capacity_provider":              "CapacityProvider",
		"capacity_provider_strategy":     "CapacityProviderStrategy",
		"dead_letter_config":             "DeadLetterConfig",
		"description":                    "Description",
		"detail_type":                    "DetailType",
		"ecs_parameters":                 "EcsParameters",
		"enable_ecs_managed_tags":        "EnableECSManagedTags",
		"enable_execute_command":         "EnableExecuteCommand",
		"end_date":                       "EndDate",
		"event_bridge_parameters":        "EventBridgeParameters",
		"expression":                     "Expression",
		"field":                          "Field",
		"flexible_time_window":           "FlexibleTimeWindow",
		"group":                          "Group",
		"group_name":                     "GroupName",
		"input":                          "Input",
		"kinesis_parameters":             "KinesisParameters",
		"kms_key_arn":                    "KmsKeyArn",
		"launch_type":                    "LaunchType",
		"maximum_event_age_in_seconds":   "MaximumEventAgeInSeconds",
		"maximum_retry_attempts":         "MaximumRetryAttempts",
		"maximum_window_in_minutes":      "MaximumWindowInMinutes",
		"message_group_id":               "MessageGroupId",
		"mode":                           "Mode",
		"name":                           "Name",
		"network_configuration":          "NetworkConfiguration",
		"partition_key":                  "PartitionKey",
		"pipeline_parameter_list":        "PipelineParameterList",
		"placement_constraints":          "PlacementConstraints",
		"placement_strategy":             "PlacementStrategy",
		"platform_version":               "PlatformVersion",
		"propagate_tags":                 "PropagateTags",
		"reference_id":                   "ReferenceId",
		"retry_policy":                   "RetryPolicy",
		"role_arn":                       "RoleArn",
		"sage_maker_pipeline_parameters": "SageMakerPipelineParameters",
		"schedule_expression":            "ScheduleExpression",
		"schedule_expression_timezone":   "ScheduleExpressionTimezone",
		"security_groups":                "SecurityGroups",
		"source":                         "Source",
		"sqs_parameters":                 "SqsParameters",
		"start_date":                     "StartDate",
		"state":                          "State",
		"subnets":                        "Subnets",
		"tags":                           "Tags",
		"target":                         "Target",
		"task_count":                     "TaskCount",
		"task_definition_arn":            "TaskDefinitionArn",
		"type":                           "Type",
		"value":                          "Value",
		"weight":                         "Weight",
	})

	opts = opts.WithCreateTimeoutInMinutes(0).WithDeleteTimeoutInMinutes(0)

	opts = opts.WithUpdateTimeoutInMinutes(0)

	v, err := generic.NewResource(ctx, opts...)

	if err != nil {
		return nil, err
	}

	return v, nil
}
