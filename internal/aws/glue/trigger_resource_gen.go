// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// Code generated by generators/resource/main.go; DO NOT EDIT.

package glue

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework-jsontypes/jsontypes"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-provider-awscc/internal/generic"
	"github.com/hashicorp/terraform-provider-awscc/internal/registry"
	fwvalidators "github.com/hashicorp/terraform-provider-awscc/internal/validators"
)

func init() {
	registry.AddResourceFactory("awscc_glue_trigger", triggerResource)
}

// triggerResource returns the Terraform awscc_glue_trigger resource.
// This Terraform resource corresponds to the CloudFormation AWS::Glue::Trigger resource.
func triggerResource(ctx context.Context) (resource.Resource, error) {
	attributes := map[string]schema.Attribute{ /*START SCHEMA*/
		// Property: Actions
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The actions initiated by this trigger.",
		//	  "items": {
		//	    "additionalProperties": false,
		//	    "description": "The actions initiated by this trigger.",
		//	    "properties": {
		//	      "Arguments": {
		//	        "description": "The job arguments used when this trigger fires. For this job run, they replace the default arguments set in the job definition itself.",
		//	        "type": "object"
		//	      },
		//	      "CrawlerName": {
		//	        "description": "The name of the crawler to be used with this action.",
		//	        "type": "string"
		//	      },
		//	      "JobName": {
		//	        "description": "The name of a job to be executed.",
		//	        "type": "string"
		//	      },
		//	      "NotificationProperty": {
		//	        "additionalProperties": false,
		//	        "description": "Specifies configuration properties of a job run notification.",
		//	        "properties": {
		//	          "NotifyDelayAfter": {
		//	            "description": "After a job run starts, the number of minutes to wait before sending a job run delay notification",
		//	            "type": "integer"
		//	          }
		//	        },
		//	        "type": "object"
		//	      },
		//	      "SecurityConfiguration": {
		//	        "description": "The name of the SecurityConfiguration structure to be used with this action.",
		//	        "type": "string"
		//	      },
		//	      "Timeout": {
		//	        "description": "The JobRun timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours). This overrides the timeout value set in the parent job.",
		//	        "type": "integer"
		//	      }
		//	    },
		//	    "type": "object"
		//	  },
		//	  "type": "array",
		//	  "uniqueItems": false
		//	}
		"actions": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: Arguments
					"arguments": schema.StringAttribute{ /*START ATTRIBUTE*/
						CustomType:  jsontypes.NormalizedType{},
						Description: "The job arguments used when this trigger fires. For this job run, they replace the default arguments set in the job definition itself.",
						Optional:    true,
						Computed:    true,
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: CrawlerName
					"crawler_name": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The name of the crawler to be used with this action.",
						Optional:    true,
						Computed:    true,
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: JobName
					"job_name": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The name of a job to be executed.",
						Optional:    true,
						Computed:    true,
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: NotificationProperty
					"notification_property": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: NotifyDelayAfter
							"notify_delay_after": schema.Int64Attribute{ /*START ATTRIBUTE*/
								Description: "After a job run starts, the number of minutes to wait before sending a job run delay notification",
								Optional:    true,
								Computed:    true,
								PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
									int64planmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
						Description: "Specifies configuration properties of a job run notification.",
						Optional:    true,
						Computed:    true,
						PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
							objectplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: SecurityConfiguration
					"security_configuration": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The name of the SecurityConfiguration structure to be used with this action.",
						Optional:    true,
						Computed:    true,
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: Timeout
					"timeout": schema.Int64Attribute{ /*START ATTRIBUTE*/
						Description: "The JobRun timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours). This overrides the timeout value set in the parent job.",
						Optional:    true,
						Computed:    true,
						PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
							int64planmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Description: "The actions initiated by this trigger.",
			Required:    true,
		}, /*END ATTRIBUTE*/
		// Property: Description
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A description of this trigger.",
		//	  "type": "string"
		//	}
		"description": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "A description of this trigger.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: EventBatchingCondition
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "Batch condition that must be met (specified number of events received or batch time window expired) before EventBridge event trigger fires.",
		//	  "properties": {
		//	    "BatchSize": {
		//	      "description": "Number of events that must be received from Amazon EventBridge before EventBridge event trigger fires.",
		//	      "type": "integer"
		//	    },
		//	    "BatchWindow": {
		//	      "description": "Window of time in seconds after which EventBridge event trigger fires. Window starts when first event is received.",
		//	      "type": "integer"
		//	    }
		//	  },
		//	  "required": [
		//	    "BatchSize"
		//	  ],
		//	  "type": "object"
		//	}
		"event_batching_condition": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: BatchSize
				"batch_size": schema.Int64Attribute{ /*START ATTRIBUTE*/
					Description: "Number of events that must be received from Amazon EventBridge before EventBridge event trigger fires.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.Int64{ /*START VALIDATORS*/
						fwvalidators.NotNullInt64(),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
						int64planmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: BatchWindow
				"batch_window": schema.Int64Attribute{ /*START ATTRIBUTE*/
					Description: "Window of time in seconds after which EventBridge event trigger fires. Window starts when first event is received.",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
						int64planmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "Batch condition that must be met (specified number of events received or batch time window expired) before EventBridge event trigger fires.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Name
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The name of the trigger.",
		//	  "type": "string"
		//	}
		"name": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The name of the trigger.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
				stringplanmodifier.RequiresReplaceIfConfigured(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Predicate
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "The predicate of this trigger, which defines when it will fire.",
		//	  "properties": {
		//	    "Conditions": {
		//	      "description": "A list of the conditions that determine when the trigger will fire.",
		//	      "items": {
		//	        "additionalProperties": false,
		//	        "description": "Defines a condition under which a trigger fires.",
		//	        "properties": {
		//	          "CrawlState": {
		//	            "description": "The state of the crawler to which this condition applies.",
		//	            "type": "string"
		//	          },
		//	          "CrawlerName": {
		//	            "description": "The name of the crawler to which this condition applies.",
		//	            "type": "string"
		//	          },
		//	          "JobName": {
		//	            "description": "The name of the job whose JobRuns this condition applies to, and on which this trigger waits.",
		//	            "type": "string"
		//	          },
		//	          "LogicalOperator": {
		//	            "description": "A logical operator.",
		//	            "type": "string"
		//	          },
		//	          "State": {
		//	            "description": "The condition state. Currently, the values supported are SUCCEEDED, STOPPED, TIMEOUT, and FAILED.",
		//	            "type": "string"
		//	          }
		//	        },
		//	        "type": "object"
		//	      },
		//	      "type": "array",
		//	      "uniqueItems": false
		//	    },
		//	    "Logical": {
		//	      "description": "An optional field if only one condition is listed. If multiple conditions are listed, then this field is required.",
		//	      "type": "string"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"predicate": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: Conditions
				"conditions": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
					NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: CrawlState
							"crawl_state": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "The state of the crawler to which this condition applies.",
								Optional:    true,
								Computed:    true,
								PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
									stringplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: CrawlerName
							"crawler_name": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "The name of the crawler to which this condition applies.",
								Optional:    true,
								Computed:    true,
								PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
									stringplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: JobName
							"job_name": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "The name of the job whose JobRuns this condition applies to, and on which this trigger waits.",
								Optional:    true,
								Computed:    true,
								PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
									stringplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: LogicalOperator
							"logical_operator": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "A logical operator.",
								Optional:    true,
								Computed:    true,
								PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
									stringplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: State
							"state": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "The condition state. Currently, the values supported are SUCCEEDED, STOPPED, TIMEOUT, and FAILED.",
								Optional:    true,
								Computed:    true,
								PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
									stringplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
					}, /*END NESTED OBJECT*/
					Description: "A list of the conditions that determine when the trigger will fire.",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
						listplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: Logical
				"logical": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "An optional field if only one condition is listed. If multiple conditions are listed, then this field is required.",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "The predicate of this trigger, which defines when it will fire.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Schedule
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A cron expression used to specify the schedule.",
		//	  "type": "string"
		//	}
		"schedule": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "A cron expression used to specify the schedule.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: StartOnCreation
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "Set to true to start SCHEDULED and CONDITIONAL triggers when created. True is not supported for ON_DEMAND triggers.",
		//	  "type": "boolean"
		//	}
		"start_on_creation": schema.BoolAttribute{ /*START ATTRIBUTE*/
			Description: "Set to true to start SCHEDULED and CONDITIONAL triggers when created. True is not supported for ON_DEMAND triggers.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Bool{ /*START PLAN MODIFIERS*/
				boolplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
			// StartOnCreation is a write-only property.
		}, /*END ATTRIBUTE*/
		// Property: Tags
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The tags to use with this trigger.",
		//	  "type": "object"
		//	}
		"tags": schema.StringAttribute{ /*START ATTRIBUTE*/
			CustomType:  jsontypes.NormalizedType{},
			Description: "The tags to use with this trigger.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Type
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The type of trigger that this is.",
		//	  "type": "string"
		//	}
		"type": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The type of trigger that this is.",
			Required:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.RequiresReplace(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: WorkflowName
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The name of the workflow associated with the trigger.",
		//	  "type": "string"
		//	}
		"workflow_name": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The name of the workflow associated with the trigger.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
				stringplanmodifier.RequiresReplaceIfConfigured(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
	} /*END SCHEMA*/

	// Corresponds to CloudFormation primaryIdentifier.
	attributes["id"] = schema.StringAttribute{
		Description: "Uniquely identifies the resource.",
		Computed:    true,
		PlanModifiers: []planmodifier.String{
			stringplanmodifier.UseStateForUnknown(),
		},
	}

	schema := schema.Schema{
		Description: "Resource Type definition for AWS::Glue::Trigger",
		Version:     1,
		Attributes:  attributes,
	}

	var opts generic.ResourceOptions

	opts = opts.WithCloudFormationTypeName("AWS::Glue::Trigger").WithTerraformTypeName("awscc_glue_trigger")
	opts = opts.WithTerraformSchema(schema)
	opts = opts.WithAttributeNameMap(map[string]string{
		"actions":                  "Actions",
		"arguments":                "Arguments",
		"batch_size":               "BatchSize",
		"batch_window":             "BatchWindow",
		"conditions":               "Conditions",
		"crawl_state":              "CrawlState",
		"crawler_name":             "CrawlerName",
		"description":              "Description",
		"event_batching_condition": "EventBatchingCondition",
		"job_name":                 "JobName",
		"logical":                  "Logical",
		"logical_operator":         "LogicalOperator",
		"name":                     "Name",
		"notification_property":    "NotificationProperty",
		"notify_delay_after":       "NotifyDelayAfter",
		"predicate":                "Predicate",
		"schedule":                 "Schedule",
		"security_configuration":   "SecurityConfiguration",
		"start_on_creation":        "StartOnCreation",
		"state":                    "State",
		"tags":                     "Tags",
		"timeout":                  "Timeout",
		"type":                     "Type",
		"workflow_name":            "WorkflowName",
	})

	opts = opts.WithWriteOnlyPropertyPaths([]string{
		"/properties/StartOnCreation",
	})
	opts = opts.WithCreateTimeoutInMinutes(0).WithDeleteTimeoutInMinutes(0)

	opts = opts.WithUpdateTimeoutInMinutes(0)

	v, err := generic.NewResource(ctx, opts...)

	if err != nil {
		return nil, err
	}

	return v, nil
}
