// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// Code generated by generators/resource/main.go; DO NOT EDIT.

package secretsmanager

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-provider-awscc/internal/generic"
	"github.com/hashicorp/terraform-provider-awscc/internal/identity"
	"github.com/hashicorp/terraform-provider-awscc/internal/registry"
	fwvalidators "github.com/hashicorp/terraform-provider-awscc/internal/validators"
)

func init() {
	registry.AddResourceFactory("awscc_secretsmanager_rotation_schedule", rotationScheduleResource)
	registry.AddListResourceFactory("awscc_secretsmanager_rotation_schedule", generic.NewListResource(rotationScheduleResource))
}

// rotationScheduleResource returns the Terraform awscc_secretsmanager_rotation_schedule resource.
// This Terraform resource corresponds to the CloudFormation AWS::SecretsManager::RotationSchedule resource.
func rotationScheduleResource(ctx context.Context) (resource.Resource, error) {
	attributes := map[string]schema.Attribute{ /*START SCHEMA*/
		// Property: HostedRotationLambda
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "Creates a new Lambda rotation function based on one of the Secrets Manager rotation function templates. To use a rotation function that already exists, specify RotationLambdaARN instead.",
		//	  "properties": {
		//	    "ExcludeCharacters": {
		//	      "description": "A string of the characters that you don't want in the password.",
		//	      "type": "string"
		//	    },
		//	    "KmsKeyArn": {
		//	      "description": "The ARN of the KMS key that Secrets Manager uses to encrypt the secret. If you don't specify this value, then Secrets Manager uses the key aws/secretsmanager. If aws/secretsmanager doesn't yet exist, then Secrets Manager creates it for you automatically the first time it encrypts the secret value.",
		//	      "type": "string"
		//	    },
		//	    "MasterSecretArn": {
		//	      "description": "The ARN of the secret that contains superuser credentials, if you use the alternating users rotation strategy. CloudFormation grants the execution role for the Lambda rotation function GetSecretValue permission to the secret in this property.",
		//	      "type": "string"
		//	    },
		//	    "MasterSecretKmsKeyArn": {
		//	      "description": "The ARN of the KMS key that Secrets Manager used to encrypt the superuser secret, if you use the alternating users strategy and the superuser secret is encrypted with a customer managed key. You don't need to specify this property if the superuser secret is encrypted using the key aws/secretsmanager. CloudFormation grants the execution role for the Lambda rotation function Decrypt, DescribeKey, and GenerateDataKey permission to the key in this property.",
		//	      "type": "string"
		//	    },
		//	    "RotationLambdaName": {
		//	      "description": "The name of the Lambda rotation function.",
		//	      "type": "string"
		//	    },
		//	    "RotationType": {
		//	      "description": "The type of rotation template to use",
		//	      "type": "string"
		//	    },
		//	    "Runtime": {
		//	      "description": "The python runtime associated with the Lambda function",
		//	      "type": "string"
		//	    },
		//	    "SuperuserSecretArn": {
		//	      "description": "The ARN of the secret that contains superuser credentials, if you use the alternating users rotation strategy. CloudFormation grants the execution role for the Lambda rotation function GetSecretValue permission to the secret in this property.",
		//	      "type": "string"
		//	    },
		//	    "SuperuserSecretKmsKeyArn": {
		//	      "description": "The ARN of the KMS key that Secrets Manager used to encrypt the superuser secret, if you use the alternating users strategy and the superuser secret is encrypted with a customer managed key. You don't need to specify this property if the superuser secret is encrypted using the key aws/secretsmanager. CloudFormation grants the execution role for the Lambda rotation function Decrypt, DescribeKey, and GenerateDataKey permission to the key in this property.",
		//	      "type": "string"
		//	    },
		//	    "VpcSecurityGroupIds": {
		//	      "description": "A comma-separated list of security group IDs applied to the target database.",
		//	      "type": "string"
		//	    },
		//	    "VpcSubnetIds": {
		//	      "description": "A comma separated list of VPC subnet IDs of the target database network. The Lambda rotation function is in the same subnet group.",
		//	      "type": "string"
		//	    }
		//	  },
		//	  "required": [
		//	    "RotationType"
		//	  ],
		//	  "type": "object"
		//	}
		"hosted_rotation_lambda": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: ExcludeCharacters
				"exclude_characters": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "A string of the characters that you don't want in the password.",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
					// ExcludeCharacters is a write-only property.
				}, /*END ATTRIBUTE*/
				// Property: KmsKeyArn
				"kms_key_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "The ARN of the KMS key that Secrets Manager uses to encrypt the secret. If you don't specify this value, then Secrets Manager uses the key aws/secretsmanager. If aws/secretsmanager doesn't yet exist, then Secrets Manager creates it for you automatically the first time it encrypts the secret value.",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
					// KmsKeyArn is a write-only property.
				}, /*END ATTRIBUTE*/
				// Property: MasterSecretArn
				"master_secret_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "The ARN of the secret that contains superuser credentials, if you use the alternating users rotation strategy. CloudFormation grants the execution role for the Lambda rotation function GetSecretValue permission to the secret in this property.",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
					// MasterSecretArn is a write-only property.
				}, /*END ATTRIBUTE*/
				// Property: MasterSecretKmsKeyArn
				"master_secret_kms_key_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "The ARN of the KMS key that Secrets Manager used to encrypt the superuser secret, if you use the alternating users strategy and the superuser secret is encrypted with a customer managed key. You don't need to specify this property if the superuser secret is encrypted using the key aws/secretsmanager. CloudFormation grants the execution role for the Lambda rotation function Decrypt, DescribeKey, and GenerateDataKey permission to the key in this property.",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
					// MasterSecretKmsKeyArn is a write-only property.
				}, /*END ATTRIBUTE*/
				// Property: RotationLambdaName
				"rotation_lambda_name": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "The name of the Lambda rotation function.",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
					// RotationLambdaName is a write-only property.
				}, /*END ATTRIBUTE*/
				// Property: RotationType
				"rotation_type": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "The type of rotation template to use",
					Optional:    true,
					Computed:    true,
					Validators: []validator.String{ /*START VALIDATORS*/
						fwvalidators.NotNullString(),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
					// RotationType is a write-only property.
				}, /*END ATTRIBUTE*/
				// Property: Runtime
				"runtime": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "The python runtime associated with the Lambda function",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
					// Runtime is a write-only property.
				}, /*END ATTRIBUTE*/
				// Property: SuperuserSecretArn
				"superuser_secret_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "The ARN of the secret that contains superuser credentials, if you use the alternating users rotation strategy. CloudFormation grants the execution role for the Lambda rotation function GetSecretValue permission to the secret in this property.",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
					// SuperuserSecretArn is a write-only property.
				}, /*END ATTRIBUTE*/
				// Property: SuperuserSecretKmsKeyArn
				"superuser_secret_kms_key_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "The ARN of the KMS key that Secrets Manager used to encrypt the superuser secret, if you use the alternating users strategy and the superuser secret is encrypted with a customer managed key. You don't need to specify this property if the superuser secret is encrypted using the key aws/secretsmanager. CloudFormation grants the execution role for the Lambda rotation function Decrypt, DescribeKey, and GenerateDataKey permission to the key in this property.",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
					// SuperuserSecretKmsKeyArn is a write-only property.
				}, /*END ATTRIBUTE*/
				// Property: VpcSecurityGroupIds
				"vpc_security_group_ids": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "A comma-separated list of security group IDs applied to the target database.",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
					// VpcSecurityGroupIds is a write-only property.
				}, /*END ATTRIBUTE*/
				// Property: VpcSubnetIds
				"vpc_subnet_ids": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "A comma separated list of VPC subnet IDs of the target database network. The Lambda rotation function is in the same subnet group.",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
					// VpcSubnetIds is a write-only property.
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "Creates a new Lambda rotation function based on one of the Secrets Manager rotation function templates. To use a rotation function that already exists, specify RotationLambdaARN instead.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
			// HostedRotationLambda is a write-only property.
		}, /*END ATTRIBUTE*/
		// Property: Id
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The ARN of the secret.",
		//	  "type": "string"
		//	}
		"rotation_schedule_id": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The ARN of the secret.",
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: RotateImmediatelyOnUpdate
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "Specifies whether to rotate the secret immediately or wait until the next scheduled rotation window.",
		//	  "type": "boolean"
		//	}
		"rotate_immediately_on_update": schema.BoolAttribute{ /*START ATTRIBUTE*/
			Description: "Specifies whether to rotate the secret immediately or wait until the next scheduled rotation window.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Bool{ /*START PLAN MODIFIERS*/
				boolplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
			// RotateImmediatelyOnUpdate is a write-only property.
		}, /*END ATTRIBUTE*/
		// Property: RotationLambdaARN
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The ARN of an existing Lambda rotation function. To specify a rotation function that is also defined in this template, use the Ref function.",
		//	  "type": "string"
		//	}
		"rotation_lambda_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The ARN of an existing Lambda rotation function. To specify a rotation function that is also defined in this template, use the Ref function.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: RotationRules
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "A structure that defines the rotation configuration for this secret.",
		//	  "properties": {
		//	    "AutomaticallyAfterDays": {
		//	      "description": "The number of days between automatic scheduled rotations of the secret. You can use this value to check that your secret meets your compliance guidelines for how often secrets must be rotated.",
		//	      "type": "integer"
		//	    },
		//	    "Duration": {
		//	      "description": "The length of the rotation window in hours, for example 3h for a three hour window. Secrets Manager rotates your secret at any time during this window. The window must not extend into the next rotation window or the next UTC day. The window starts according to the ScheduleExpression. If you don't specify a Duration, for a ScheduleExpression in hours, the window automatically closes after one hour. For a ScheduleExpression in days, the window automatically closes at the end of the UTC day.",
		//	      "type": "string"
		//	    },
		//	    "ScheduleExpression": {
		//	      "description": "A cron() or rate() expression that defines the schedule for rotating your secret. Secrets Manager rotation schedules use UTC time zone.",
		//	      "type": "string"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"rotation_rules": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: AutomaticallyAfterDays
				"automatically_after_days": schema.Int64Attribute{ /*START ATTRIBUTE*/
					Description: "The number of days between automatic scheduled rotations of the secret. You can use this value to check that your secret meets your compliance guidelines for how often secrets must be rotated.",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
						int64planmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: Duration
				"duration": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "The length of the rotation window in hours, for example 3h for a three hour window. Secrets Manager rotates your secret at any time during this window. The window must not extend into the next rotation window or the next UTC day. The window starts according to the ScheduleExpression. If you don't specify a Duration, for a ScheduleExpression in hours, the window automatically closes after one hour. For a ScheduleExpression in days, the window automatically closes at the end of the UTC day.",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: ScheduleExpression
				"schedule_expression": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "A cron() or rate() expression that defines the schedule for rotating your secret. Secrets Manager rotation schedules use UTC time zone.",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "A structure that defines the rotation configuration for this secret.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: SecretId
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The ARN or name of the secret to rotate.",
		//	  "type": "string"
		//	}
		"secret_id": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The ARN or name of the secret to rotate.",
			Required:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.RequiresReplace(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
	} /*END SCHEMA*/

	// Corresponds to CloudFormation primaryIdentifier.
	attributes["id"] = schema.StringAttribute{
		Description: "Uniquely identifies the resource.",
		Computed:    true,
		PlanModifiers: []planmodifier.String{
			stringplanmodifier.UseStateForUnknown(),
		},
	}

	schema := schema.Schema{
		Description: "Resource Type definition for AWS::SecretsManager::RotationSchedule",
		Version:     1,
		Attributes:  attributes,
	}

	var opts generic.ResourceOptions

	opts = opts.WithCloudFormationTypeName("AWS::SecretsManager::RotationSchedule").WithTerraformTypeName("awscc_secretsmanager_rotation_schedule")
	opts = opts.WithTerraformSchema(schema)
	opts = opts.WithPrimaryIdentifier(
		identity.Identifier{
			Name:              "id",
			Description:       "The ARN of the secret",
			RequiredForImport: true,
		})

	opts = opts.WithAttributeNameMap(map[string]string{
		"automatically_after_days":     "AutomaticallyAfterDays",
		"duration":                     "Duration",
		"exclude_characters":           "ExcludeCharacters",
		"hosted_rotation_lambda":       "HostedRotationLambda",
		"kms_key_arn":                  "KmsKeyArn",
		"master_secret_arn":            "MasterSecretArn",
		"master_secret_kms_key_arn":    "MasterSecretKmsKeyArn",
		"rotate_immediately_on_update": "RotateImmediatelyOnUpdate",
		"rotation_lambda_arn":          "RotationLambdaARN",
		"rotation_lambda_name":         "RotationLambdaName",
		"rotation_rules":               "RotationRules",
		"rotation_schedule_id":         "Id",
		"rotation_type":                "RotationType",
		"runtime":                      "Runtime",
		"schedule_expression":          "ScheduleExpression",
		"secret_id":                    "SecretId",
		"superuser_secret_arn":         "SuperuserSecretArn",
		"superuser_secret_kms_key_arn": "SuperuserSecretKmsKeyArn",
		"vpc_security_group_ids":       "VpcSecurityGroupIds",
		"vpc_subnet_ids":               "VpcSubnetIds",
	})

	opts = opts.WithWriteOnlyPropertyPaths([]string{
		"/properties/RotateImmediatelyOnUpdate",
		"/properties/HostedRotationLambda",
		"/properties/HostedRotationLambda/ExcludeCharacters",
		"/properties/HostedRotationLambda/KmsKeyArn",
		"/properties/HostedRotationLambda/MasterSecretArn",
		"/properties/HostedRotationLambda/MasterSecretKmsKeyArn",
		"/properties/HostedRotationLambda/RotationLambdaName",
		"/properties/HostedRotationLambda/RotationType",
		"/properties/HostedRotationLambda/Runtime",
		"/properties/HostedRotationLambda/SuperuserSecretArn",
		"/properties/HostedRotationLambda/SuperuserSecretKmsKeyArn",
		"/properties/HostedRotationLambda/VpcSecurityGroupIds",
		"/properties/HostedRotationLambda/VpcSubnetIds",
	})
	opts = opts.WithCreateTimeoutInMinutes(0).WithDeleteTimeoutInMinutes(0)

	opts = opts.WithUpdateTimeoutInMinutes(0)

	v, err := generic.NewResource(ctx, opts...)

	if err != nil {
		return nil, err
	}

	return v, nil
}
