// Copyright IBM Corp. 2021, 2026
// SPDX-License-Identifier: MPL-2.0

// Code generated by generators/resource/main.go; DO NOT EDIT.

package observabilityadmin

import (
	"context"
	"regexp"

	"github.com/hashicorp/terraform-plugin-framework-validators/setvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/setplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-provider-awscc/internal/generic"
	"github.com/hashicorp/terraform-provider-awscc/internal/identity"
	"github.com/hashicorp/terraform-provider-awscc/internal/registry"
	fwvalidators "github.com/hashicorp/terraform-provider-awscc/internal/validators"
)

func init() {
	registry.AddResourceFactory("awscc_observabilityadmin_telemetry_rule", telemetryRuleResource)
	registry.AddListResourceFactory("awscc_observabilityadmin_telemetry_rule", generic.NewListResource(telemetryRuleResource))
}

// telemetryRuleResource returns the Terraform awscc_observabilityadmin_telemetry_rule resource.
// This Terraform resource corresponds to the CloudFormation AWS::ObservabilityAdmin::TelemetryRule resource.
func telemetryRuleResource(ctx context.Context) (resource.Resource, error) {
	attributes := map[string]schema.Attribute{ /*START SCHEMA*/
		// Property: Rule
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "The telemetry rule",
		//	  "properties": {
		//	    "DestinationConfiguration": {
		//	      "additionalProperties": false,
		//	      "description": "The destination configuration for telemetry data",
		//	      "properties": {
		//	        "CloudtrailParameters": {
		//	          "additionalProperties": false,
		//	          "description": "Telemetry parameters for Cloudtrail",
		//	          "properties": {
		//	            "AdvancedEventSelectors": {
		//	              "description": "Create fine-grained selectors for AWS CloudTrail management and data.",
		//	              "insertionOrder": false,
		//	              "items": {
		//	                "additionalProperties": false,
		//	                "description": "An advanced event selector that includes optional name and field selectors",
		//	                "properties": {
		//	                  "FieldSelectors": {
		//	                    "description": "Contains all selector statements in an advanced event selector.",
		//	                    "insertionOrder": false,
		//	                    "items": {
		//	                      "description": "A single selector statement in an advanced event selector.",
		//	                      "properties": {
		//	                        "EndsWith": {
		//	                          "description": "An operator that includes events that match the last few characters of the event record field specified as the value of Field.",
		//	                          "insertionOrder": false,
		//	                          "items": {
		//	                            "type": "string"
		//	                          },
		//	                          "type": "array",
		//	                          "uniqueItems": true
		//	                        },
		//	                        "Equals": {
		//	                          "description": "An operator that includes events that match the exact value of the event record field specified as the value of Field.",
		//	                          "insertionOrder": false,
		//	                          "items": {
		//	                            "type": "string"
		//	                          },
		//	                          "type": "array",
		//	                          "uniqueItems": true
		//	                        },
		//	                        "Field": {
		//	                          "description": "A field in a CloudTrail event record on which to filter events to be logged",
		//	                          "maxLength": 1000,
		//	                          "minLength": 1,
		//	                          "type": "string"
		//	                        },
		//	                        "NotEndsWith": {
		//	                          "description": "An operator that excludes events that match the last few characters of the event record field specified as the value of Field.",
		//	                          "insertionOrder": false,
		//	                          "items": {
		//	                            "type": "string"
		//	                          },
		//	                          "type": "array",
		//	                          "uniqueItems": true
		//	                        },
		//	                        "NotEquals": {
		//	                          "description": "An operator that excludes events that match the exact value of the event record field specified as the value of Field.",
		//	                          "insertionOrder": false,
		//	                          "items": {
		//	                            "type": "string"
		//	                          },
		//	                          "type": "array",
		//	                          "uniqueItems": true
		//	                        },
		//	                        "NotStartsWith": {
		//	                          "description": "An operator that excludes events that match the first few characters of the event record field specified as the value of Field.",
		//	                          "insertionOrder": false,
		//	                          "items": {
		//	                            "type": "string"
		//	                          },
		//	                          "type": "array",
		//	                          "uniqueItems": true
		//	                        },
		//	                        "StartsWith": {
		//	                          "description": "An operator that includes events that match the first few characters of the event record field specified as the value of Field.",
		//	                          "insertionOrder": false,
		//	                          "items": {
		//	                            "type": "string"
		//	                          },
		//	                          "type": "array",
		//	                          "uniqueItems": true
		//	                        }
		//	                      },
		//	                      "type": "object"
		//	                    },
		//	                    "type": "array",
		//	                    "uniqueItems": true
		//	                  },
		//	                  "Name": {
		//	                    "description": "An optional descriptive name for the advanced event selector",
		//	                    "type": "string"
		//	                  }
		//	                },
		//	                "required": [
		//	                  "FieldSelectors"
		//	                ],
		//	                "type": "object"
		//	              },
		//	              "type": "array",
		//	              "uniqueItems": true
		//	            }
		//	          },
		//	          "required": [
		//	            "AdvancedEventSelectors"
		//	          ],
		//	          "type": "object"
		//	        },
		//	        "DestinationPattern": {
		//	          "description": "Pattern for telemetry data destination",
		//	          "type": "string"
		//	        },
		//	        "DestinationType": {
		//	          "description": "Type of telemetry destination",
		//	          "enum": [
		//	            "cloud-watch-logs"
		//	          ],
		//	          "type": "string"
		//	        },
		//	        "ELBLoadBalancerLoggingParameters": {
		//	          "description": "Telemetry parameters for ELB/NLB Load Balancer Logs",
		//	          "properties": {
		//	            "FieldDelimiter": {
		//	              "description": "A delimiter to delineate log fields",
		//	              "type": "string"
		//	            },
		//	            "OutputFormat": {
		//	              "enum": [
		//	                "plain",
		//	                "json"
		//	              ],
		//	              "type": "string"
		//	            }
		//	          },
		//	          "type": "object"
		//	        },
		//	        "LogDeliveryParameters": {
		//	          "description": "Parameters for BedrockAgentCore log delivery",
		//	          "properties": {
		//	            "LogTypes": {
		//	              "description": "Types of logs to deliver for BedrockAgentCore resources",
		//	              "insertionOrder": false,
		//	              "items": {
		//	                "enum": [
		//	                  "APPLICATION_LOGS",
		//	                  "USAGE_LOGS"
		//	                ],
		//	                "type": "string"
		//	              },
		//	              "minItems": 1,
		//	              "type": "array",
		//	              "uniqueItems": true
		//	            }
		//	          },
		//	          "type": "object"
		//	        },
		//	        "RetentionInDays": {
		//	          "description": "Number of days to retain the telemetry data in the specified destination",
		//	          "type": "integer"
		//	        },
		//	        "VPCFlowLogParameters": {
		//	          "additionalProperties": false,
		//	          "description": "Telemetry parameters for VPC Flow logs",
		//	          "properties": {
		//	            "LogFormat": {
		//	              "description": "The fields to include in the flow log record. If you omit this parameter, the flow log is created using the default format.",
		//	              "type": "string"
		//	            },
		//	            "MaxAggregationInterval": {
		//	              "description": "The maximum interval of time, in seconds, during which a flow of packets is captured and aggregated into a flow log record. Default is 600s.",
		//	              "type": "integer"
		//	            },
		//	            "TrafficType": {
		//	              "description": "The type of traffic captured for the flow log. Default is ALL",
		//	              "type": "string"
		//	            }
		//	          },
		//	          "type": "object"
		//	        },
		//	        "WAFLoggingParameters": {
		//	          "description": "Telemetry parameters for WAF v2 Web ACL",
		//	          "properties": {
		//	            "LogType": {
		//	              "description": "The type of logs to generate for WAF.",
		//	              "enum": [
		//	                "WAF_LOGS"
		//	              ],
		//	              "type": "string"
		//	            },
		//	            "LoggingFilter": {
		//	              "description": "Default handling for logs that don't match any of the specified filtering conditions.",
		//	              "properties": {
		//	                "DefaultBehavior": {
		//	                  "description": "The behavior required of the filter.",
		//	                  "enum": [
		//	                    "KEEP",
		//	                    "DROP"
		//	                  ],
		//	                  "type": "string"
		//	                },
		//	                "Filters": {
		//	                  "description": "A list of filters to be applied.",
		//	                  "insertionOrder": false,
		//	                  "items": {
		//	                    "description": "A filter to be applied",
		//	                    "properties": {
		//	                      "Behavior": {
		//	                        "description": "The behavior required of the filter.",
		//	                        "enum": [
		//	                          "KEEP",
		//	                          "DROP"
		//	                        ],
		//	                        "type": "string"
		//	                      },
		//	                      "Conditions": {
		//	                        "description": "A list of conditions for a filter.",
		//	                        "insertionOrder": false,
		//	                        "items": {
		//	                          "description": "A condition for a filter.",
		//	                          "properties": {
		//	                            "ActionCondition": {
		//	                              "description": "The condition of the action desired in the filter.",
		//	                              "properties": {
		//	                                "Action": {
		//	                                  "description": "The enumerated action to take.",
		//	                                  "enum": [
		//	                                    "ALLOW",
		//	                                    "BLOCK",
		//	                                    "COUNT",
		//	                                    "CAPTCHA",
		//	                                    "CHALLENGE",
		//	                                    "EXCLUDED_AS_COUNT"
		//	                                  ],
		//	                                  "type": "string"
		//	                                }
		//	                              },
		//	                              "type": "object"
		//	                            },
		//	                            "LabelNameCondition": {
		//	                              "description": "The label name of the condition.",
		//	                              "properties": {
		//	                                "LabelName": {
		//	                                  "description": "The label name of the condition.",
		//	                                  "maxLength": 1024,
		//	                                  "minLength": 1,
		//	                                  "pattern": "^[0-9A-Za-z_\\-:]+$",
		//	                                  "type": "string"
		//	                                }
		//	                              },
		//	                              "type": "object"
		//	                            }
		//	                          },
		//	                          "type": "object"
		//	                        },
		//	                        "minLength": 1,
		//	                        "type": "array",
		//	                        "uniqueItems": true
		//	                      },
		//	                      "Requirement": {
		//	                        "description": "The requirement portion of the filter.",
		//	                        "enum": [
		//	                          "MEETS_ALL",
		//	                          "MEETS_ANY"
		//	                        ],
		//	                        "type": "string"
		//	                      }
		//	                    },
		//	                    "type": "object"
		//	                  },
		//	                  "minLength": 1,
		//	                  "type": "array",
		//	                  "uniqueItems": true
		//	                }
		//	              },
		//	              "type": "object"
		//	            },
		//	            "RedactedFields": {
		//	              "description": "Fields not to be included in the logs.",
		//	              "insertionOrder": false,
		//	              "items": {
		//	                "description": "The field that we want to match this rule to.",
		//	                "properties": {
		//	                  "Method": {
		//	                    "description": "The method with which to match this rule.",
		//	                    "type": "string"
		//	                  },
		//	                  "QueryString": {
		//	                    "description": "The query string to find the resource to match this field to.",
		//	                    "type": "string"
		//	                  },
		//	                  "SingleHeader": {
		//	                    "additionalProperties": false,
		//	                    "description": "Header for the field to match.",
		//	                    "properties": {
		//	                      "Name": {
		//	                        "description": "The name of the header",
		//	                        "maxLength": 64,
		//	                        "minLength": 1,
		//	                        "type": "string"
		//	                      }
		//	                    },
		//	                    "required": [
		//	                      "Name"
		//	                    ],
		//	                    "type": "object"
		//	                  },
		//	                  "UriPath": {
		//	                    "description": "This is the URI path to match this rule to.",
		//	                    "type": "string"
		//	                  }
		//	                },
		//	                "type": "object"
		//	              },
		//	              "maxItems": 100,
		//	              "type": "array",
		//	              "uniqueItems": true
		//	            }
		//	          },
		//	          "type": "object"
		//	        }
		//	      },
		//	      "type": "object"
		//	    },
		//	    "ResourceType": {
		//	      "description": "Resource Type associated with the Telemetry Rule",
		//	      "enum": [
		//	        "AWS::EC2::VPC",
		//	        "AWS::WAFv2::WebACL",
		//	        "AWS::CloudTrail",
		//	        "AWS::EKS::Cluster",
		//	        "AWS::ElasticLoadBalancingV2::LoadBalancer",
		//	        "AWS::BedrockAgentCore::Runtime",
		//	        "AWS::BedrockAgentCore::Browser",
		//	        "AWS::BedrockAgentCore::CodeInterpreter"
		//	      ],
		//	      "type": "string"
		//	    },
		//	    "SelectionCriteria": {
		//	      "description": "Selection Criteria on resource level for rule application",
		//	      "type": "string"
		//	    },
		//	    "TelemetrySourceTypes": {
		//	      "description": "The telemetry source types for a telemetry rule.",
		//	      "insertionOrder": false,
		//	      "items": {
		//	        "description": "The telemetry source type that goes into the array.",
		//	        "enum": [
		//	          "VPC_FLOW_LOGS",
		//	          "ROUTE53_RESOLVER_QUERY_LOGS",
		//	          "EKS_AUDIT_LOGS",
		//	          "EKS_AUTHENTICATOR_LOGS",
		//	          "EKS_CONTROLLER_MANAGER_LOGS",
		//	          "EKS_SCHEDULER_LOGS",
		//	          "EKS_API_LOGS"
		//	        ],
		//	        "type": "string"
		//	      },
		//	      "type": "array",
		//	      "uniqueItems": true
		//	    },
		//	    "TelemetryType": {
		//	      "description": "Telemetry Type associated with the Telemetry Rule",
		//	      "enum": [
		//	        "Logs",
		//	        "Traces"
		//	      ],
		//	      "type": "string"
		//	    }
		//	  },
		//	  "required": [
		//	    "ResourceType",
		//	    "TelemetryType"
		//	  ],
		//	  "type": "object"
		//	}
		"rule": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: DestinationConfiguration
				"destination_configuration": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
					Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
						// Property: CloudtrailParameters
						"cloudtrail_parameters": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: AdvancedEventSelectors
								"advanced_event_selectors": schema.SetNestedAttribute{ /*START ATTRIBUTE*/
									NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
										Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
											// Property: FieldSelectors
											"field_selectors": schema.SetNestedAttribute{ /*START ATTRIBUTE*/
												NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
													Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
														// Property: EndsWith
														"ends_with": schema.SetAttribute{ /*START ATTRIBUTE*/
															ElementType: types.StringType,
															Description: "An operator that includes events that match the last few characters of the event record field specified as the value of Field.",
															Optional:    true,
															Computed:    true,
															PlanModifiers: []planmodifier.Set{ /*START PLAN MODIFIERS*/
																setplanmodifier.UseStateForUnknown(),
															}, /*END PLAN MODIFIERS*/
														}, /*END ATTRIBUTE*/
														// Property: Equals
														"equals": schema.SetAttribute{ /*START ATTRIBUTE*/
															ElementType: types.StringType,
															Description: "An operator that includes events that match the exact value of the event record field specified as the value of Field.",
															Optional:    true,
															Computed:    true,
															PlanModifiers: []planmodifier.Set{ /*START PLAN MODIFIERS*/
																setplanmodifier.UseStateForUnknown(),
															}, /*END PLAN MODIFIERS*/
														}, /*END ATTRIBUTE*/
														// Property: Field
														"field": schema.StringAttribute{ /*START ATTRIBUTE*/
															Description: "A field in a CloudTrail event record on which to filter events to be logged",
															Optional:    true,
															Computed:    true,
															Validators: []validator.String{ /*START VALIDATORS*/
																stringvalidator.LengthBetween(1, 1000),
															}, /*END VALIDATORS*/
															PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
																stringplanmodifier.UseStateForUnknown(),
															}, /*END PLAN MODIFIERS*/
														}, /*END ATTRIBUTE*/
														// Property: NotEndsWith
														"not_ends_with": schema.SetAttribute{ /*START ATTRIBUTE*/
															ElementType: types.StringType,
															Description: "An operator that excludes events that match the last few characters of the event record field specified as the value of Field.",
															Optional:    true,
															Computed:    true,
															PlanModifiers: []planmodifier.Set{ /*START PLAN MODIFIERS*/
																setplanmodifier.UseStateForUnknown(),
															}, /*END PLAN MODIFIERS*/
														}, /*END ATTRIBUTE*/
														// Property: NotEquals
														"not_equals": schema.SetAttribute{ /*START ATTRIBUTE*/
															ElementType: types.StringType,
															Description: "An operator that excludes events that match the exact value of the event record field specified as the value of Field.",
															Optional:    true,
															Computed:    true,
															PlanModifiers: []planmodifier.Set{ /*START PLAN MODIFIERS*/
																setplanmodifier.UseStateForUnknown(),
															}, /*END PLAN MODIFIERS*/
														}, /*END ATTRIBUTE*/
														// Property: NotStartsWith
														"not_starts_with": schema.SetAttribute{ /*START ATTRIBUTE*/
															ElementType: types.StringType,
															Description: "An operator that excludes events that match the first few characters of the event record field specified as the value of Field.",
															Optional:    true,
															Computed:    true,
															PlanModifiers: []planmodifier.Set{ /*START PLAN MODIFIERS*/
																setplanmodifier.UseStateForUnknown(),
															}, /*END PLAN MODIFIERS*/
														}, /*END ATTRIBUTE*/
														// Property: StartsWith
														"starts_with": schema.SetAttribute{ /*START ATTRIBUTE*/
															ElementType: types.StringType,
															Description: "An operator that includes events that match the first few characters of the event record field specified as the value of Field.",
															Optional:    true,
															Computed:    true,
															PlanModifiers: []planmodifier.Set{ /*START PLAN MODIFIERS*/
																setplanmodifier.UseStateForUnknown(),
															}, /*END PLAN MODIFIERS*/
														}, /*END ATTRIBUTE*/
													}, /*END SCHEMA*/
												}, /*END NESTED OBJECT*/
												Description: "Contains all selector statements in an advanced event selector.",
												Optional:    true,
												Computed:    true,
												Validators: []validator.Set{ /*START VALIDATORS*/
													fwvalidators.NotNullSet(),
												}, /*END VALIDATORS*/
												PlanModifiers: []planmodifier.Set{ /*START PLAN MODIFIERS*/
													setplanmodifier.UseStateForUnknown(),
												}, /*END PLAN MODIFIERS*/
											}, /*END ATTRIBUTE*/
											// Property: Name
											"name": schema.StringAttribute{ /*START ATTRIBUTE*/
												Description: "An optional descriptive name for the advanced event selector",
												Optional:    true,
												Computed:    true,
												PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
													stringplanmodifier.UseStateForUnknown(),
												}, /*END PLAN MODIFIERS*/
											}, /*END ATTRIBUTE*/
										}, /*END SCHEMA*/
									}, /*END NESTED OBJECT*/
									Description: "Create fine-grained selectors for AWS CloudTrail management and data.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.Set{ /*START VALIDATORS*/
										fwvalidators.NotNullSet(),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.Set{ /*START PLAN MODIFIERS*/
										setplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
							Description: "Telemetry parameters for Cloudtrail",
							Optional:    true,
							Computed:    true,
							PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
								objectplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
						// Property: DestinationPattern
						"destination_pattern": schema.StringAttribute{ /*START ATTRIBUTE*/
							Description: "Pattern for telemetry data destination",
							Optional:    true,
							Computed:    true,
							PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
								stringplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
						// Property: DestinationType
						"destination_type": schema.StringAttribute{ /*START ATTRIBUTE*/
							Description: "Type of telemetry destination",
							Optional:    true,
							Computed:    true,
							Validators: []validator.String{ /*START VALIDATORS*/
								stringvalidator.OneOf(
									"cloud-watch-logs",
								),
							}, /*END VALIDATORS*/
							PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
								stringplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
						// Property: ELBLoadBalancerLoggingParameters
						"elb_load_balancer_logging_parameters": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: FieldDelimiter
								"field_delimiter": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "A delimiter to delineate log fields",
									Optional:    true,
									Computed:    true,
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: OutputFormat
								"output_format": schema.StringAttribute{ /*START ATTRIBUTE*/
									Optional: true,
									Computed: true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.OneOf(
											"plain",
											"json",
										),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
							Description: "Telemetry parameters for ELB/NLB Load Balancer Logs",
							Optional:    true,
							Computed:    true,
							PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
								objectplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
						// Property: LogDeliveryParameters
						"log_delivery_parameters": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: LogTypes
								"log_types": schema.SetAttribute{ /*START ATTRIBUTE*/
									ElementType: types.StringType,
									Description: "Types of logs to deliver for BedrockAgentCore resources",
									Optional:    true,
									Computed:    true,
									Validators: []validator.Set{ /*START VALIDATORS*/
										setvalidator.SizeAtLeast(1),
										setvalidator.ValueStringsAre(
											stringvalidator.OneOf(
												"APPLICATION_LOGS",
												"USAGE_LOGS",
											),
										),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.Set{ /*START PLAN MODIFIERS*/
										setplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
							Description: "Parameters for BedrockAgentCore log delivery",
							Optional:    true,
							Computed:    true,
							PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
								objectplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
						// Property: RetentionInDays
						"retention_in_days": schema.Int64Attribute{ /*START ATTRIBUTE*/
							Description: "Number of days to retain the telemetry data in the specified destination",
							Optional:    true,
							Computed:    true,
							PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
								int64planmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
						// Property: VPCFlowLogParameters
						"vpc_flow_log_parameters": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: LogFormat
								"log_format": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The fields to include in the flow log record. If you omit this parameter, the flow log is created using the default format.",
									Optional:    true,
									Computed:    true,
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: MaxAggregationInterval
								"max_aggregation_interval": schema.Int64Attribute{ /*START ATTRIBUTE*/
									Description: "The maximum interval of time, in seconds, during which a flow of packets is captured and aggregated into a flow log record. Default is 600s.",
									Optional:    true,
									Computed:    true,
									PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
										int64planmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: TrafficType
								"traffic_type": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The type of traffic captured for the flow log. Default is ALL",
									Optional:    true,
									Computed:    true,
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
							Description: "Telemetry parameters for VPC Flow logs",
							Optional:    true,
							Computed:    true,
							PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
								objectplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
						// Property: WAFLoggingParameters
						"waf_logging_parameters": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: LogType
								"log_type": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The type of logs to generate for WAF.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.OneOf(
											"WAF_LOGS",
										),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: LoggingFilter
								"logging_filter": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
									Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
										// Property: DefaultBehavior
										"default_behavior": schema.StringAttribute{ /*START ATTRIBUTE*/
											Description: "The behavior required of the filter.",
											Optional:    true,
											Computed:    true,
											Validators: []validator.String{ /*START VALIDATORS*/
												stringvalidator.OneOf(
													"KEEP",
													"DROP",
												),
											}, /*END VALIDATORS*/
											PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
												stringplanmodifier.UseStateForUnknown(),
											}, /*END PLAN MODIFIERS*/
										}, /*END ATTRIBUTE*/
										// Property: Filters
										"filters": schema.SetNestedAttribute{ /*START ATTRIBUTE*/
											NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
												Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
													// Property: Behavior
													"behavior": schema.StringAttribute{ /*START ATTRIBUTE*/
														Description: "The behavior required of the filter.",
														Optional:    true,
														Computed:    true,
														Validators: []validator.String{ /*START VALIDATORS*/
															stringvalidator.OneOf(
																"KEEP",
																"DROP",
															),
														}, /*END VALIDATORS*/
														PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
															stringplanmodifier.UseStateForUnknown(),
														}, /*END PLAN MODIFIERS*/
													}, /*END ATTRIBUTE*/
													// Property: Conditions
													"conditions": schema.SetNestedAttribute{ /*START ATTRIBUTE*/
														NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
															Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
																// Property: ActionCondition
																"action_condition": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
																	Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
																		// Property: Action
																		"action": schema.StringAttribute{ /*START ATTRIBUTE*/
																			Description: "The enumerated action to take.",
																			Optional:    true,
																			Computed:    true,
																			Validators: []validator.String{ /*START VALIDATORS*/
																				stringvalidator.OneOf(
																					"ALLOW",
																					"BLOCK",
																					"COUNT",
																					"CAPTCHA",
																					"CHALLENGE",
																					"EXCLUDED_AS_COUNT",
																				),
																			}, /*END VALIDATORS*/
																			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
																				stringplanmodifier.UseStateForUnknown(),
																			}, /*END PLAN MODIFIERS*/
																		}, /*END ATTRIBUTE*/
																	}, /*END SCHEMA*/
																	Description: "The condition of the action desired in the filter.",
																	Optional:    true,
																	Computed:    true,
																	PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
																		objectplanmodifier.UseStateForUnknown(),
																	}, /*END PLAN MODIFIERS*/
																}, /*END ATTRIBUTE*/
																// Property: LabelNameCondition
																"label_name_condition": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
																	Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
																		// Property: LabelName
																		"label_name": schema.StringAttribute{ /*START ATTRIBUTE*/
																			Description: "The label name of the condition.",
																			Optional:    true,
																			Computed:    true,
																			Validators: []validator.String{ /*START VALIDATORS*/
																				stringvalidator.LengthBetween(1, 1024),
																				stringvalidator.RegexMatches(regexp.MustCompile("^[0-9A-Za-z_\\-:]+$"), ""),
																			}, /*END VALIDATORS*/
																			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
																				stringplanmodifier.UseStateForUnknown(),
																			}, /*END PLAN MODIFIERS*/
																		}, /*END ATTRIBUTE*/
																	}, /*END SCHEMA*/
																	Description: "The label name of the condition.",
																	Optional:    true,
																	Computed:    true,
																	PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
																		objectplanmodifier.UseStateForUnknown(),
																	}, /*END PLAN MODIFIERS*/
																}, /*END ATTRIBUTE*/
															}, /*END SCHEMA*/
														}, /*END NESTED OBJECT*/
														Description: "A list of conditions for a filter.",
														Optional:    true,
														Computed:    true,
														PlanModifiers: []planmodifier.Set{ /*START PLAN MODIFIERS*/
															setplanmodifier.UseStateForUnknown(),
														}, /*END PLAN MODIFIERS*/
													}, /*END ATTRIBUTE*/
													// Property: Requirement
													"requirement": schema.StringAttribute{ /*START ATTRIBUTE*/
														Description: "The requirement portion of the filter.",
														Optional:    true,
														Computed:    true,
														Validators: []validator.String{ /*START VALIDATORS*/
															stringvalidator.OneOf(
																"MEETS_ALL",
																"MEETS_ANY",
															),
														}, /*END VALIDATORS*/
														PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
															stringplanmodifier.UseStateForUnknown(),
														}, /*END PLAN MODIFIERS*/
													}, /*END ATTRIBUTE*/
												}, /*END SCHEMA*/
											}, /*END NESTED OBJECT*/
											Description: "A list of filters to be applied.",
											Optional:    true,
											Computed:    true,
											PlanModifiers: []planmodifier.Set{ /*START PLAN MODIFIERS*/
												setplanmodifier.UseStateForUnknown(),
											}, /*END PLAN MODIFIERS*/
										}, /*END ATTRIBUTE*/
									}, /*END SCHEMA*/
									Description: "Default handling for logs that don't match any of the specified filtering conditions.",
									Optional:    true,
									Computed:    true,
									PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
										objectplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: RedactedFields
								"redacted_fields": schema.SetNestedAttribute{ /*START ATTRIBUTE*/
									NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
										Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
											// Property: Method
											"method": schema.StringAttribute{ /*START ATTRIBUTE*/
												Description: "The method with which to match this rule.",
												Optional:    true,
												Computed:    true,
												PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
													stringplanmodifier.UseStateForUnknown(),
												}, /*END PLAN MODIFIERS*/
											}, /*END ATTRIBUTE*/
											// Property: QueryString
											"query_string": schema.StringAttribute{ /*START ATTRIBUTE*/
												Description: "The query string to find the resource to match this field to.",
												Optional:    true,
												Computed:    true,
												PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
													stringplanmodifier.UseStateForUnknown(),
												}, /*END PLAN MODIFIERS*/
											}, /*END ATTRIBUTE*/
											// Property: SingleHeader
											"single_header": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
												Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
													// Property: Name
													"name": schema.StringAttribute{ /*START ATTRIBUTE*/
														Description: "The name of the header",
														Optional:    true,
														Computed:    true,
														Validators: []validator.String{ /*START VALIDATORS*/
															stringvalidator.LengthBetween(1, 64),
															fwvalidators.NotNullString(),
														}, /*END VALIDATORS*/
														PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
															stringplanmodifier.UseStateForUnknown(),
														}, /*END PLAN MODIFIERS*/
													}, /*END ATTRIBUTE*/
												}, /*END SCHEMA*/
												Description: "Header for the field to match.",
												Optional:    true,
												Computed:    true,
												PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
													objectplanmodifier.UseStateForUnknown(),
												}, /*END PLAN MODIFIERS*/
											}, /*END ATTRIBUTE*/
											// Property: UriPath
											"uri_path": schema.StringAttribute{ /*START ATTRIBUTE*/
												Description: "This is the URI path to match this rule to.",
												Optional:    true,
												Computed:    true,
												PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
													stringplanmodifier.UseStateForUnknown(),
												}, /*END PLAN MODIFIERS*/
											}, /*END ATTRIBUTE*/
										}, /*END SCHEMA*/
									}, /*END NESTED OBJECT*/
									Description: "Fields not to be included in the logs.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.Set{ /*START VALIDATORS*/
										setvalidator.SizeAtMost(100),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.Set{ /*START PLAN MODIFIERS*/
										setplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
							Description: "Telemetry parameters for WAF v2 Web ACL",
							Optional:    true,
							Computed:    true,
							PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
								objectplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
					}, /*END SCHEMA*/
					Description: "The destination configuration for telemetry data",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
						objectplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: ResourceType
				"resource_type": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "Resource Type associated with the Telemetry Rule",
					Required:    true,
					Validators: []validator.String{ /*START VALIDATORS*/
						stringvalidator.OneOf(
							"AWS::EC2::VPC",
							"AWS::WAFv2::WebACL",
							"AWS::CloudTrail",
							"AWS::EKS::Cluster",
							"AWS::ElasticLoadBalancingV2::LoadBalancer",
							"AWS::BedrockAgentCore::Runtime",
							"AWS::BedrockAgentCore::Browser",
							"AWS::BedrockAgentCore::CodeInterpreter",
						),
					}, /*END VALIDATORS*/
				}, /*END ATTRIBUTE*/
				// Property: SelectionCriteria
				"selection_criteria": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "Selection Criteria on resource level for rule application",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: TelemetrySourceTypes
				"telemetry_source_types": schema.SetAttribute{ /*START ATTRIBUTE*/
					ElementType: types.StringType,
					Description: "The telemetry source types for a telemetry rule.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.Set{ /*START VALIDATORS*/
						setvalidator.ValueStringsAre(
							stringvalidator.OneOf(
								"VPC_FLOW_LOGS",
								"ROUTE53_RESOLVER_QUERY_LOGS",
								"EKS_AUDIT_LOGS",
								"EKS_AUTHENTICATOR_LOGS",
								"EKS_CONTROLLER_MANAGER_LOGS",
								"EKS_SCHEDULER_LOGS",
								"EKS_API_LOGS",
							),
						),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.Set{ /*START PLAN MODIFIERS*/
						setplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: TelemetryType
				"telemetry_type": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "Telemetry Type associated with the Telemetry Rule",
					Required:    true,
					Validators: []validator.String{ /*START VALIDATORS*/
						stringvalidator.OneOf(
							"Logs",
							"Traces",
						),
					}, /*END VALIDATORS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "The telemetry rule",
			Required:    true,
		}, /*END ATTRIBUTE*/
		// Property: RuleArn
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The arn of the telemetry rule",
		//	  "maxLength": 1011,
		//	  "minLength": 1,
		//	  "pattern": "^arn:aws([a-z0-9\\-]+)?:([a-zA-Z0-9\\-]+):([a-z0-9\\-]+)?:([0-9]{12})?:(.+)$",
		//	  "type": "string"
		//	}
		"rule_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The arn of the telemetry rule",
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: RuleName
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The name of the telemetry rule",
		//	  "maxLength": 100,
		//	  "minLength": 1,
		//	  "pattern": "^[0-9A-Za-z-]+$",
		//	  "type": "string"
		//	}
		"rule_name": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The name of the telemetry rule",
			Required:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.LengthBetween(1, 100),
				stringvalidator.RegexMatches(regexp.MustCompile("^[0-9A-Za-z-]+$"), ""),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.RequiresReplace(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Tags
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "An array of key-value pairs to apply to this resource",
		//	  "insertionOrder": false,
		//	  "items": {
		//	    "additionalProperties": false,
		//	    "description": "A key-value pair to associate with a resource",
		//	    "properties": {
		//	      "Key": {
		//	        "description": "The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.",
		//	        "maxLength": 128,
		//	        "minLength": 1,
		//	        "type": "string"
		//	      },
		//	      "Value": {
		//	        "description": "The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.",
		//	        "maxLength": 256,
		//	        "minLength": 0,
		//	        "type": "string"
		//	      }
		//	    },
		//	    "required": [
		//	      "Key",
		//	      "Value"
		//	    ],
		//	    "type": "object"
		//	  },
		//	  "type": "array",
		//	  "uniqueItems": true
		//	}
		"tags": schema.SetNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: Key
					"key": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.LengthBetween(1, 128),
							fwvalidators.NotNullString(),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: Value
					"value": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.LengthBetween(0, 256),
							fwvalidators.NotNullString(),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Description: "An array of key-value pairs to apply to this resource",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Set{ /*START PLAN MODIFIERS*/
				setplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
	} /*END SCHEMA*/

	// Corresponds to CloudFormation primaryIdentifier.
	attributes["id"] = schema.StringAttribute{
		Description: "Uniquely identifies the resource.",
		Computed:    true,
		PlanModifiers: []planmodifier.String{
			stringplanmodifier.UseStateForUnknown(),
		},
	}

	schema := schema.Schema{
		Description: "The AWS::ObservabilityAdmin::TelemetryRule resource defines a CloudWatch Observability Admin Telemetry Rule.",
		Version:     1,
		Attributes:  attributes,
	}

	var opts generic.ResourceOptions

	opts = opts.WithCloudFormationTypeName("AWS::ObservabilityAdmin::TelemetryRule").WithTerraformTypeName("awscc_observabilityadmin_telemetry_rule")
	opts = opts.WithTerraformSchema(schema)
	opts = opts.WithPrimaryIdentifier(
		identity.Identifier{
			Name:              "rule_arn",
			Description:       "The arn of the telemetry rule",
			RequiredForImport: true,
		})

	opts = opts.WithAttributeNameMap(map[string]string{
		"action":                               "Action",
		"action_condition":                     "ActionCondition",
		"advanced_event_selectors":             "AdvancedEventSelectors",
		"behavior":                             "Behavior",
		"cloudtrail_parameters":                "CloudtrailParameters",
		"conditions":                           "Conditions",
		"default_behavior":                     "DefaultBehavior",
		"destination_configuration":            "DestinationConfiguration",
		"destination_pattern":                  "DestinationPattern",
		"destination_type":                     "DestinationType",
		"elb_load_balancer_logging_parameters": "ELBLoadBalancerLoggingParameters",
		"ends_with":                            "EndsWith",
		"equals":                               "Equals",
		"field":                                "Field",
		"field_delimiter":                      "FieldDelimiter",
		"field_selectors":                      "FieldSelectors",
		"filters":                              "Filters",
		"key":                                  "Key",
		"label_name":                           "LabelName",
		"label_name_condition":                 "LabelNameCondition",
		"log_delivery_parameters":              "LogDeliveryParameters",
		"log_format":                           "LogFormat",
		"log_type":                             "LogType",
		"log_types":                            "LogTypes",
		"logging_filter":                       "LoggingFilter",
		"max_aggregation_interval":             "MaxAggregationInterval",
		"method":                               "Method",
		"name":                                 "Name",
		"not_ends_with":                        "NotEndsWith",
		"not_equals":                           "NotEquals",
		"not_starts_with":                      "NotStartsWith",
		"output_format":                        "OutputFormat",
		"query_string":                         "QueryString",
		"redacted_fields":                      "RedactedFields",
		"requirement":                          "Requirement",
		"resource_type":                        "ResourceType",
		"retention_in_days":                    "RetentionInDays",
		"rule":                                 "Rule",
		"rule_arn":                             "RuleArn",
		"rule_name":                            "RuleName",
		"selection_criteria":                   "SelectionCriteria",
		"single_header":                        "SingleHeader",
		"starts_with":                          "StartsWith",
		"tags":                                 "Tags",
		"telemetry_source_types":               "TelemetrySourceTypes",
		"telemetry_type":                       "TelemetryType",
		"traffic_type":                         "TrafficType",
		"uri_path":                             "UriPath",
		"value":                                "Value",
		"vpc_flow_log_parameters":              "VPCFlowLogParameters",
		"waf_logging_parameters":               "WAFLoggingParameters",
	})

	opts = opts.WithCreateTimeoutInMinutes(0).WithDeleteTimeoutInMinutes(0)

	opts = opts.WithUpdateTimeoutInMinutes(0)

	v, err := generic.NewResource(ctx, opts...)

	if err != nil {
		return nil, err
	}

	return v, nil
}
