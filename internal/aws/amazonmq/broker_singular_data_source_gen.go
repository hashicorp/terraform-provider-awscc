// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// Code generated by generators/singular-data-source/main.go; DO NOT EDIT.

package amazonmq

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-provider-awscc/internal/generic"
	"github.com/hashicorp/terraform-provider-awscc/internal/registry"
)

func init() {
	registry.AddDataSourceFactory("awscc_amazonmq_broker", brokerDataSource)
}

// brokerDataSource returns the Terraform awscc_amazonmq_broker data source.
// This Terraform data source corresponds to the CloudFormation AWS::AmazonMQ::Broker resource.
func brokerDataSource(ctx context.Context) (datasource.DataSource, error) {
	attributes := map[string]schema.Attribute{ /*START SCHEMA*/
		// Property: AmqpEndpoints
		// CloudFormation resource type schema:
		//
		//	{
		//	  "insertionOrder": false,
		//	  "items": {
		//	    "type": "string"
		//	  },
		//	  "type": "array",
		//	  "uniqueItems": false
		//	}
		"amqp_endpoints": schema.ListAttribute{ /*START ATTRIBUTE*/
			ElementType: types.StringType,
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: Arn
		// CloudFormation resource type schema:
		//
		//	{
		//	  "pattern": "^arn:.*",
		//	  "type": "string"
		//	}
		"arn": schema.StringAttribute{ /*START ATTRIBUTE*/
			Computed: true,
		}, /*END ATTRIBUTE*/
		// Property: AuthenticationStrategy
		// CloudFormation resource type schema:
		//
		//	{
		//	  "type": "string"
		//	}
		"authentication_strategy": schema.StringAttribute{ /*START ATTRIBUTE*/
			Computed: true,
		}, /*END ATTRIBUTE*/
		// Property: AutoMinorVersionUpgrade
		// CloudFormation resource type schema:
		//
		//	{
		//	  "type": "boolean"
		//	}
		"auto_minor_version_upgrade": schema.BoolAttribute{ /*START ATTRIBUTE*/
			Computed: true,
		}, /*END ATTRIBUTE*/
		// Property: BrokerName
		// CloudFormation resource type schema:
		//
		//	{
		//	  "pattern": "^[0-9A-Za-z_-]{1,50}$",
		//	  "type": "string"
		//	}
		"broker_name": schema.StringAttribute{ /*START ATTRIBUTE*/
			Computed: true,
		}, /*END ATTRIBUTE*/
		// Property: Configuration
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "The intended configuration (ID and revision) to be set when creating or updating.\nThis property is write-only so that applications of a ConfigurationAssociation do not cause drift.\n",
		//	  "properties": {
		//	    "Id": {
		//	      "type": "string"
		//	    },
		//	    "Revision": {
		//	      "type": "integer"
		//	    }
		//	  },
		//	  "required": [
		//	    "Revision",
		//	    "Id"
		//	  ],
		//	  "type": "object"
		//	}
		"configuration": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: Id
				"id": schema.StringAttribute{ /*START ATTRIBUTE*/
					Computed: true,
				}, /*END ATTRIBUTE*/
				// Property: Revision
				"revision": schema.Int64Attribute{ /*START ATTRIBUTE*/
					Computed: true,
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "The intended configuration (ID and revision) to be set when creating or updating.\nThis property is write-only so that applications of a ConfigurationAssociation do not cause drift.\n",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: ConfigurationId
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The ID of the current actual configuration.",
		//	  "type": "string"
		//	}
		"configuration_id": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The ID of the current actual configuration.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: ConfigurationRevision
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The revision of the current actual configuration.",
		//	  "type": "string"
		//	}
		"configuration_revision": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The revision of the current actual configuration.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: ConsoleURLs
		// CloudFormation resource type schema:
		//
		//	{
		//	  "insertionOrder": false,
		//	  "items": {
		//	    "type": "string"
		//	  },
		//	  "type": "array",
		//	  "uniqueItems": false
		//	}
		"console_ur_ls": schema.ListAttribute{ /*START ATTRIBUTE*/
			ElementType: types.StringType,
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: DataReplicationMode
		// CloudFormation resource type schema:
		//
		//	{
		//	  "anyOf": [
		//	    {},
		//	    {},
		//	    {}
		//	  ],
		//	  "type": "string"
		//	}
		"data_replication_mode": schema.StringAttribute{ /*START ATTRIBUTE*/
			Computed: true,
		}, /*END ATTRIBUTE*/
		// Property: DataReplicationPrimaryBrokerArn
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The ARN of the primary broker that is used to replicate data from in a data replication pair when creating a replica.\nThis field is only used at creation-time. Changes to it subsequently are ignored by CloudFormation.\nInformation on the current primary is available on the DataReplicationMetadata object returned by the API.\n",
		//	  "pattern": "^arn:.*",
		//	  "type": "string"
		//	}
		"data_replication_primary_broker_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The ARN of the primary broker that is used to replicate data from in a data replication pair when creating a replica.\nThis field is only used at creation-time. Changes to it subsequently are ignored by CloudFormation.\nInformation on the current primary is available on the DataReplicationMetadata object returned by the API.\n",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: DeploymentMode
		// CloudFormation resource type schema:
		//
		//	{
		//	  "anyOf": [
		//	    {},
		//	    {},
		//	    {},
		//	    {}
		//	  ],
		//	  "type": "string"
		//	}
		"deployment_mode": schema.StringAttribute{ /*START ATTRIBUTE*/
			Computed: true,
		}, /*END ATTRIBUTE*/
		// Property: EncryptionOptions
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "properties": {
		//	    "KmsKeyId": {
		//	      "description": "The customer master key (CMK) to use for the A KMS (KMS). \nThis key is used to encrypt your data at rest. If not provided, Amazon MQ will use a default CMK to encrypt your data.\nThe Key ARN is recommended so that drift can be detected,\nbut a key ID or key alias will also be accepted for API compatibility reasons.\n",
		//	      "type": "string"
		//	    },
		//	    "UseAwsOwnedKey": {
		//	      "type": "boolean"
		//	    }
		//	  },
		//	  "required": [
		//	    "UseAwsOwnedKey"
		//	  ],
		//	  "type": "object"
		//	}
		"encryption_options": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: KmsKeyId
				"kms_key_id": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "The customer master key (CMK) to use for the A KMS (KMS). \nThis key is used to encrypt your data at rest. If not provided, Amazon MQ will use a default CMK to encrypt your data.\nThe Key ARN is recommended so that drift can be detected,\nbut a key ID or key alias will also be accepted for API compatibility reasons.\n",
					Computed:    true,
				}, /*END ATTRIBUTE*/
				// Property: UseAwsOwnedKey
				"use_aws_owned_key": schema.BoolAttribute{ /*START ATTRIBUTE*/
					Computed: true,
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Computed: true,
		}, /*END ATTRIBUTE*/
		// Property: EngineType
		// CloudFormation resource type schema:
		//
		//	{
		//	  "anyOf": [
		//	    {},
		//	    {},
		//	    {}
		//	  ],
		//	  "type": "string"
		//	}
		"engine_type": schema.StringAttribute{ /*START ATTRIBUTE*/
			Computed: true,
		}, /*END ATTRIBUTE*/
		// Property: EngineVersion
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The version specified to use. See also EngineVersionCurrent.",
		//	  "type": "string"
		//	}
		"engine_version": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The version specified to use. See also EngineVersionCurrent.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: EngineVersionCurrent
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The version in use. This may have more precision than the specified EngineVersion.",
		//	  "type": "string"
		//	}
		"engine_version_current": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The version in use. This may have more precision than the specified EngineVersion.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: HostInstanceType
		// CloudFormation resource type schema:
		//
		//	{
		//	  "type": "string"
		//	}
		"host_instance_type": schema.StringAttribute{ /*START ATTRIBUTE*/
			Computed: true,
		}, /*END ATTRIBUTE*/
		// Property: Id
		// CloudFormation resource type schema:
		//
		//	{
		//	  "type": "string"
		//	}
		"broker_id": schema.StringAttribute{ /*START ATTRIBUTE*/
			Computed: true,
		}, /*END ATTRIBUTE*/
		// Property: IpAddresses
		// CloudFormation resource type schema:
		//
		//	{
		//	  "insertionOrder": false,
		//	  "items": {
		//	    "type": "string"
		//	  },
		//	  "type": "array",
		//	  "uniqueItems": false
		//	}
		"ip_addresses": schema.ListAttribute{ /*START ATTRIBUTE*/
			ElementType: types.StringType,
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: LdapServerMetadata
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "properties": {
		//	    "Hosts": {
		//	      "insertionOrder": true,
		//	      "items": {
		//	        "type": "string"
		//	      },
		//	      "type": "array",
		//	      "uniqueItems": false
		//	    },
		//	    "RoleBase": {
		//	      "type": "string"
		//	    },
		//	    "RoleName": {
		//	      "type": "string"
		//	    },
		//	    "RoleSearchMatching": {
		//	      "type": "string"
		//	    },
		//	    "RoleSearchSubtree": {
		//	      "type": "boolean"
		//	    },
		//	    "ServiceAccountPassword": {
		//	      "type": "string"
		//	    },
		//	    "ServiceAccountUsername": {
		//	      "type": "string"
		//	    },
		//	    "UserBase": {
		//	      "type": "string"
		//	    },
		//	    "UserRoleName": {
		//	      "type": "string"
		//	    },
		//	    "UserSearchMatching": {
		//	      "type": "string"
		//	    },
		//	    "UserSearchSubtree": {
		//	      "type": "boolean"
		//	    }
		//	  },
		//	  "required": [
		//	    "Hosts",
		//	    "UserSearchMatching",
		//	    "UserBase",
		//	    "RoleSearchMatching",
		//	    "ServiceAccountUsername",
		//	    "RoleBase"
		//	  ],
		//	  "type": "object"
		//	}
		"ldap_server_metadata": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: Hosts
				"hosts": schema.ListAttribute{ /*START ATTRIBUTE*/
					ElementType: types.StringType,
					Computed:    true,
				}, /*END ATTRIBUTE*/
				// Property: RoleBase
				"role_base": schema.StringAttribute{ /*START ATTRIBUTE*/
					Computed: true,
				}, /*END ATTRIBUTE*/
				// Property: RoleName
				"role_name": schema.StringAttribute{ /*START ATTRIBUTE*/
					Computed: true,
				}, /*END ATTRIBUTE*/
				// Property: RoleSearchMatching
				"role_search_matching": schema.StringAttribute{ /*START ATTRIBUTE*/
					Computed: true,
				}, /*END ATTRIBUTE*/
				// Property: RoleSearchSubtree
				"role_search_subtree": schema.BoolAttribute{ /*START ATTRIBUTE*/
					Computed: true,
				}, /*END ATTRIBUTE*/
				// Property: ServiceAccountPassword
				"service_account_password": schema.StringAttribute{ /*START ATTRIBUTE*/
					Computed: true,
				}, /*END ATTRIBUTE*/
				// Property: ServiceAccountUsername
				"service_account_username": schema.StringAttribute{ /*START ATTRIBUTE*/
					Computed: true,
				}, /*END ATTRIBUTE*/
				// Property: UserBase
				"user_base": schema.StringAttribute{ /*START ATTRIBUTE*/
					Computed: true,
				}, /*END ATTRIBUTE*/
				// Property: UserRoleName
				"user_role_name": schema.StringAttribute{ /*START ATTRIBUTE*/
					Computed: true,
				}, /*END ATTRIBUTE*/
				// Property: UserSearchMatching
				"user_search_matching": schema.StringAttribute{ /*START ATTRIBUTE*/
					Computed: true,
				}, /*END ATTRIBUTE*/
				// Property: UserSearchSubtree
				"user_search_subtree": schema.BoolAttribute{ /*START ATTRIBUTE*/
					Computed: true,
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Computed: true,
		}, /*END ATTRIBUTE*/
		// Property: Logs
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "properties": {
		//	    "Audit": {
		//	      "type": "boolean"
		//	    },
		//	    "General": {
		//	      "type": "boolean"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"logs": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: Audit
				"audit": schema.BoolAttribute{ /*START ATTRIBUTE*/
					Computed: true,
				}, /*END ATTRIBUTE*/
				// Property: General
				"general": schema.BoolAttribute{ /*START ATTRIBUTE*/
					Computed: true,
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Computed: true,
		}, /*END ATTRIBUTE*/
		// Property: MaintenanceWindowStartTime
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "properties": {
		//	    "DayOfWeek": {
		//	      "anyOf": [
		//	        {},
		//	        {},
		//	        {},
		//	        {},
		//	        {},
		//	        {},
		//	        {},
		//	        {}
		//	      ],
		//	      "description": "_Allowed Values_: \u003ccode\u003eMONDAY\u003c/code\u003e | \u003ccode\u003eTUESDAY\u003c/code\u003e | \u003ccode\u003eWEDNESDAY\u003c/code\u003e | \u003ccode\u003eTHURSDAY\u003c/code\u003e | \u003ccode\u003eFRIDAY\u003c/code\u003e | \u003ccode\u003eSATURDAY\u003c/code\u003e | \u003ccode\u003eSUNDAY\u003c/code\u003e\n",
		//	      "type": "string"
		//	    },
		//	    "TimeOfDay": {
		//	      "description": "The time, in 24-hour format, and use only numbers separated by a colon, HH:MM or HH:MM:SS. Example: 13:05.\nWhen writing YAML this may need to be quoted to prevent a timestamp being read and converted to a number of minutes or seconds.\n",
		//	      "pattern": "^[0-9]{1,2}:[0-9]{2}(:[0-9]{2})?$",
		//	      "type": "string"
		//	    },
		//	    "TimeZone": {
		//	      "description": "The time zone, UTC by default, in either the Country/City format, or the UTC offset format.",
		//	      "type": "string"
		//	    }
		//	  },
		//	  "required": [
		//	    "DayOfWeek",
		//	    "TimeOfDay",
		//	    "TimeZone"
		//	  ],
		//	  "type": "object"
		//	}
		"maintenance_window_start_time": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: DayOfWeek
				"day_of_week": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "_Allowed Values_: <code>MONDAY</code> | <code>TUESDAY</code> | <code>WEDNESDAY</code> | <code>THURSDAY</code> | <code>FRIDAY</code> | <code>SATURDAY</code> | <code>SUNDAY</code>\n",
					Computed:    true,
				}, /*END ATTRIBUTE*/
				// Property: TimeOfDay
				"time_of_day": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "The time, in 24-hour format, and use only numbers separated by a colon, HH:MM or HH:MM:SS. Example: 13:05.\nWhen writing YAML this may need to be quoted to prevent a timestamp being read and converted to a number of minutes or seconds.\n",
					Computed:    true,
				}, /*END ATTRIBUTE*/
				// Property: TimeZone
				"time_zone": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "The time zone, UTC by default, in either the Country/City format, or the UTC offset format.",
					Computed:    true,
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Computed: true,
		}, /*END ATTRIBUTE*/
		// Property: MqttEndpoints
		// CloudFormation resource type schema:
		//
		//	{
		//	  "insertionOrder": false,
		//	  "items": {
		//	    "type": "string"
		//	  },
		//	  "type": "array",
		//	  "uniqueItems": false
		//	}
		"mqtt_endpoints": schema.ListAttribute{ /*START ATTRIBUTE*/
			ElementType: types.StringType,
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: OpenWireEndpoints
		// CloudFormation resource type schema:
		//
		//	{
		//	  "insertionOrder": false,
		//	  "items": {
		//	    "type": "string"
		//	  },
		//	  "type": "array",
		//	  "uniqueItems": false
		//	}
		"open_wire_endpoints": schema.ListAttribute{ /*START ATTRIBUTE*/
			ElementType: types.StringType,
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: PubliclyAccessible
		// CloudFormation resource type schema:
		//
		//	{
		//	  "type": "boolean"
		//	}
		"publicly_accessible": schema.BoolAttribute{ /*START ATTRIBUTE*/
			Computed: true,
		}, /*END ATTRIBUTE*/
		// Property: SecurityGroups
		// CloudFormation resource type schema:
		//
		//	{
		//	  "insertionOrder": false,
		//	  "items": {
		//	    "type": "string"
		//	  },
		//	  "maxItems": 5,
		//	  "minItems": 1,
		//	  "type": "array",
		//	  "uniqueItems": false
		//	}
		"security_groups": schema.ListAttribute{ /*START ATTRIBUTE*/
			ElementType: types.StringType,
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: StompEndpoints
		// CloudFormation resource type schema:
		//
		//	{
		//	  "insertionOrder": false,
		//	  "items": {
		//	    "type": "string"
		//	  },
		//	  "type": "array",
		//	  "uniqueItems": false
		//	}
		"stomp_endpoints": schema.ListAttribute{ /*START ATTRIBUTE*/
			ElementType: types.StringType,
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: StorageType
		// CloudFormation resource type schema:
		//
		//	{
		//	  "anyOf": [
		//	    {},
		//	    {}
		//	  ],
		//	  "type": "string"
		//	}
		"storage_type": schema.StringAttribute{ /*START ATTRIBUTE*/
			Computed: true,
		}, /*END ATTRIBUTE*/
		// Property: SubnetIds
		// CloudFormation resource type schema:
		//
		//	{
		//	  "insertionOrder": false,
		//	  "items": {
		//	    "type": "string"
		//	  },
		//	  "type": "array",
		//	  "uniqueItems": false
		//	}
		"subnet_ids": schema.ListAttribute{ /*START ATTRIBUTE*/
			ElementType: types.StringType,
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: Tags
		// CloudFormation resource type schema:
		//
		//	{
		//	  "insertionOrder": false,
		//	  "items": {
		//	    "additionalProperties": false,
		//	    "properties": {
		//	      "Key": {
		//	        "type": "string"
		//	      },
		//	      "Value": {
		//	        "type": "string"
		//	      }
		//	    },
		//	    "required": [
		//	      "Key",
		//	      "Value"
		//	    ],
		//	    "type": "object"
		//	  },
		//	  "type": "array",
		//	  "uniqueItems": false
		//	}
		"tags": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: Key
					"key": schema.StringAttribute{ /*START ATTRIBUTE*/
						Computed: true,
					}, /*END ATTRIBUTE*/
					// Property: Value
					"value": schema.StringAttribute{ /*START ATTRIBUTE*/
						Computed: true,
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Computed: true,
		}, /*END ATTRIBUTE*/
		// Property: Users
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "Users to configure on the broker. \nFor RabbitMQ, this should be one user, created when the broker is created, and changes thereafter are ignored.\nFor ActiveMQ, changes to anything but Password are detected and will trigger an update,\nbut changes to Password cannot be detected so updates to Password may not take effect unless there is some other change.\n",
		//	  "insertionOrder": false,
		//	  "items": {
		//	    "additionalProperties": false,
		//	    "properties": {
		//	      "ConsoleAccess": {
		//	        "type": "boolean"
		//	      },
		//	      "Groups": {
		//	        "insertionOrder": false,
		//	        "items": {
		//	          "pattern": "^[A-Za-z0-9._~-]{2,100}$",
		//	          "type": "string"
		//	        },
		//	        "maxItems": 20,
		//	        "type": "array",
		//	        "uniqueItems": false
		//	      },
		//	      "Password": {
		//	        "minLength": 12,
		//	        "pattern": "^[^,:=]+$",
		//	        "type": "string"
		//	      },
		//	      "ReplicationUser": {
		//	        "type": "boolean"
		//	      },
		//	      "Username": {
		//	        "pattern": "^[A-Za-z0-9_.~-]{2,100}$",
		//	        "type": "string"
		//	      }
		//	    },
		//	    "required": [
		//	      "Username",
		//	      "Password"
		//	    ],
		//	    "type": "object"
		//	  },
		//	  "type": "array",
		//	  "uniqueItems": false
		//	}
		"users": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: ConsoleAccess
					"console_access": schema.BoolAttribute{ /*START ATTRIBUTE*/
						Computed: true,
					}, /*END ATTRIBUTE*/
					// Property: Groups
					"groups": schema.ListAttribute{ /*START ATTRIBUTE*/
						ElementType: types.StringType,
						Computed:    true,
					}, /*END ATTRIBUTE*/
					// Property: Password
					"password": schema.StringAttribute{ /*START ATTRIBUTE*/
						Computed: true,
					}, /*END ATTRIBUTE*/
					// Property: ReplicationUser
					"replication_user": schema.BoolAttribute{ /*START ATTRIBUTE*/
						Computed: true,
					}, /*END ATTRIBUTE*/
					// Property: Username
					"username": schema.StringAttribute{ /*START ATTRIBUTE*/
						Computed: true,
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Description: "Users to configure on the broker. \nFor RabbitMQ, this should be one user, created when the broker is created, and changes thereafter are ignored.\nFor ActiveMQ, changes to anything but Password are detected and will trigger an update,\nbut changes to Password cannot be detected so updates to Password may not take effect unless there is some other change.\n",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: WssEndpoints
		// CloudFormation resource type schema:
		//
		//	{
		//	  "insertionOrder": false,
		//	  "items": {
		//	    "type": "string"
		//	  },
		//	  "type": "array",
		//	  "uniqueItems": false
		//	}
		"wss_endpoints": schema.ListAttribute{ /*START ATTRIBUTE*/
			ElementType: types.StringType,
			Computed:    true,
		}, /*END ATTRIBUTE*/
	} /*END SCHEMA*/

	attributes["id"] = schema.StringAttribute{
		Description: "Uniquely identifies the resource.",
		Required:    true,
	}

	schema := schema.Schema{
		Description: "Data Source schema for AWS::AmazonMQ::Broker",
		Attributes:  attributes,
	}

	var opts generic.DataSourceOptions

	opts = opts.WithCloudFormationTypeName("AWS::AmazonMQ::Broker").WithTerraformTypeName("awscc_amazonmq_broker")
	opts = opts.WithTerraformSchema(schema)
	opts = opts.WithAttributeNameMap(map[string]string{
		"amqp_endpoints":                      "AmqpEndpoints",
		"arn":                                 "Arn",
		"audit":                               "Audit",
		"authentication_strategy":             "AuthenticationStrategy",
		"auto_minor_version_upgrade":          "AutoMinorVersionUpgrade",
		"broker_id":                           "Id",
		"broker_name":                         "BrokerName",
		"configuration":                       "Configuration",
		"configuration_id":                    "ConfigurationId",
		"configuration_revision":              "ConfigurationRevision",
		"console_access":                      "ConsoleAccess",
		"console_ur_ls":                       "ConsoleURLs",
		"data_replication_mode":               "DataReplicationMode",
		"data_replication_primary_broker_arn": "DataReplicationPrimaryBrokerArn",
		"day_of_week":                         "DayOfWeek",
		"deployment_mode":                     "DeploymentMode",
		"encryption_options":                  "EncryptionOptions",
		"engine_type":                         "EngineType",
		"engine_version":                      "EngineVersion",
		"engine_version_current":              "EngineVersionCurrent",
		"general":                             "General",
		"groups":                              "Groups",
		"host_instance_type":                  "HostInstanceType",
		"hosts":                               "Hosts",
		"id":                                  "Id",
		"ip_addresses":                        "IpAddresses",
		"key":                                 "Key",
		"kms_key_id":                          "KmsKeyId",
		"ldap_server_metadata":                "LdapServerMetadata",
		"logs":                                "Logs",
		"maintenance_window_start_time":       "MaintenanceWindowStartTime",
		"mqtt_endpoints":                      "MqttEndpoints",
		"open_wire_endpoints":                 "OpenWireEndpoints",
		"password":                            "Password",
		"publicly_accessible":                 "PubliclyAccessible",
		"replication_user":                    "ReplicationUser",
		"revision":                            "Revision",
		"role_base":                           "RoleBase",
		"role_name":                           "RoleName",
		"role_search_matching":                "RoleSearchMatching",
		"role_search_subtree":                 "RoleSearchSubtree",
		"security_groups":                     "SecurityGroups",
		"service_account_password":            "ServiceAccountPassword",
		"service_account_username":            "ServiceAccountUsername",
		"stomp_endpoints":                     "StompEndpoints",
		"storage_type":                        "StorageType",
		"subnet_ids":                          "SubnetIds",
		"tags":                                "Tags",
		"time_of_day":                         "TimeOfDay",
		"time_zone":                           "TimeZone",
		"use_aws_owned_key":                   "UseAwsOwnedKey",
		"user_base":                           "UserBase",
		"user_role_name":                      "UserRoleName",
		"user_search_matching":                "UserSearchMatching",
		"user_search_subtree":                 "UserSearchSubtree",
		"username":                            "Username",
		"users":                               "Users",
		"value":                               "Value",
		"wss_endpoints":                       "WssEndpoints",
	})

	v, err := generic.NewSingularDataSource(ctx, opts...)

	if err != nil {
		return nil, err
	}

	return v, nil
}
