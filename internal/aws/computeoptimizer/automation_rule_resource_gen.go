// Copyright IBM Corp. 2021, 2026
// SPDX-License-Identifier: MPL-2.0

// Code generated by generators/resource/main.go; DO NOT EDIT.

package computeoptimizer

import (
	"context"
	"regexp"

	"github.com/hashicorp/terraform-plugin-framework-timetypes/timetypes"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-provider-awscc/internal/generic"
	"github.com/hashicorp/terraform-provider-awscc/internal/identity"
	"github.com/hashicorp/terraform-provider-awscc/internal/registry"
	fwvalidators "github.com/hashicorp/terraform-provider-awscc/internal/validators"
)

func init() {
	registry.AddResourceFactory("awscc_computeoptimizer_automation_rule", automationRuleResource)
	registry.AddListResourceFactory("awscc_computeoptimizer_automation_rule", generic.NewListResource(automationRuleResource))
}

// automationRuleResource returns the Terraform awscc_computeoptimizer_automation_rule resource.
// This Terraform resource corresponds to the CloudFormation AWS::ComputeOptimizer::AutomationRule resource.
func automationRuleResource(ctx context.Context) (resource.Resource, error) {
	attributes := map[string]schema.Attribute{ /*START SCHEMA*/
		// Property: AccountId
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The AWS account ID that owns the automation rule.",
		//	  "pattern": "^[0-9]{12}$",
		//	  "type": "string"
		//	}
		"account_id": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The AWS account ID that owns the automation rule.",
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: CreatedTimestamp
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The timestamp when the automation rule was created.",
		//	  "format": "date-time",
		//	  "type": "string"
		//	}
		"created_timestamp": schema.StringAttribute{ /*START ATTRIBUTE*/
			CustomType:  timetypes.RFC3339Type{},
			Description: "The timestamp when the automation rule was created.",
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Criteria
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "Filter criteria that specify which recommended actions qualify for implementation.",
		//	  "properties": {
		//	    "EbsVolumeSizeInGib": {
		//	      "insertionOrder": false,
		//	      "items": {
		//	        "additionalProperties": false,
		//	        "properties": {
		//	          "Comparison": {
		//	            "enum": [
		//	              "StringEquals",
		//	              "StringNotEquals",
		//	              "StringEqualsIgnoreCase",
		//	              "StringNotEqualsIgnoreCase",
		//	              "StringLike",
		//	              "StringNotLike",
		//	              "NumericEquals",
		//	              "NumericNotEquals",
		//	              "NumericLessThan",
		//	              "NumericLessThanEquals",
		//	              "NumericGreaterThan",
		//	              "NumericGreaterThanEquals"
		//	            ],
		//	            "type": "string"
		//	          },
		//	          "Values": {
		//	            "insertionOrder": false,
		//	            "items": {
		//	              "type": "integer"
		//	            },
		//	            "type": "array"
		//	          }
		//	        },
		//	        "type": "object"
		//	      },
		//	      "type": "array"
		//	    },
		//	    "EbsVolumeType": {
		//	      "insertionOrder": false,
		//	      "items": {
		//	        "additionalProperties": false,
		//	        "properties": {
		//	          "Comparison": {
		//	            "enum": [
		//	              "StringEquals",
		//	              "StringNotEquals",
		//	              "StringEqualsIgnoreCase",
		//	              "StringNotEqualsIgnoreCase",
		//	              "StringLike",
		//	              "StringNotLike",
		//	              "NumericEquals",
		//	              "NumericNotEquals",
		//	              "NumericLessThan",
		//	              "NumericLessThanEquals",
		//	              "NumericGreaterThan",
		//	              "NumericGreaterThanEquals"
		//	            ],
		//	            "type": "string"
		//	          },
		//	          "Values": {
		//	            "insertionOrder": false,
		//	            "items": {
		//	              "maxLength": 512,
		//	              "minLength": 1,
		//	              "pattern": "^[\\w\\s\\.\\-\\:\\/\\=\\+\\@\\*\\?]+$",
		//	              "type": "string"
		//	            },
		//	            "type": "array"
		//	          }
		//	        },
		//	        "type": "object"
		//	      },
		//	      "type": "array"
		//	    },
		//	    "EstimatedMonthlySavings": {
		//	      "insertionOrder": false,
		//	      "items": {
		//	        "additionalProperties": false,
		//	        "properties": {
		//	          "Comparison": {
		//	            "enum": [
		//	              "StringEquals",
		//	              "StringNotEquals",
		//	              "StringEqualsIgnoreCase",
		//	              "StringNotEqualsIgnoreCase",
		//	              "StringLike",
		//	              "StringNotLike",
		//	              "NumericEquals",
		//	              "NumericNotEquals",
		//	              "NumericLessThan",
		//	              "NumericLessThanEquals",
		//	              "NumericGreaterThan",
		//	              "NumericGreaterThanEquals"
		//	            ],
		//	            "type": "string"
		//	          },
		//	          "Values": {
		//	            "insertionOrder": false,
		//	            "items": {
		//	              "type": "number"
		//	            },
		//	            "type": "array"
		//	          }
		//	        },
		//	        "type": "object"
		//	      },
		//	      "type": "array"
		//	    },
		//	    "LookBackPeriodInDays": {
		//	      "insertionOrder": false,
		//	      "items": {
		//	        "additionalProperties": false,
		//	        "properties": {
		//	          "Comparison": {
		//	            "enum": [
		//	              "StringEquals",
		//	              "StringNotEquals",
		//	              "StringEqualsIgnoreCase",
		//	              "StringNotEqualsIgnoreCase",
		//	              "StringLike",
		//	              "StringNotLike",
		//	              "NumericEquals",
		//	              "NumericNotEquals",
		//	              "NumericLessThan",
		//	              "NumericLessThanEquals",
		//	              "NumericGreaterThan",
		//	              "NumericGreaterThanEquals"
		//	            ],
		//	            "type": "string"
		//	          },
		//	          "Values": {
		//	            "insertionOrder": false,
		//	            "items": {
		//	              "type": "integer"
		//	            },
		//	            "type": "array"
		//	          }
		//	        },
		//	        "type": "object"
		//	      },
		//	      "type": "array"
		//	    },
		//	    "Region": {
		//	      "insertionOrder": false,
		//	      "items": {
		//	        "additionalProperties": false,
		//	        "properties": {
		//	          "Comparison": {
		//	            "enum": [
		//	              "StringEquals",
		//	              "StringNotEquals",
		//	              "StringEqualsIgnoreCase",
		//	              "StringNotEqualsIgnoreCase",
		//	              "StringLike",
		//	              "StringNotLike",
		//	              "NumericEquals",
		//	              "NumericNotEquals",
		//	              "NumericLessThan",
		//	              "NumericLessThanEquals",
		//	              "NumericGreaterThan",
		//	              "NumericGreaterThanEquals"
		//	            ],
		//	            "type": "string"
		//	          },
		//	          "Values": {
		//	            "insertionOrder": false,
		//	            "items": {
		//	              "maxLength": 512,
		//	              "minLength": 1,
		//	              "pattern": "^[\\w\\s\\.\\-\\:\\/\\=\\+\\@\\*\\?]+$",
		//	              "type": "string"
		//	            },
		//	            "type": "array"
		//	          }
		//	        },
		//	        "type": "object"
		//	      },
		//	      "type": "array"
		//	    },
		//	    "ResourceArn": {
		//	      "insertionOrder": false,
		//	      "items": {
		//	        "additionalProperties": false,
		//	        "properties": {
		//	          "Comparison": {
		//	            "enum": [
		//	              "StringEquals",
		//	              "StringNotEquals",
		//	              "StringEqualsIgnoreCase",
		//	              "StringNotEqualsIgnoreCase",
		//	              "StringLike",
		//	              "StringNotLike",
		//	              "NumericEquals",
		//	              "NumericNotEquals",
		//	              "NumericLessThan",
		//	              "NumericLessThanEquals",
		//	              "NumericGreaterThan",
		//	              "NumericGreaterThanEquals"
		//	            ],
		//	            "type": "string"
		//	          },
		//	          "Values": {
		//	            "insertionOrder": false,
		//	            "items": {
		//	              "maxLength": 512,
		//	              "minLength": 1,
		//	              "pattern": "^[\\w\\s\\.\\-\\:\\/\\=\\+\\@\\*\\?]+$",
		//	              "type": "string"
		//	            },
		//	            "type": "array"
		//	          }
		//	        },
		//	        "type": "object"
		//	      },
		//	      "type": "array"
		//	    },
		//	    "ResourceTag": {
		//	      "insertionOrder": false,
		//	      "items": {
		//	        "additionalProperties": false,
		//	        "properties": {
		//	          "Comparison": {
		//	            "enum": [
		//	              "StringEquals",
		//	              "StringNotEquals",
		//	              "StringEqualsIgnoreCase",
		//	              "StringNotEqualsIgnoreCase",
		//	              "StringLike",
		//	              "StringNotLike",
		//	              "NumericEquals",
		//	              "NumericNotEquals",
		//	              "NumericLessThan",
		//	              "NumericLessThanEquals",
		//	              "NumericGreaterThan",
		//	              "NumericGreaterThanEquals"
		//	            ],
		//	            "type": "string"
		//	          },
		//	          "Key": {
		//	            "maxLength": 512,
		//	            "minLength": 1,
		//	            "pattern": "^[\\w\\s\\.\\-\\:\\/\\=\\+\\@\\*\\?]+$",
		//	            "type": "string"
		//	          },
		//	          "Values": {
		//	            "insertionOrder": false,
		//	            "items": {
		//	              "maxLength": 512,
		//	              "minLength": 1,
		//	              "pattern": "^[\\w\\s\\.\\-\\:\\/\\=\\+\\@\\*\\?]+$",
		//	              "type": "string"
		//	            },
		//	            "type": "array"
		//	          }
		//	        },
		//	        "type": "object"
		//	      },
		//	      "type": "array"
		//	    },
		//	    "RestartNeeded": {
		//	      "insertionOrder": false,
		//	      "items": {
		//	        "additionalProperties": false,
		//	        "properties": {
		//	          "Comparison": {
		//	            "enum": [
		//	              "StringEquals",
		//	              "StringNotEquals",
		//	              "StringEqualsIgnoreCase",
		//	              "StringNotEqualsIgnoreCase",
		//	              "StringLike",
		//	              "StringNotLike",
		//	              "NumericEquals",
		//	              "NumericNotEquals",
		//	              "NumericLessThan",
		//	              "NumericLessThanEquals",
		//	              "NumericGreaterThan",
		//	              "NumericGreaterThanEquals"
		//	            ],
		//	            "type": "string"
		//	          },
		//	          "Values": {
		//	            "insertionOrder": false,
		//	            "items": {
		//	              "maxLength": 512,
		//	              "minLength": 1,
		//	              "pattern": "^[\\w\\s\\.\\-\\:\\/\\=\\+\\@\\*\\?]+$",
		//	              "type": "string"
		//	            },
		//	            "type": "array"
		//	          }
		//	        },
		//	        "type": "object"
		//	      },
		//	      "type": "array"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"criteria": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: EbsVolumeSizeInGib
				"ebs_volume_size_in_gib": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
					NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: Comparison
							"comparison": schema.StringAttribute{ /*START ATTRIBUTE*/
								Optional: true,
								Computed: true,
								Validators: []validator.String{ /*START VALIDATORS*/
									stringvalidator.OneOf(
										"StringEquals",
										"StringNotEquals",
										"StringEqualsIgnoreCase",
										"StringNotEqualsIgnoreCase",
										"StringLike",
										"StringNotLike",
										"NumericEquals",
										"NumericNotEquals",
										"NumericLessThan",
										"NumericLessThanEquals",
										"NumericGreaterThan",
										"NumericGreaterThanEquals",
									),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
									stringplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: Values
							"values": schema.ListAttribute{ /*START ATTRIBUTE*/
								ElementType: types.Int64Type,
								Optional:    true,
								Computed:    true,
								PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
									generic.Multiset(),
									listplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
					}, /*END NESTED OBJECT*/
					Optional: true,
					Computed: true,
					PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
						generic.Multiset(),
						listplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: EbsVolumeType
				"ebs_volume_type": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
					NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: Comparison
							"comparison": schema.StringAttribute{ /*START ATTRIBUTE*/
								Optional: true,
								Computed: true,
								Validators: []validator.String{ /*START VALIDATORS*/
									stringvalidator.OneOf(
										"StringEquals",
										"StringNotEquals",
										"StringEqualsIgnoreCase",
										"StringNotEqualsIgnoreCase",
										"StringLike",
										"StringNotLike",
										"NumericEquals",
										"NumericNotEquals",
										"NumericLessThan",
										"NumericLessThanEquals",
										"NumericGreaterThan",
										"NumericGreaterThanEquals",
									),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
									stringplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: Values
							"values": schema.ListAttribute{ /*START ATTRIBUTE*/
								ElementType: types.StringType,
								Optional:    true,
								Computed:    true,
								Validators: []validator.List{ /*START VALIDATORS*/
									listvalidator.ValueStringsAre(
										stringvalidator.LengthBetween(1, 512),
										stringvalidator.RegexMatches(regexp.MustCompile("^[\\w\\s\\.\\-\\:\\/\\=\\+\\@\\*\\?]+$"), ""),
									),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
									generic.Multiset(),
									listplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
					}, /*END NESTED OBJECT*/
					Optional: true,
					Computed: true,
					PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
						generic.Multiset(),
						listplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: EstimatedMonthlySavings
				"estimated_monthly_savings": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
					NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: Comparison
							"comparison": schema.StringAttribute{ /*START ATTRIBUTE*/
								Optional: true,
								Computed: true,
								Validators: []validator.String{ /*START VALIDATORS*/
									stringvalidator.OneOf(
										"StringEquals",
										"StringNotEquals",
										"StringEqualsIgnoreCase",
										"StringNotEqualsIgnoreCase",
										"StringLike",
										"StringNotLike",
										"NumericEquals",
										"NumericNotEquals",
										"NumericLessThan",
										"NumericLessThanEquals",
										"NumericGreaterThan",
										"NumericGreaterThanEquals",
									),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
									stringplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: Values
							"values": schema.ListAttribute{ /*START ATTRIBUTE*/
								ElementType: types.Float64Type,
								Optional:    true,
								Computed:    true,
								PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
									generic.Multiset(),
									listplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
					}, /*END NESTED OBJECT*/
					Optional: true,
					Computed: true,
					PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
						generic.Multiset(),
						listplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: LookBackPeriodInDays
				"look_back_period_in_days": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
					NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: Comparison
							"comparison": schema.StringAttribute{ /*START ATTRIBUTE*/
								Optional: true,
								Computed: true,
								Validators: []validator.String{ /*START VALIDATORS*/
									stringvalidator.OneOf(
										"StringEquals",
										"StringNotEquals",
										"StringEqualsIgnoreCase",
										"StringNotEqualsIgnoreCase",
										"StringLike",
										"StringNotLike",
										"NumericEquals",
										"NumericNotEquals",
										"NumericLessThan",
										"NumericLessThanEquals",
										"NumericGreaterThan",
										"NumericGreaterThanEquals",
									),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
									stringplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: Values
							"values": schema.ListAttribute{ /*START ATTRIBUTE*/
								ElementType: types.Int64Type,
								Optional:    true,
								Computed:    true,
								PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
									generic.Multiset(),
									listplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
					}, /*END NESTED OBJECT*/
					Optional: true,
					Computed: true,
					PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
						generic.Multiset(),
						listplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: Region
				"region": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
					NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: Comparison
							"comparison": schema.StringAttribute{ /*START ATTRIBUTE*/
								Optional: true,
								Computed: true,
								Validators: []validator.String{ /*START VALIDATORS*/
									stringvalidator.OneOf(
										"StringEquals",
										"StringNotEquals",
										"StringEqualsIgnoreCase",
										"StringNotEqualsIgnoreCase",
										"StringLike",
										"StringNotLike",
										"NumericEquals",
										"NumericNotEquals",
										"NumericLessThan",
										"NumericLessThanEquals",
										"NumericGreaterThan",
										"NumericGreaterThanEquals",
									),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
									stringplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: Values
							"values": schema.ListAttribute{ /*START ATTRIBUTE*/
								ElementType: types.StringType,
								Optional:    true,
								Computed:    true,
								Validators: []validator.List{ /*START VALIDATORS*/
									listvalidator.ValueStringsAre(
										stringvalidator.LengthBetween(1, 512),
										stringvalidator.RegexMatches(regexp.MustCompile("^[\\w\\s\\.\\-\\:\\/\\=\\+\\@\\*\\?]+$"), ""),
									),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
									generic.Multiset(),
									listplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
					}, /*END NESTED OBJECT*/
					Optional: true,
					Computed: true,
					PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
						generic.Multiset(),
						listplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: ResourceArn
				"resource_arn": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
					NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: Comparison
							"comparison": schema.StringAttribute{ /*START ATTRIBUTE*/
								Optional: true,
								Computed: true,
								Validators: []validator.String{ /*START VALIDATORS*/
									stringvalidator.OneOf(
										"StringEquals",
										"StringNotEquals",
										"StringEqualsIgnoreCase",
										"StringNotEqualsIgnoreCase",
										"StringLike",
										"StringNotLike",
										"NumericEquals",
										"NumericNotEquals",
										"NumericLessThan",
										"NumericLessThanEquals",
										"NumericGreaterThan",
										"NumericGreaterThanEquals",
									),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
									stringplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: Values
							"values": schema.ListAttribute{ /*START ATTRIBUTE*/
								ElementType: types.StringType,
								Optional:    true,
								Computed:    true,
								Validators: []validator.List{ /*START VALIDATORS*/
									listvalidator.ValueStringsAre(
										stringvalidator.LengthBetween(1, 512),
										stringvalidator.RegexMatches(regexp.MustCompile("^[\\w\\s\\.\\-\\:\\/\\=\\+\\@\\*\\?]+$"), ""),
									),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
									generic.Multiset(),
									listplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
					}, /*END NESTED OBJECT*/
					Optional: true,
					Computed: true,
					PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
						generic.Multiset(),
						listplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: ResourceTag
				"resource_tag": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
					NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: Comparison
							"comparison": schema.StringAttribute{ /*START ATTRIBUTE*/
								Optional: true,
								Computed: true,
								Validators: []validator.String{ /*START VALIDATORS*/
									stringvalidator.OneOf(
										"StringEquals",
										"StringNotEquals",
										"StringEqualsIgnoreCase",
										"StringNotEqualsIgnoreCase",
										"StringLike",
										"StringNotLike",
										"NumericEquals",
										"NumericNotEquals",
										"NumericLessThan",
										"NumericLessThanEquals",
										"NumericGreaterThan",
										"NumericGreaterThanEquals",
									),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
									stringplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: Key
							"key": schema.StringAttribute{ /*START ATTRIBUTE*/
								Optional: true,
								Computed: true,
								Validators: []validator.String{ /*START VALIDATORS*/
									stringvalidator.LengthBetween(1, 512),
									stringvalidator.RegexMatches(regexp.MustCompile("^[\\w\\s\\.\\-\\:\\/\\=\\+\\@\\*\\?]+$"), ""),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
									stringplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: Values
							"values": schema.ListAttribute{ /*START ATTRIBUTE*/
								ElementType: types.StringType,
								Optional:    true,
								Computed:    true,
								Validators: []validator.List{ /*START VALIDATORS*/
									listvalidator.ValueStringsAre(
										stringvalidator.LengthBetween(1, 512),
										stringvalidator.RegexMatches(regexp.MustCompile("^[\\w\\s\\.\\-\\:\\/\\=\\+\\@\\*\\?]+$"), ""),
									),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
									generic.Multiset(),
									listplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
					}, /*END NESTED OBJECT*/
					Optional: true,
					Computed: true,
					PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
						generic.Multiset(),
						listplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: RestartNeeded
				"restart_needed": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
					NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: Comparison
							"comparison": schema.StringAttribute{ /*START ATTRIBUTE*/
								Optional: true,
								Computed: true,
								Validators: []validator.String{ /*START VALIDATORS*/
									stringvalidator.OneOf(
										"StringEquals",
										"StringNotEquals",
										"StringEqualsIgnoreCase",
										"StringNotEqualsIgnoreCase",
										"StringLike",
										"StringNotLike",
										"NumericEquals",
										"NumericNotEquals",
										"NumericLessThan",
										"NumericLessThanEquals",
										"NumericGreaterThan",
										"NumericGreaterThanEquals",
									),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
									stringplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: Values
							"values": schema.ListAttribute{ /*START ATTRIBUTE*/
								ElementType: types.StringType,
								Optional:    true,
								Computed:    true,
								Validators: []validator.List{ /*START VALIDATORS*/
									listvalidator.ValueStringsAre(
										stringvalidator.LengthBetween(1, 512),
										stringvalidator.RegexMatches(regexp.MustCompile("^[\\w\\s\\.\\-\\:\\/\\=\\+\\@\\*\\?]+$"), ""),
									),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
									generic.Multiset(),
									listplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
					}, /*END NESTED OBJECT*/
					Optional: true,
					Computed: true,
					PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
						generic.Multiset(),
						listplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "Filter criteria that specify which recommended actions qualify for implementation.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Description
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The description of the automation rule.",
		//	  "maxLength": 1024,
		//	  "minLength": 0,
		//	  "pattern": "^[a-zA-Z0-9_\\-\\s@\\.]*$",
		//	  "type": "string"
		//	}
		"description": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The description of the automation rule.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.LengthBetween(0, 1024),
				stringvalidator.RegexMatches(regexp.MustCompile("^[a-zA-Z0-9_\\-\\s@\\.]*$"), ""),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: LastUpdatedTimestamp
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The timestamp when the automation rule was last updated.",
		//	  "format": "date-time",
		//	  "type": "string"
		//	}
		"last_updated_timestamp": schema.StringAttribute{ /*START ATTRIBUTE*/
			CustomType:  timetypes.RFC3339Type{},
			Description: "The timestamp when the automation rule was last updated.",
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Name
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The name of the automation rule.",
		//	  "maxLength": 128,
		//	  "minLength": 0,
		//	  "pattern": "^[a-zA-Z0-9_-]*$",
		//	  "type": "string"
		//	}
		"name": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The name of the automation rule.",
			Required:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.LengthBetween(0, 128),
				stringvalidator.RegexMatches(regexp.MustCompile("^[a-zA-Z0-9_-]*$"), ""),
			}, /*END VALIDATORS*/
		}, /*END ATTRIBUTE*/
		// Property: OrganizationConfiguration
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "Organization configuration for organization rules, including rule apply order and account scope.",
		//	  "properties": {
		//	    "AccountIds": {
		//	      "description": "List of account IDs where the organization rule applies",
		//	      "insertionOrder": false,
		//	      "items": {
		//	        "pattern": "^[0-9]{12}$",
		//	        "type": "string"
		//	      },
		//	      "maxItems": 50,
		//	      "minItems": 1,
		//	      "type": "array"
		//	    },
		//	    "RuleApplyOrder": {
		//	      "description": "When the rule should be applied relative to account rules",
		//	      "enum": [
		//	        "BeforeAccountRules",
		//	        "AfterAccountRules"
		//	      ],
		//	      "type": "string"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"organization_configuration": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: AccountIds
				"account_ids": schema.ListAttribute{ /*START ATTRIBUTE*/
					ElementType: types.StringType,
					Description: "List of account IDs where the organization rule applies",
					Optional:    true,
					Computed:    true,
					Validators: []validator.List{ /*START VALIDATORS*/
						listvalidator.SizeBetween(1, 50),
						listvalidator.ValueStringsAre(
							stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]{12}$"), ""),
						),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
						generic.Multiset(),
						listplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: RuleApplyOrder
				"rule_apply_order": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "When the rule should be applied relative to account rules",
					Optional:    true,
					Computed:    true,
					Validators: []validator.String{ /*START VALIDATORS*/
						stringvalidator.OneOf(
							"BeforeAccountRules",
							"AfterAccountRules",
						),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "Organization configuration for organization rules, including rule apply order and account scope.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Priority
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "Rule priority within its group",
		//	  "type": "string"
		//	}
		"priority": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "Rule priority within its group",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: RecommendedActionTypes
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The types of recommended actions this rule will implement.",
		//	  "insertionOrder": false,
		//	  "items": {
		//	    "enum": [
		//	      "SnapshotAndDeleteUnattachedEbsVolume",
		//	      "UpgradeEbsVolumeType"
		//	    ],
		//	    "type": "string"
		//	  },
		//	  "minItems": 1,
		//	  "type": "array"
		//	}
		"recommended_action_types": schema.ListAttribute{ /*START ATTRIBUTE*/
			ElementType: types.StringType,
			Description: "The types of recommended actions this rule will implement.",
			Required:    true,
			Validators: []validator.List{ /*START VALIDATORS*/
				listvalidator.SizeAtLeast(1),
				listvalidator.ValueStringsAre(
					stringvalidator.OneOf(
						"SnapshotAndDeleteUnattachedEbsVolume",
						"UpgradeEbsVolumeType",
					),
				),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
				generic.Multiset(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: RuleArn
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The Amazon Resource Name (ARN) of the automation rule.",
		//	  "type": "string"
		//	}
		"rule_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The Amazon Resource Name (ARN) of the automation rule.",
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: RuleId
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The unique identifier of the automation rule.",
		//	  "pattern": "^[0-9A-Za-z]{16}$",
		//	  "type": "string"
		//	}
		"rule_id": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The unique identifier of the automation rule.",
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: RuleRevision
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The revision number of the automation rule.",
		//	  "type": "string"
		//	}
		"rule_revision": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The revision number of the automation rule.",
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: RuleType
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The type of automation rule.",
		//	  "enum": [
		//	    "AccountRule",
		//	    "OrganizationRule"
		//	  ],
		//	  "type": "string"
		//	}
		"rule_type": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The type of automation rule.",
			Required:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.OneOf(
					"AccountRule",
					"OrganizationRule",
				),
			}, /*END VALIDATORS*/
		}, /*END ATTRIBUTE*/
		// Property: Schedule
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "The schedule configuration for when the rule runs.",
		//	  "properties": {
		//	    "ExecutionWindowInMinutes": {
		//	      "description": "Execution window duration in minutes",
		//	      "maximum": 1440,
		//	      "minimum": 60,
		//	      "type": "integer"
		//	    },
		//	    "ScheduleExpression": {
		//	      "description": "Schedule expression (e.g., cron or rate expression)",
		//	      "type": "string"
		//	    },
		//	    "ScheduleExpressionTimezone": {
		//	      "description": "IANA timezone identifier",
		//	      "type": "string"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"schedule": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: ExecutionWindowInMinutes
				"execution_window_in_minutes": schema.Int64Attribute{ /*START ATTRIBUTE*/
					Description: "Execution window duration in minutes",
					Optional:    true,
					Computed:    true,
					Validators: []validator.Int64{ /*START VALIDATORS*/
						int64validator.Between(60, 1440),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
						int64planmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: ScheduleExpression
				"schedule_expression": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "Schedule expression (e.g., cron or rate expression)",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: ScheduleExpressionTimezone
				"schedule_expression_timezone": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "IANA timezone identifier",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "The schedule configuration for when the rule runs.",
			Required:    true,
		}, /*END ATTRIBUTE*/
		// Property: Status
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The status of the automation rule.",
		//	  "enum": [
		//	    "Active",
		//	    "Inactive"
		//	  ],
		//	  "type": "string"
		//	}
		"status": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The status of the automation rule.",
			Required:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.OneOf(
					"Active",
					"Inactive",
				),
			}, /*END VALIDATORS*/
		}, /*END ATTRIBUTE*/
		// Property: Tags
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "Tags associated with the automation rule.",
		//	  "insertionOrder": false,
		//	  "items": {
		//	    "additionalProperties": false,
		//	    "properties": {
		//	      "Key": {
		//	        "maxLength": 128,
		//	        "minLength": 1,
		//	        "pattern": "^[\\w\\s\\.\\-\\:\\/\\=\\+\\@]+$",
		//	        "type": "string"
		//	      },
		//	      "Value": {
		//	        "maxLength": 256,
		//	        "pattern": "^[\\w\\s\\.\\-\\:\\/\\=\\+\\@]*$",
		//	        "type": "string"
		//	      }
		//	    },
		//	    "required": [
		//	      "Key",
		//	      "Value"
		//	    ],
		//	    "type": "object"
		//	  },
		//	  "maxItems": 200,
		//	  "type": "array"
		//	}
		"tags": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: Key
					"key": schema.StringAttribute{ /*START ATTRIBUTE*/
						Optional: true,
						Computed: true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.LengthBetween(1, 128),
							stringvalidator.RegexMatches(regexp.MustCompile("^[\\w\\s\\.\\-\\:\\/\\=\\+\\@]+$"), ""),
							fwvalidators.NotNullString(),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: Value
					"value": schema.StringAttribute{ /*START ATTRIBUTE*/
						Optional: true,
						Computed: true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.LengthAtMost(256),
							stringvalidator.RegexMatches(regexp.MustCompile("^[\\w\\s\\.\\-\\:\\/\\=\\+\\@]*$"), ""),
							fwvalidators.NotNullString(),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Description: "Tags associated with the automation rule.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.List{ /*START VALIDATORS*/
				listvalidator.SizeAtMost(200),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
				generic.Multiset(),
				listplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
	} /*END SCHEMA*/

	// Corresponds to CloudFormation primaryIdentifier.
	attributes["id"] = schema.StringAttribute{
		Description: "Uniquely identifies the resource.",
		Computed:    true,
		PlanModifiers: []planmodifier.String{
			stringplanmodifier.UseStateForUnknown(),
		},
	}

	schema := schema.Schema{
		Description: "Creates an AWS Compute Optimizer automation rule that automatically implements recommended actions based on your defined criteria and schedule. Automation rules are global resources that manage automated actions across all AWS Regions where Compute Optimizer Automation is available. Organization-level rules can only be created by the management account or delegated administrator.",
		Version:     1,
		Attributes:  attributes,
	}

	var opts generic.ResourceOptions

	opts = opts.WithCloudFormationTypeName("AWS::ComputeOptimizer::AutomationRule").WithTerraformTypeName("awscc_computeoptimizer_automation_rule")
	opts = opts.WithTerraformSchema(schema)
	opts = opts.WithPrimaryIdentifier(
		identity.Identifier{
			Name:              "rule_arn",
			Description:       "The Amazon Resource Name (ARN) of the automation rule",
			RequiredForImport: true,
		})

	opts = opts.WithAttributeNameMap(map[string]string{
		"account_id":                   "AccountId",
		"account_ids":                  "AccountIds",
		"comparison":                   "Comparison",
		"created_timestamp":            "CreatedTimestamp",
		"criteria":                     "Criteria",
		"description":                  "Description",
		"ebs_volume_size_in_gib":       "EbsVolumeSizeInGib",
		"ebs_volume_type":              "EbsVolumeType",
		"estimated_monthly_savings":    "EstimatedMonthlySavings",
		"execution_window_in_minutes":  "ExecutionWindowInMinutes",
		"key":                          "Key",
		"last_updated_timestamp":       "LastUpdatedTimestamp",
		"look_back_period_in_days":     "LookBackPeriodInDays",
		"name":                         "Name",
		"organization_configuration":   "OrganizationConfiguration",
		"priority":                     "Priority",
		"recommended_action_types":     "RecommendedActionTypes",
		"region":                       "Region",
		"resource_arn":                 "ResourceArn",
		"resource_tag":                 "ResourceTag",
		"restart_needed":               "RestartNeeded",
		"rule_apply_order":             "RuleApplyOrder",
		"rule_arn":                     "RuleArn",
		"rule_id":                      "RuleId",
		"rule_revision":                "RuleRevision",
		"rule_type":                    "RuleType",
		"schedule":                     "Schedule",
		"schedule_expression":          "ScheduleExpression",
		"schedule_expression_timezone": "ScheduleExpressionTimezone",
		"status":                       "Status",
		"tags":                         "Tags",
		"value":                        "Value",
		"values":                       "Values",
	})

	opts = opts.WithCreateTimeoutInMinutes(0).WithDeleteTimeoutInMinutes(0)

	opts = opts.WithUpdateTimeoutInMinutes(0)

	v, err := generic.NewResource(ctx, opts...)

	if err != nil {
		return nil, err
	}

	return v, nil
}
