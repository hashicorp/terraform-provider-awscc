// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// Code generated by generators/resource/main.go; DO NOT EDIT.

package sagemaker

import (
	"context"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/mapplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-provider-awscc/internal/generic"
	"github.com/hashicorp/terraform-provider-awscc/internal/registry"
	"regexp"
)

func init() {
	registry.AddResourceFactory("awscc_sagemaker_model_package", modelPackageResource)
}

// modelPackageResource returns the Terraform awscc_sagemaker_model_package resource.
// This Terraform resource corresponds to the CloudFormation AWS::SageMaker::ModelPackage resource.
func modelPackageResource(ctx context.Context) (resource.Resource, error) {
	attributes := map[string]schema.Attribute{ /*START SCHEMA*/
		// Property: AdditionalInferenceSpecifications
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "An array of additional Inference Specification objects.",
		//	  "insertionOrder": true,
		//	  "items": {
		//	    "additionalProperties": false,
		//	    "description": "Additional Inference Specification specifies details about inference jobs that can be run with models based on this model package.AdditionalInferenceSpecifications can be added to existing model packages using AdditionalInferenceSpecificationsToAdd.",
		//	    "properties": {
		//	      "Containers": {
		//	        "description": "The Amazon ECR registry path of the Docker image that contains the inference code.",
		//	        "insertionOrder": true,
		//	        "items": {
		//	          "additionalProperties": false,
		//	          "description": "Describes the Docker container for the model package.",
		//	          "properties": {
		//	            "ContainerHostname": {
		//	              "description": "The DNS host name for the Docker container.",
		//	              "maxLength": 63,
		//	              "pattern": "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}",
		//	              "type": "string"
		//	            },
		//	            "Environment": {
		//	              "additionalProperties": false,
		//	              "description": "Sets the environment variables in the Docker container",
		//	              "patternProperties": {
		//	                "": {
		//	                  "maxLength": 1024,
		//	                  "type": "string"
		//	                },
		//	                "[\\S\\s]*": {
		//	                  "maxLength": 1024,
		//	                  "type": "string"
		//	                }
		//	              },
		//	              "type": "object"
		//	            },
		//	            "Framework": {
		//	              "description": "The machine learning framework of the model package container image.",
		//	              "type": "string"
		//	            },
		//	            "FrameworkVersion": {
		//	              "description": "The framework version of the Model Package Container Image.",
		//	              "maxLength": 10,
		//	              "minLength": 3,
		//	              "pattern": "[0-9]\\.[A-Za-z0-9.]+",
		//	              "type": "string"
		//	            },
		//	            "Image": {
		//	              "description": "The Amazon EC2 Container Registry (Amazon ECR) path where inference code is stored.",
		//	              "maxLength": 255,
		//	              "minLength": 1,
		//	              "pattern": "[\\S]{1,255}",
		//	              "type": "string"
		//	            },
		//	            "ImageDigest": {
		//	              "description": "An MD5 hash of the training algorithm that identifies the Docker image used for training.",
		//	              "maxLength": 72,
		//	              "pattern": "^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$",
		//	              "type": "string"
		//	            },
		//	            "ModelDataUrl": {
		//	              "description": "A structure with Model Input details.",
		//	              "maxLength": 1024,
		//	              "pattern": "^(https|s3)://([^/]+)/?(.*)$",
		//	              "type": "string"
		//	            },
		//	            "ModelInput": {
		//	              "additionalProperties": false,
		//	              "properties": {
		//	                "DataInputConfig": {
		//	                  "description": "The input configuration object for the model.",
		//	                  "maxLength": 1024,
		//	                  "minLength": 1,
		//	                  "pattern": "[\\S\\s]+",
		//	                  "type": "string"
		//	                }
		//	              },
		//	              "required": [
		//	                "DataInputConfig"
		//	              ],
		//	              "type": "object"
		//	            },
		//	            "NearestModelName": {
		//	              "description": "The name of a pre-trained machine learning benchmarked by Amazon SageMaker Inference Recommender model that matches your model.",
		//	              "type": "string"
		//	            }
		//	          },
		//	          "required": [
		//	            "Image"
		//	          ],
		//	          "type": "object"
		//	        },
		//	        "maxItems": 15,
		//	        "minItems": 1,
		//	        "type": "array"
		//	      },
		//	      "Description": {
		//	        "description": "A description of the additional Inference specification.",
		//	        "maxLength": 1024,
		//	        "pattern": ".*",
		//	        "type": "string"
		//	      },
		//	      "Name": {
		//	        "description": "A unique name to identify the additional inference specification. The name must be unique within the list of your additional inference specifications for a particular model package.",
		//	        "maxLength": 63,
		//	        "minLength": 1,
		//	        "pattern": "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$",
		//	        "type": "string"
		//	      },
		//	      "SupportedContentTypes": {
		//	        "description": "The supported MIME types for the input data.",
		//	        "insertionOrder": true,
		//	        "items": {
		//	          "description": "The supported MIME type for the input data.",
		//	          "maxLength": 256,
		//	          "pattern": ".*",
		//	          "type": "string"
		//	        },
		//	        "type": "array"
		//	      },
		//	      "SupportedRealtimeInferenceInstanceTypes": {
		//	        "description": "A list of the instance types that are used to generate inferences in real-time",
		//	        "insertionOrder": true,
		//	        "items": {
		//	          "description": "Instance type that is used to generate inferences in real-time",
		//	          "type": "string"
		//	        },
		//	        "type": "array"
		//	      },
		//	      "SupportedResponseMIMETypes": {
		//	        "description": "The supported MIME types for the output data.",
		//	        "insertionOrder": true,
		//	        "items": {
		//	          "description": "The supported MIME types for the output data.",
		//	          "maxLength": 1024,
		//	          "pattern": "^[-\\w]+\\/.+$",
		//	          "type": "string"
		//	        },
		//	        "type": "array"
		//	      },
		//	      "SupportedTransformInstanceTypes": {
		//	        "description": "A list of the instance types on which a transformation job can be run or on which an endpoint can be deployed.",
		//	        "insertionOrder": true,
		//	        "items": {
		//	          "description": "Instance types on which a transformation job can be run or on which an endpoint can be deployed.",
		//	          "type": "string"
		//	        },
		//	        "minItems": 1,
		//	        "type": "array"
		//	      }
		//	    },
		//	    "required": [
		//	      "Containers",
		//	      "Name"
		//	    ],
		//	    "type": "object"
		//	  },
		//	  "maxItems": 15,
		//	  "minItems": 1,
		//	  "type": "array"
		//	}
		"additional_inference_specifications": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: Containers
					"containers": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
						NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: ContainerHostname
								"container_hostname": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The DNS host name for the Docker container.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(63),
										stringvalidator.RegexMatches(regexp.MustCompile("^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}"), ""),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: Environment
								"environment":       // Pattern: ""
								schema.MapAttribute{ /*START ATTRIBUTE*/
									ElementType: types.StringType,
									// Pattern "[\\S\\s]*" ignored.
									Description: "Sets the environment variables in the Docker container",
									Optional:    true,
									Computed:    true,
									PlanModifiers: []planmodifier.Map{ /*START PLAN MODIFIERS*/
										mapplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: Framework
								"framework": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The machine learning framework of the model package container image.",
									Optional:    true,
									Computed:    true,
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: FrameworkVersion
								"framework_version": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The framework version of the Model Package Container Image.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthBetween(3, 10),
										stringvalidator.RegexMatches(regexp.MustCompile("[0-9]\\.[A-Za-z0-9.]+"), ""),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: Image
								"image": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The Amazon EC2 Container Registry (Amazon ECR) path where inference code is stored.",
									Required:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthBetween(1, 255),
										stringvalidator.RegexMatches(regexp.MustCompile("[\\S]{1,255}"), ""),
									}, /*END VALIDATORS*/
								}, /*END ATTRIBUTE*/
								// Property: ImageDigest
								"image_digest": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "An MD5 hash of the training algorithm that identifies the Docker image used for training.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(72),
										stringvalidator.RegexMatches(regexp.MustCompile("^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$"), ""),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: ModelDataUrl
								"model_data_url": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "A structure with Model Input details.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(1024),
										stringvalidator.RegexMatches(regexp.MustCompile("^(https|s3)://([^/]+)/?(.*)$"), ""),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: ModelInput
								"model_input": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
									Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
										// Property: DataInputConfig
										"data_input_config": schema.StringAttribute{ /*START ATTRIBUTE*/
											Description: "The input configuration object for the model.",
											Required:    true,
											Validators: []validator.String{ /*START VALIDATORS*/
												stringvalidator.LengthBetween(1, 1024),
												stringvalidator.RegexMatches(regexp.MustCompile("[\\S\\s]+"), ""),
											}, /*END VALIDATORS*/
										}, /*END ATTRIBUTE*/
									}, /*END SCHEMA*/
									Optional: true,
									Computed: true,
									PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
										objectplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: NearestModelName
								"nearest_model_name": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The name of a pre-trained machine learning benchmarked by Amazon SageMaker Inference Recommender model that matches your model.",
									Optional:    true,
									Computed:    true,
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
						}, /*END NESTED OBJECT*/
						Description: "The Amazon ECR registry path of the Docker image that contains the inference code.",
						Required:    true,
						Validators: []validator.List{ /*START VALIDATORS*/
							listvalidator.SizeBetween(1, 15),
						}, /*END VALIDATORS*/
					}, /*END ATTRIBUTE*/
					// Property: Description
					"description": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "A description of the additional Inference specification.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.LengthAtMost(1024),
							stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: Name
					"name": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "A unique name to identify the additional inference specification. The name must be unique within the list of your additional inference specifications for a particular model package.",
						Required:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.LengthBetween(1, 63),
							stringvalidator.RegexMatches(regexp.MustCompile("^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$"), ""),
						}, /*END VALIDATORS*/
					}, /*END ATTRIBUTE*/
					// Property: SupportedContentTypes
					"supported_content_types": schema.ListAttribute{ /*START ATTRIBUTE*/
						ElementType: types.StringType,
						Description: "The supported MIME types for the input data.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.List{ /*START VALIDATORS*/
							listvalidator.ValueStringsAre(
								stringvalidator.LengthAtMost(256),
								stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
							),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
							listplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: SupportedRealtimeInferenceInstanceTypes
					"supported_realtime_inference_instance_types": schema.ListAttribute{ /*START ATTRIBUTE*/
						ElementType: types.StringType,
						Description: "A list of the instance types that are used to generate inferences in real-time",
						Optional:    true,
						Computed:    true,
						PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
							listplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: SupportedResponseMIMETypes
					"supported_response_mime_types": schema.ListAttribute{ /*START ATTRIBUTE*/
						ElementType: types.StringType,
						Description: "The supported MIME types for the output data.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.List{ /*START VALIDATORS*/
							listvalidator.ValueStringsAre(
								stringvalidator.LengthAtMost(1024),
								stringvalidator.RegexMatches(regexp.MustCompile("^[-\\w]+\\/.+$"), ""),
							),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
							listplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: SupportedTransformInstanceTypes
					"supported_transform_instance_types": schema.ListAttribute{ /*START ATTRIBUTE*/
						ElementType: types.StringType,
						Description: "A list of the instance types on which a transformation job can be run or on which an endpoint can be deployed.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.List{ /*START VALIDATORS*/
							listvalidator.SizeAtLeast(1),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
							listplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Description: "An array of additional Inference Specification objects.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.List{ /*START VALIDATORS*/
				listvalidator.SizeBetween(1, 15),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
				listplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: AdditionalInferenceSpecificationsToAdd
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "An array of additional Inference Specification objects.",
		//	  "insertionOrder": true,
		//	  "items": {
		//	    "additionalProperties": false,
		//	    "description": "Additional Inference Specification specifies details about inference jobs that can be run with models based on this model package.AdditionalInferenceSpecifications can be added to existing model packages using AdditionalInferenceSpecificationsToAdd.",
		//	    "properties": {
		//	      "Containers": {
		//	        "description": "The Amazon ECR registry path of the Docker image that contains the inference code.",
		//	        "insertionOrder": true,
		//	        "items": {
		//	          "additionalProperties": false,
		//	          "description": "Describes the Docker container for the model package.",
		//	          "properties": {
		//	            "ContainerHostname": {
		//	              "description": "The DNS host name for the Docker container.",
		//	              "maxLength": 63,
		//	              "pattern": "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}",
		//	              "type": "string"
		//	            },
		//	            "Environment": {
		//	              "additionalProperties": false,
		//	              "description": "Sets the environment variables in the Docker container",
		//	              "patternProperties": {
		//	                "": {
		//	                  "maxLength": 1024,
		//	                  "type": "string"
		//	                },
		//	                "[\\S\\s]*": {
		//	                  "maxLength": 1024,
		//	                  "type": "string"
		//	                }
		//	              },
		//	              "type": "object"
		//	            },
		//	            "Framework": {
		//	              "description": "The machine learning framework of the model package container image.",
		//	              "type": "string"
		//	            },
		//	            "FrameworkVersion": {
		//	              "description": "The framework version of the Model Package Container Image.",
		//	              "maxLength": 10,
		//	              "minLength": 3,
		//	              "pattern": "[0-9]\\.[A-Za-z0-9.]+",
		//	              "type": "string"
		//	            },
		//	            "Image": {
		//	              "description": "The Amazon EC2 Container Registry (Amazon ECR) path where inference code is stored.",
		//	              "maxLength": 255,
		//	              "minLength": 1,
		//	              "pattern": "[\\S]{1,255}",
		//	              "type": "string"
		//	            },
		//	            "ImageDigest": {
		//	              "description": "An MD5 hash of the training algorithm that identifies the Docker image used for training.",
		//	              "maxLength": 72,
		//	              "pattern": "^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$",
		//	              "type": "string"
		//	            },
		//	            "ModelDataUrl": {
		//	              "description": "A structure with Model Input details.",
		//	              "maxLength": 1024,
		//	              "pattern": "^(https|s3)://([^/]+)/?(.*)$",
		//	              "type": "string"
		//	            },
		//	            "ModelInput": {
		//	              "additionalProperties": false,
		//	              "properties": {
		//	                "DataInputConfig": {
		//	                  "description": "The input configuration object for the model.",
		//	                  "maxLength": 1024,
		//	                  "minLength": 1,
		//	                  "pattern": "[\\S\\s]+",
		//	                  "type": "string"
		//	                }
		//	              },
		//	              "required": [
		//	                "DataInputConfig"
		//	              ],
		//	              "type": "object"
		//	            },
		//	            "NearestModelName": {
		//	              "description": "The name of a pre-trained machine learning benchmarked by Amazon SageMaker Inference Recommender model that matches your model.",
		//	              "type": "string"
		//	            }
		//	          },
		//	          "required": [
		//	            "Image"
		//	          ],
		//	          "type": "object"
		//	        },
		//	        "maxItems": 15,
		//	        "minItems": 1,
		//	        "type": "array"
		//	      },
		//	      "Description": {
		//	        "description": "A description of the additional Inference specification.",
		//	        "maxLength": 1024,
		//	        "pattern": ".*",
		//	        "type": "string"
		//	      },
		//	      "Name": {
		//	        "description": "A unique name to identify the additional inference specification. The name must be unique within the list of your additional inference specifications for a particular model package.",
		//	        "maxLength": 63,
		//	        "minLength": 1,
		//	        "pattern": "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$",
		//	        "type": "string"
		//	      },
		//	      "SupportedContentTypes": {
		//	        "description": "The supported MIME types for the input data.",
		//	        "insertionOrder": true,
		//	        "items": {
		//	          "description": "The supported MIME type for the input data.",
		//	          "maxLength": 256,
		//	          "pattern": ".*",
		//	          "type": "string"
		//	        },
		//	        "type": "array"
		//	      },
		//	      "SupportedRealtimeInferenceInstanceTypes": {
		//	        "description": "A list of the instance types that are used to generate inferences in real-time",
		//	        "insertionOrder": true,
		//	        "items": {
		//	          "description": "Instance type that is used to generate inferences in real-time",
		//	          "type": "string"
		//	        },
		//	        "type": "array"
		//	      },
		//	      "SupportedResponseMIMETypes": {
		//	        "description": "The supported MIME types for the output data.",
		//	        "insertionOrder": true,
		//	        "items": {
		//	          "description": "The supported MIME types for the output data.",
		//	          "maxLength": 1024,
		//	          "pattern": "^[-\\w]+\\/.+$",
		//	          "type": "string"
		//	        },
		//	        "type": "array"
		//	      },
		//	      "SupportedTransformInstanceTypes": {
		//	        "description": "A list of the instance types on which a transformation job can be run or on which an endpoint can be deployed.",
		//	        "insertionOrder": true,
		//	        "items": {
		//	          "description": "Instance types on which a transformation job can be run or on which an endpoint can be deployed.",
		//	          "type": "string"
		//	        },
		//	        "minItems": 1,
		//	        "type": "array"
		//	      }
		//	    },
		//	    "required": [
		//	      "Containers",
		//	      "Name"
		//	    ],
		//	    "type": "object"
		//	  },
		//	  "maxItems": 15,
		//	  "minItems": 1,
		//	  "type": "array"
		//	}
		"additional_inference_specifications_to_add": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: Containers
					"containers": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
						NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: ContainerHostname
								"container_hostname": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The DNS host name for the Docker container.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(63),
										stringvalidator.RegexMatches(regexp.MustCompile("^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}"), ""),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: Environment
								"environment":       // Pattern: ""
								schema.MapAttribute{ /*START ATTRIBUTE*/
									ElementType: types.StringType,
									// Pattern "[\\S\\s]*" ignored.
									Description: "Sets the environment variables in the Docker container",
									Optional:    true,
									Computed:    true,
									PlanModifiers: []planmodifier.Map{ /*START PLAN MODIFIERS*/
										mapplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: Framework
								"framework": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The machine learning framework of the model package container image.",
									Optional:    true,
									Computed:    true,
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: FrameworkVersion
								"framework_version": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The framework version of the Model Package Container Image.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthBetween(3, 10),
										stringvalidator.RegexMatches(regexp.MustCompile("[0-9]\\.[A-Za-z0-9.]+"), ""),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: Image
								"image": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The Amazon EC2 Container Registry (Amazon ECR) path where inference code is stored.",
									Required:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthBetween(1, 255),
										stringvalidator.RegexMatches(regexp.MustCompile("[\\S]{1,255}"), ""),
									}, /*END VALIDATORS*/
								}, /*END ATTRIBUTE*/
								// Property: ImageDigest
								"image_digest": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "An MD5 hash of the training algorithm that identifies the Docker image used for training.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(72),
										stringvalidator.RegexMatches(regexp.MustCompile("^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$"), ""),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: ModelDataUrl
								"model_data_url": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "A structure with Model Input details.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(1024),
										stringvalidator.RegexMatches(regexp.MustCompile("^(https|s3)://([^/]+)/?(.*)$"), ""),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: ModelInput
								"model_input": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
									Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
										// Property: DataInputConfig
										"data_input_config": schema.StringAttribute{ /*START ATTRIBUTE*/
											Description: "The input configuration object for the model.",
											Required:    true,
											Validators: []validator.String{ /*START VALIDATORS*/
												stringvalidator.LengthBetween(1, 1024),
												stringvalidator.RegexMatches(regexp.MustCompile("[\\S\\s]+"), ""),
											}, /*END VALIDATORS*/
										}, /*END ATTRIBUTE*/
									}, /*END SCHEMA*/
									Optional: true,
									Computed: true,
									PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
										objectplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: NearestModelName
								"nearest_model_name": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The name of a pre-trained machine learning benchmarked by Amazon SageMaker Inference Recommender model that matches your model.",
									Optional:    true,
									Computed:    true,
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
						}, /*END NESTED OBJECT*/
						Description: "The Amazon ECR registry path of the Docker image that contains the inference code.",
						Required:    true,
						Validators: []validator.List{ /*START VALIDATORS*/
							listvalidator.SizeBetween(1, 15),
						}, /*END VALIDATORS*/
					}, /*END ATTRIBUTE*/
					// Property: Description
					"description": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "A description of the additional Inference specification.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.LengthAtMost(1024),
							stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: Name
					"name": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "A unique name to identify the additional inference specification. The name must be unique within the list of your additional inference specifications for a particular model package.",
						Required:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.LengthBetween(1, 63),
							stringvalidator.RegexMatches(regexp.MustCompile("^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$"), ""),
						}, /*END VALIDATORS*/
					}, /*END ATTRIBUTE*/
					// Property: SupportedContentTypes
					"supported_content_types": schema.ListAttribute{ /*START ATTRIBUTE*/
						ElementType: types.StringType,
						Description: "The supported MIME types for the input data.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.List{ /*START VALIDATORS*/
							listvalidator.ValueStringsAre(
								stringvalidator.LengthAtMost(256),
								stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
							),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
							listplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: SupportedRealtimeInferenceInstanceTypes
					"supported_realtime_inference_instance_types": schema.ListAttribute{ /*START ATTRIBUTE*/
						ElementType: types.StringType,
						Description: "A list of the instance types that are used to generate inferences in real-time",
						Optional:    true,
						Computed:    true,
						PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
							listplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: SupportedResponseMIMETypes
					"supported_response_mime_types": schema.ListAttribute{ /*START ATTRIBUTE*/
						ElementType: types.StringType,
						Description: "The supported MIME types for the output data.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.List{ /*START VALIDATORS*/
							listvalidator.ValueStringsAre(
								stringvalidator.LengthAtMost(1024),
								stringvalidator.RegexMatches(regexp.MustCompile("^[-\\w]+\\/.+$"), ""),
							),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
							listplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: SupportedTransformInstanceTypes
					"supported_transform_instance_types": schema.ListAttribute{ /*START ATTRIBUTE*/
						ElementType: types.StringType,
						Description: "A list of the instance types on which a transformation job can be run or on which an endpoint can be deployed.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.List{ /*START VALIDATORS*/
							listvalidator.SizeAtLeast(1),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
							listplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Description: "An array of additional Inference Specification objects.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.List{ /*START VALIDATORS*/
				listvalidator.SizeBetween(1, 15),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
				listplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
			// AdditionalInferenceSpecificationsToAdd is a write-only property.
		}, /*END ATTRIBUTE*/
		// Property: ApprovalDescription
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A description provided for the model approval.",
		//	  "maxLength": 1024,
		//	  "pattern": ".*",
		//	  "type": "string"
		//	}
		"approval_description": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "A description provided for the model approval.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.LengthAtMost(1024),
				stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: CertifyForMarketplace
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "Whether to certify the model package for listing on AWS Marketplace.",
		//	  "type": "boolean"
		//	}
		"certify_for_marketplace": schema.BoolAttribute{ /*START ATTRIBUTE*/
			Description: "Whether to certify the model package for listing on AWS Marketplace.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Bool{ /*START PLAN MODIFIERS*/
				boolplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: ClientToken
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A unique token that guarantees that the call to this API is idempotent.",
		//	  "maxLength": 36,
		//	  "minLength": 1,
		//	  "pattern": "^[a-zA-Z0-9-]+$",
		//	  "type": "string"
		//	}
		"client_token": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "A unique token that guarantees that the call to this API is idempotent.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.LengthBetween(1, 36),
				stringvalidator.RegexMatches(regexp.MustCompile("^[a-zA-Z0-9-]+$"), ""),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
				stringplanmodifier.RequiresReplace(),
			}, /*END PLAN MODIFIERS*/
			// ClientToken is a write-only property.
		}, /*END ATTRIBUTE*/
		// Property: CreationTime
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The time at which the model package was created.",
		//	  "type": "string"
		//	}
		"creation_time": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The time at which the model package was created.",
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: CustomerMetadataProperties
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "The metadata properties associated with the model package versions.",
		//	  "patternProperties": {
		//	    "": {
		//	      "maxLength": 128,
		//	      "minLength": 1,
		//	      "type": "string"
		//	    },
		//	    "^([\\p{L}\\p{Z}\\p{N}_.:\\/=+\\-@]*)${1,256}": {
		//	      "maxLength": 256,
		//	      "minLength": 1,
		//	      "type": "string"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"customer_metadata_properties": // Pattern: ""
		schema.MapAttribute{            /*START ATTRIBUTE*/
			ElementType: types.StringType,
			// Pattern "^([\\p{L}\\p{Z}\\p{N}_.:\\/=+\\-@]*)${1,256}" ignored.
			Description: "The metadata properties associated with the model package versions.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Map{ /*START PLAN MODIFIERS*/
				mapplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Domain
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The machine learning domain of the model package you specified.",
		//	  "type": "string"
		//	}
		"domain": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The machine learning domain of the model package you specified.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
				stringplanmodifier.RequiresReplace(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: DriftCheckBaselines
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "Represents the drift check baselines that can be used when the model monitor is set using the model package.",
		//	  "properties": {
		//	    "Bias": {
		//	      "additionalProperties": false,
		//	      "description": "Represents the drift check bias baselines that can be used when the model monitor is set using the model package.",
		//	      "properties": {
		//	        "ConfigFile": {
		//	          "additionalProperties": false,
		//	          "description": "Represents a File Source Object.",
		//	          "properties": {
		//	            "ContentDigest": {
		//	              "description": "The digest of the file source.",
		//	              "maxLength": 72,
		//	              "pattern": "^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$",
		//	              "type": "string"
		//	            },
		//	            "ContentType": {
		//	              "description": "The type of content stored in the file source.",
		//	              "maxLength": 256,
		//	              "pattern": ".*",
		//	              "type": "string"
		//	            },
		//	            "S3Uri": {
		//	              "description": "The Amazon S3 URI for the file source.",
		//	              "maxLength": 1024,
		//	              "pattern": "^(https|s3)://([^/]+)/?(.*)$",
		//	              "type": "string"
		//	            }
		//	          },
		//	          "required": [
		//	            "S3Uri"
		//	          ],
		//	          "type": "object"
		//	        },
		//	        "PostTrainingConstraints": {
		//	          "additionalProperties": false,
		//	          "description": "Represents a Metric Source Object.",
		//	          "properties": {
		//	            "ContentDigest": {
		//	              "description": "The digest of the metric source.",
		//	              "maxLength": 72,
		//	              "pattern": "^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$",
		//	              "type": "string"
		//	            },
		//	            "ContentType": {
		//	              "description": "The type of content stored in the metric source.",
		//	              "maxLength": 256,
		//	              "pattern": ".*",
		//	              "type": "string"
		//	            },
		//	            "S3Uri": {
		//	              "description": "The Amazon S3 URI for the metric source.",
		//	              "maxLength": 1024,
		//	              "pattern": "^(https|s3)://([^/]+)/?(.*)$",
		//	              "type": "string"
		//	            }
		//	          },
		//	          "required": [
		//	            "ContentType",
		//	            "S3Uri"
		//	          ],
		//	          "type": "object"
		//	        },
		//	        "PreTrainingConstraints": {
		//	          "additionalProperties": false,
		//	          "description": "Represents a Metric Source Object.",
		//	          "properties": {
		//	            "ContentDigest": {
		//	              "description": "The digest of the metric source.",
		//	              "maxLength": 72,
		//	              "pattern": "^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$",
		//	              "type": "string"
		//	            },
		//	            "ContentType": {
		//	              "description": "The type of content stored in the metric source.",
		//	              "maxLength": 256,
		//	              "pattern": ".*",
		//	              "type": "string"
		//	            },
		//	            "S3Uri": {
		//	              "description": "The Amazon S3 URI for the metric source.",
		//	              "maxLength": 1024,
		//	              "pattern": "^(https|s3)://([^/]+)/?(.*)$",
		//	              "type": "string"
		//	            }
		//	          },
		//	          "required": [
		//	            "ContentType",
		//	            "S3Uri"
		//	          ],
		//	          "type": "object"
		//	        }
		//	      },
		//	      "type": "object"
		//	    },
		//	    "Explainability": {
		//	      "additionalProperties": false,
		//	      "description": "Contains explainability metrics for a model.",
		//	      "properties": {
		//	        "ConfigFile": {
		//	          "additionalProperties": false,
		//	          "description": "Represents a File Source Object.",
		//	          "properties": {
		//	            "ContentDigest": {
		//	              "description": "The digest of the file source.",
		//	              "maxLength": 72,
		//	              "pattern": "^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$",
		//	              "type": "string"
		//	            },
		//	            "ContentType": {
		//	              "description": "The type of content stored in the file source.",
		//	              "maxLength": 256,
		//	              "pattern": ".*",
		//	              "type": "string"
		//	            },
		//	            "S3Uri": {
		//	              "description": "The Amazon S3 URI for the file source.",
		//	              "maxLength": 1024,
		//	              "pattern": "^(https|s3)://([^/]+)/?(.*)$",
		//	              "type": "string"
		//	            }
		//	          },
		//	          "required": [
		//	            "S3Uri"
		//	          ],
		//	          "type": "object"
		//	        },
		//	        "Constraints": {
		//	          "additionalProperties": false,
		//	          "description": "Represents a Metric Source Object.",
		//	          "properties": {
		//	            "ContentDigest": {
		//	              "description": "The digest of the metric source.",
		//	              "maxLength": 72,
		//	              "pattern": "^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$",
		//	              "type": "string"
		//	            },
		//	            "ContentType": {
		//	              "description": "The type of content stored in the metric source.",
		//	              "maxLength": 256,
		//	              "pattern": ".*",
		//	              "type": "string"
		//	            },
		//	            "S3Uri": {
		//	              "description": "The Amazon S3 URI for the metric source.",
		//	              "maxLength": 1024,
		//	              "pattern": "^(https|s3)://([^/]+)/?(.*)$",
		//	              "type": "string"
		//	            }
		//	          },
		//	          "required": [
		//	            "ContentType",
		//	            "S3Uri"
		//	          ],
		//	          "type": "object"
		//	        }
		//	      },
		//	      "type": "object"
		//	    },
		//	    "ModelDataQuality": {
		//	      "additionalProperties": false,
		//	      "description": "Represents the drift check data quality baselines that can be used when the model monitor is set using the model package.",
		//	      "properties": {
		//	        "Constraints": {
		//	          "additionalProperties": false,
		//	          "description": "Represents a Metric Source Object.",
		//	          "properties": {
		//	            "ContentDigest": {
		//	              "description": "The digest of the metric source.",
		//	              "maxLength": 72,
		//	              "pattern": "^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$",
		//	              "type": "string"
		//	            },
		//	            "ContentType": {
		//	              "description": "The type of content stored in the metric source.",
		//	              "maxLength": 256,
		//	              "pattern": ".*",
		//	              "type": "string"
		//	            },
		//	            "S3Uri": {
		//	              "description": "The Amazon S3 URI for the metric source.",
		//	              "maxLength": 1024,
		//	              "pattern": "^(https|s3)://([^/]+)/?(.*)$",
		//	              "type": "string"
		//	            }
		//	          },
		//	          "required": [
		//	            "ContentType",
		//	            "S3Uri"
		//	          ],
		//	          "type": "object"
		//	        },
		//	        "Statistics": {
		//	          "additionalProperties": false,
		//	          "description": "Represents a Metric Source Object.",
		//	          "properties": {
		//	            "ContentDigest": {
		//	              "description": "The digest of the metric source.",
		//	              "maxLength": 72,
		//	              "pattern": "^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$",
		//	              "type": "string"
		//	            },
		//	            "ContentType": {
		//	              "description": "The type of content stored in the metric source.",
		//	              "maxLength": 256,
		//	              "pattern": ".*",
		//	              "type": "string"
		//	            },
		//	            "S3Uri": {
		//	              "description": "The Amazon S3 URI for the metric source.",
		//	              "maxLength": 1024,
		//	              "pattern": "^(https|s3)://([^/]+)/?(.*)$",
		//	              "type": "string"
		//	            }
		//	          },
		//	          "required": [
		//	            "ContentType",
		//	            "S3Uri"
		//	          ],
		//	          "type": "object"
		//	        }
		//	      },
		//	      "type": "object"
		//	    },
		//	    "ModelQuality": {
		//	      "additionalProperties": false,
		//	      "description": "Represents the drift check model quality baselines that can be used when the model monitor is set using the model package.",
		//	      "properties": {
		//	        "Constraints": {
		//	          "additionalProperties": false,
		//	          "description": "Represents a Metric Source Object.",
		//	          "properties": {
		//	            "ContentDigest": {
		//	              "description": "The digest of the metric source.",
		//	              "maxLength": 72,
		//	              "pattern": "^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$",
		//	              "type": "string"
		//	            },
		//	            "ContentType": {
		//	              "description": "The type of content stored in the metric source.",
		//	              "maxLength": 256,
		//	              "pattern": ".*",
		//	              "type": "string"
		//	            },
		//	            "S3Uri": {
		//	              "description": "The Amazon S3 URI for the metric source.",
		//	              "maxLength": 1024,
		//	              "pattern": "^(https|s3)://([^/]+)/?(.*)$",
		//	              "type": "string"
		//	            }
		//	          },
		//	          "required": [
		//	            "ContentType",
		//	            "S3Uri"
		//	          ],
		//	          "type": "object"
		//	        },
		//	        "Statistics": {
		//	          "additionalProperties": false,
		//	          "description": "Represents a Metric Source Object.",
		//	          "properties": {
		//	            "ContentDigest": {
		//	              "description": "The digest of the metric source.",
		//	              "maxLength": 72,
		//	              "pattern": "^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$",
		//	              "type": "string"
		//	            },
		//	            "ContentType": {
		//	              "description": "The type of content stored in the metric source.",
		//	              "maxLength": 256,
		//	              "pattern": ".*",
		//	              "type": "string"
		//	            },
		//	            "S3Uri": {
		//	              "description": "The Amazon S3 URI for the metric source.",
		//	              "maxLength": 1024,
		//	              "pattern": "^(https|s3)://([^/]+)/?(.*)$",
		//	              "type": "string"
		//	            }
		//	          },
		//	          "required": [
		//	            "ContentType",
		//	            "S3Uri"
		//	          ],
		//	          "type": "object"
		//	        }
		//	      },
		//	      "type": "object"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"drift_check_baselines": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: Bias
				"bias": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
					Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
						// Property: ConfigFile
						"config_file": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: ContentDigest
								"content_digest": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The digest of the file source.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(72),
										stringvalidator.RegexMatches(regexp.MustCompile("^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$"), ""),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: ContentType
								"content_type": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The type of content stored in the file source.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(256),
										stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: S3Uri
								"s3_uri": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The Amazon S3 URI for the file source.",
									Required:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(1024),
										stringvalidator.RegexMatches(regexp.MustCompile("^(https|s3)://([^/]+)/?(.*)$"), ""),
									}, /*END VALIDATORS*/
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
							Description: "Represents a File Source Object.",
							Optional:    true,
							Computed:    true,
							PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
								objectplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
						// Property: PostTrainingConstraints
						"post_training_constraints": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: ContentDigest
								"content_digest": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The digest of the metric source.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(72),
										stringvalidator.RegexMatches(regexp.MustCompile("^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$"), ""),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: ContentType
								"content_type": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The type of content stored in the metric source.",
									Required:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(256),
										stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
									}, /*END VALIDATORS*/
								}, /*END ATTRIBUTE*/
								// Property: S3Uri
								"s3_uri": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The Amazon S3 URI for the metric source.",
									Required:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(1024),
										stringvalidator.RegexMatches(regexp.MustCompile("^(https|s3)://([^/]+)/?(.*)$"), ""),
									}, /*END VALIDATORS*/
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
							Description: "Represents a Metric Source Object.",
							Optional:    true,
							Computed:    true,
							PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
								objectplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
						// Property: PreTrainingConstraints
						"pre_training_constraints": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: ContentDigest
								"content_digest": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The digest of the metric source.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(72),
										stringvalidator.RegexMatches(regexp.MustCompile("^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$"), ""),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: ContentType
								"content_type": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The type of content stored in the metric source.",
									Required:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(256),
										stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
									}, /*END VALIDATORS*/
								}, /*END ATTRIBUTE*/
								// Property: S3Uri
								"s3_uri": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The Amazon S3 URI for the metric source.",
									Required:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(1024),
										stringvalidator.RegexMatches(regexp.MustCompile("^(https|s3)://([^/]+)/?(.*)$"), ""),
									}, /*END VALIDATORS*/
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
							Description: "Represents a Metric Source Object.",
							Optional:    true,
							Computed:    true,
							PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
								objectplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
					}, /*END SCHEMA*/
					Description: "Represents the drift check bias baselines that can be used when the model monitor is set using the model package.",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
						objectplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: Explainability
				"explainability": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
					Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
						// Property: ConfigFile
						"config_file": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: ContentDigest
								"content_digest": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The digest of the file source.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(72),
										stringvalidator.RegexMatches(regexp.MustCompile("^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$"), ""),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: ContentType
								"content_type": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The type of content stored in the file source.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(256),
										stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: S3Uri
								"s3_uri": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The Amazon S3 URI for the file source.",
									Required:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(1024),
										stringvalidator.RegexMatches(regexp.MustCompile("^(https|s3)://([^/]+)/?(.*)$"), ""),
									}, /*END VALIDATORS*/
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
							Description: "Represents a File Source Object.",
							Optional:    true,
							Computed:    true,
							PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
								objectplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
						// Property: Constraints
						"constraints": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: ContentDigest
								"content_digest": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The digest of the metric source.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(72),
										stringvalidator.RegexMatches(regexp.MustCompile("^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$"), ""),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: ContentType
								"content_type": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The type of content stored in the metric source.",
									Required:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(256),
										stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
									}, /*END VALIDATORS*/
								}, /*END ATTRIBUTE*/
								// Property: S3Uri
								"s3_uri": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The Amazon S3 URI for the metric source.",
									Required:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(1024),
										stringvalidator.RegexMatches(regexp.MustCompile("^(https|s3)://([^/]+)/?(.*)$"), ""),
									}, /*END VALIDATORS*/
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
							Description: "Represents a Metric Source Object.",
							Optional:    true,
							Computed:    true,
							PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
								objectplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
					}, /*END SCHEMA*/
					Description: "Contains explainability metrics for a model.",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
						objectplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: ModelDataQuality
				"model_data_quality": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
					Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
						// Property: Constraints
						"constraints": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: ContentDigest
								"content_digest": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The digest of the metric source.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(72),
										stringvalidator.RegexMatches(regexp.MustCompile("^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$"), ""),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: ContentType
								"content_type": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The type of content stored in the metric source.",
									Required:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(256),
										stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
									}, /*END VALIDATORS*/
								}, /*END ATTRIBUTE*/
								// Property: S3Uri
								"s3_uri": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The Amazon S3 URI for the metric source.",
									Required:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(1024),
										stringvalidator.RegexMatches(regexp.MustCompile("^(https|s3)://([^/]+)/?(.*)$"), ""),
									}, /*END VALIDATORS*/
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
							Description: "Represents a Metric Source Object.",
							Optional:    true,
							Computed:    true,
							PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
								objectplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
						// Property: Statistics
						"statistics": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: ContentDigest
								"content_digest": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The digest of the metric source.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(72),
										stringvalidator.RegexMatches(regexp.MustCompile("^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$"), ""),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: ContentType
								"content_type": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The type of content stored in the metric source.",
									Required:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(256),
										stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
									}, /*END VALIDATORS*/
								}, /*END ATTRIBUTE*/
								// Property: S3Uri
								"s3_uri": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The Amazon S3 URI for the metric source.",
									Required:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(1024),
										stringvalidator.RegexMatches(regexp.MustCompile("^(https|s3)://([^/]+)/?(.*)$"), ""),
									}, /*END VALIDATORS*/
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
							Description: "Represents a Metric Source Object.",
							Optional:    true,
							Computed:    true,
							PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
								objectplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
					}, /*END SCHEMA*/
					Description: "Represents the drift check data quality baselines that can be used when the model monitor is set using the model package.",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
						objectplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: ModelQuality
				"model_quality": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
					Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
						// Property: Constraints
						"constraints": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: ContentDigest
								"content_digest": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The digest of the metric source.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(72),
										stringvalidator.RegexMatches(regexp.MustCompile("^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$"), ""),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: ContentType
								"content_type": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The type of content stored in the metric source.",
									Required:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(256),
										stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
									}, /*END VALIDATORS*/
								}, /*END ATTRIBUTE*/
								// Property: S3Uri
								"s3_uri": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The Amazon S3 URI for the metric source.",
									Required:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(1024),
										stringvalidator.RegexMatches(regexp.MustCompile("^(https|s3)://([^/]+)/?(.*)$"), ""),
									}, /*END VALIDATORS*/
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
							Description: "Represents a Metric Source Object.",
							Optional:    true,
							Computed:    true,
							PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
								objectplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
						// Property: Statistics
						"statistics": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: ContentDigest
								"content_digest": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The digest of the metric source.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(72),
										stringvalidator.RegexMatches(regexp.MustCompile("^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$"), ""),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: ContentType
								"content_type": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The type of content stored in the metric source.",
									Required:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(256),
										stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
									}, /*END VALIDATORS*/
								}, /*END ATTRIBUTE*/
								// Property: S3Uri
								"s3_uri": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The Amazon S3 URI for the metric source.",
									Required:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(1024),
										stringvalidator.RegexMatches(regexp.MustCompile("^(https|s3)://([^/]+)/?(.*)$"), ""),
									}, /*END VALIDATORS*/
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
							Description: "Represents a Metric Source Object.",
							Optional:    true,
							Computed:    true,
							PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
								objectplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
					}, /*END SCHEMA*/
					Description: "Represents the drift check model quality baselines that can be used when the model monitor is set using the model package.",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
						objectplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "Represents the drift check baselines that can be used when the model monitor is set using the model package.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
				objectplanmodifier.RequiresReplace(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: InferenceSpecification
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "Details about inference jobs that can be run with models based on this model package.",
		//	  "properties": {
		//	    "Containers": {
		//	      "description": "The Amazon ECR registry path of the Docker image that contains the inference code.",
		//	      "insertionOrder": true,
		//	      "items": {
		//	        "additionalProperties": false,
		//	        "description": "Describes the Docker container for the model package.",
		//	        "properties": {
		//	          "ContainerHostname": {
		//	            "description": "The DNS host name for the Docker container.",
		//	            "maxLength": 63,
		//	            "pattern": "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}",
		//	            "type": "string"
		//	          },
		//	          "Environment": {
		//	            "additionalProperties": false,
		//	            "description": "Sets the environment variables in the Docker container",
		//	            "patternProperties": {
		//	              "": {
		//	                "maxLength": 1024,
		//	                "type": "string"
		//	              },
		//	              "[\\S\\s]*": {
		//	                "maxLength": 1024,
		//	                "type": "string"
		//	              }
		//	            },
		//	            "type": "object"
		//	          },
		//	          "Framework": {
		//	            "description": "The machine learning framework of the model package container image.",
		//	            "type": "string"
		//	          },
		//	          "FrameworkVersion": {
		//	            "description": "The framework version of the Model Package Container Image.",
		//	            "maxLength": 10,
		//	            "minLength": 3,
		//	            "pattern": "[0-9]\\.[A-Za-z0-9.]+",
		//	            "type": "string"
		//	          },
		//	          "Image": {
		//	            "description": "The Amazon EC2 Container Registry (Amazon ECR) path where inference code is stored.",
		//	            "maxLength": 255,
		//	            "minLength": 1,
		//	            "pattern": "[\\S]{1,255}",
		//	            "type": "string"
		//	          },
		//	          "ImageDigest": {
		//	            "description": "An MD5 hash of the training algorithm that identifies the Docker image used for training.",
		//	            "maxLength": 72,
		//	            "pattern": "^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$",
		//	            "type": "string"
		//	          },
		//	          "ModelDataUrl": {
		//	            "description": "A structure with Model Input details.",
		//	            "maxLength": 1024,
		//	            "pattern": "^(https|s3)://([^/]+)/?(.*)$",
		//	            "type": "string"
		//	          },
		//	          "ModelInput": {
		//	            "additionalProperties": false,
		//	            "properties": {
		//	              "DataInputConfig": {
		//	                "description": "The input configuration object for the model.",
		//	                "maxLength": 1024,
		//	                "minLength": 1,
		//	                "pattern": "[\\S\\s]+",
		//	                "type": "string"
		//	              }
		//	            },
		//	            "required": [
		//	              "DataInputConfig"
		//	            ],
		//	            "type": "object"
		//	          },
		//	          "NearestModelName": {
		//	            "description": "The name of a pre-trained machine learning benchmarked by Amazon SageMaker Inference Recommender model that matches your model.",
		//	            "type": "string"
		//	          }
		//	        },
		//	        "required": [
		//	          "Image"
		//	        ],
		//	        "type": "object"
		//	      },
		//	      "maxItems": 15,
		//	      "minItems": 1,
		//	      "type": "array",
		//	      "uniqueItems": true
		//	    },
		//	    "SupportedContentTypes": {
		//	      "description": "The supported MIME types for the input data.",
		//	      "insertionOrder": true,
		//	      "items": {
		//	        "description": "The supported MIME type for the input data.",
		//	        "maxLength": 256,
		//	        "pattern": ".*",
		//	        "type": "string"
		//	      },
		//	      "type": "array"
		//	    },
		//	    "SupportedRealtimeInferenceInstanceTypes": {
		//	      "description": "A list of the instance types that are used to generate inferences in real-time",
		//	      "insertionOrder": true,
		//	      "items": {
		//	        "description": "Instance type that is used to generate inferences in real-time",
		//	        "type": "string"
		//	      },
		//	      "type": "array"
		//	    },
		//	    "SupportedResponseMIMETypes": {
		//	      "description": "The supported MIME types for the output data.",
		//	      "insertionOrder": true,
		//	      "items": {
		//	        "description": "The supported MIME types for the output data.",
		//	        "maxLength": 1024,
		//	        "pattern": "^[-\\w]+\\/.+$",
		//	        "type": "string"
		//	      },
		//	      "type": "array"
		//	    },
		//	    "SupportedTransformInstanceTypes": {
		//	      "description": "A list of the instance types on which a transformation job can be run or on which an endpoint can be deployed.",
		//	      "insertionOrder": true,
		//	      "items": {
		//	        "description": "Instance types on which a transformation job can be run or on which an endpoint can be deployed.",
		//	        "type": "string"
		//	      },
		//	      "minItems": 1,
		//	      "type": "array"
		//	    }
		//	  },
		//	  "required": [
		//	    "Containers",
		//	    "SupportedContentTypes",
		//	    "SupportedResponseMIMETypes"
		//	  ],
		//	  "type": "object"
		//	}
		"inference_specification": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: Containers
				"containers": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
					NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: ContainerHostname
							"container_hostname": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "The DNS host name for the Docker container.",
								Optional:    true,
								Computed:    true,
								Validators: []validator.String{ /*START VALIDATORS*/
									stringvalidator.LengthAtMost(63),
									stringvalidator.RegexMatches(regexp.MustCompile("^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}"), ""),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
									stringplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: Environment
							"environment":       // Pattern: ""
							schema.MapAttribute{ /*START ATTRIBUTE*/
								ElementType: types.StringType,
								// Pattern "[\\S\\s]*" ignored.
								Description: "Sets the environment variables in the Docker container",
								Optional:    true,
								Computed:    true,
								PlanModifiers: []planmodifier.Map{ /*START PLAN MODIFIERS*/
									mapplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: Framework
							"framework": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "The machine learning framework of the model package container image.",
								Optional:    true,
								Computed:    true,
								PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
									stringplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: FrameworkVersion
							"framework_version": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "The framework version of the Model Package Container Image.",
								Optional:    true,
								Computed:    true,
								Validators: []validator.String{ /*START VALIDATORS*/
									stringvalidator.LengthBetween(3, 10),
									stringvalidator.RegexMatches(regexp.MustCompile("[0-9]\\.[A-Za-z0-9.]+"), ""),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
									stringplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: Image
							"image": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "The Amazon EC2 Container Registry (Amazon ECR) path where inference code is stored.",
								Required:    true,
								Validators: []validator.String{ /*START VALIDATORS*/
									stringvalidator.LengthBetween(1, 255),
									stringvalidator.RegexMatches(regexp.MustCompile("[\\S]{1,255}"), ""),
								}, /*END VALIDATORS*/
							}, /*END ATTRIBUTE*/
							// Property: ImageDigest
							"image_digest": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "An MD5 hash of the training algorithm that identifies the Docker image used for training.",
								Optional:    true,
								Computed:    true,
								Validators: []validator.String{ /*START VALIDATORS*/
									stringvalidator.LengthAtMost(72),
									stringvalidator.RegexMatches(regexp.MustCompile("^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$"), ""),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
									stringplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: ModelDataUrl
							"model_data_url": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "A structure with Model Input details.",
								Optional:    true,
								Computed:    true,
								Validators: []validator.String{ /*START VALIDATORS*/
									stringvalidator.LengthAtMost(1024),
									stringvalidator.RegexMatches(regexp.MustCompile("^(https|s3)://([^/]+)/?(.*)$"), ""),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
									stringplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: ModelInput
							"model_input": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
								Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
									// Property: DataInputConfig
									"data_input_config": schema.StringAttribute{ /*START ATTRIBUTE*/
										Description: "The input configuration object for the model.",
										Required:    true,
										Validators: []validator.String{ /*START VALIDATORS*/
											stringvalidator.LengthBetween(1, 1024),
											stringvalidator.RegexMatches(regexp.MustCompile("[\\S\\s]+"), ""),
										}, /*END VALIDATORS*/
									}, /*END ATTRIBUTE*/
								}, /*END SCHEMA*/
								Optional: true,
								Computed: true,
								PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
									objectplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: NearestModelName
							"nearest_model_name": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "The name of a pre-trained machine learning benchmarked by Amazon SageMaker Inference Recommender model that matches your model.",
								Optional:    true,
								Computed:    true,
								PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
									stringplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
					}, /*END NESTED OBJECT*/
					Description: "The Amazon ECR registry path of the Docker image that contains the inference code.",
					Required:    true,
					Validators: []validator.List{ /*START VALIDATORS*/
						listvalidator.SizeBetween(1, 15),
						listvalidator.UniqueValues(),
					}, /*END VALIDATORS*/
				}, /*END ATTRIBUTE*/
				// Property: SupportedContentTypes
				"supported_content_types": schema.ListAttribute{ /*START ATTRIBUTE*/
					ElementType: types.StringType,
					Description: "The supported MIME types for the input data.",
					Required:    true,
					Validators: []validator.List{ /*START VALIDATORS*/
						listvalidator.ValueStringsAre(
							stringvalidator.LengthAtMost(256),
							stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
						),
					}, /*END VALIDATORS*/
				}, /*END ATTRIBUTE*/
				// Property: SupportedRealtimeInferenceInstanceTypes
				"supported_realtime_inference_instance_types": schema.ListAttribute{ /*START ATTRIBUTE*/
					ElementType: types.StringType,
					Description: "A list of the instance types that are used to generate inferences in real-time",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
						listplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: SupportedResponseMIMETypes
				"supported_response_mime_types": schema.ListAttribute{ /*START ATTRIBUTE*/
					ElementType: types.StringType,
					Description: "The supported MIME types for the output data.",
					Required:    true,
					Validators: []validator.List{ /*START VALIDATORS*/
						listvalidator.ValueStringsAre(
							stringvalidator.LengthAtMost(1024),
							stringvalidator.RegexMatches(regexp.MustCompile("^[-\\w]+\\/.+$"), ""),
						),
					}, /*END VALIDATORS*/
				}, /*END ATTRIBUTE*/
				// Property: SupportedTransformInstanceTypes
				"supported_transform_instance_types": schema.ListAttribute{ /*START ATTRIBUTE*/
					ElementType: types.StringType,
					Description: "A list of the instance types on which a transformation job can be run or on which an endpoint can be deployed.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.List{ /*START VALIDATORS*/
						listvalidator.SizeAtLeast(1),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
						listplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "Details about inference jobs that can be run with models based on this model package.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
				objectplanmodifier.RequiresReplace(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: LastModifiedTime
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The time at which the model package was last modified.",
		//	  "type": "string"
		//	}
		"last_modified_time": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The time at which the model package was last modified.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: MetadataProperties
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "Metadata properties of the tracking entity, trial, or trial component.",
		//	  "properties": {
		//	    "CommitId": {
		//	      "description": "The commit ID.",
		//	      "maxLength": 1024,
		//	      "pattern": ".*",
		//	      "type": "string"
		//	    },
		//	    "GeneratedBy": {
		//	      "description": "The entity this entity was generated by.",
		//	      "maxLength": 1024,
		//	      "pattern": ".*",
		//	      "type": "string"
		//	    },
		//	    "ProjectId": {
		//	      "description": "The project ID metadata.",
		//	      "maxLength": 1024,
		//	      "pattern": ".*",
		//	      "type": "string"
		//	    },
		//	    "Repository": {
		//	      "description": "The repository metadata.",
		//	      "maxLength": 1024,
		//	      "pattern": ".*",
		//	      "type": "string"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"metadata_properties": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: CommitId
				"commit_id": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "The commit ID.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.String{ /*START VALIDATORS*/
						stringvalidator.LengthAtMost(1024),
						stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: GeneratedBy
				"generated_by": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "The entity this entity was generated by.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.String{ /*START VALIDATORS*/
						stringvalidator.LengthAtMost(1024),
						stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: ProjectId
				"project_id": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "The project ID metadata.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.String{ /*START VALIDATORS*/
						stringvalidator.LengthAtMost(1024),
						stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: Repository
				"repository": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "The repository metadata.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.String{ /*START VALIDATORS*/
						stringvalidator.LengthAtMost(1024),
						stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "Metadata properties of the tracking entity, trial, or trial component.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
				objectplanmodifier.RequiresReplace(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: ModelApprovalStatus
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The approval status of the model package.",
		//	  "enum": [
		//	    "Approved",
		//	    "Rejected",
		//	    "PendingManualApproval"
		//	  ],
		//	  "type": "string"
		//	}
		"model_approval_status": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The approval status of the model package.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.OneOf(
					"Approved",
					"Rejected",
					"PendingManualApproval",
				),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: ModelMetrics
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "A structure that contains model metrics reports.",
		//	  "properties": {
		//	    "Bias": {
		//	      "additionalProperties": false,
		//	      "description": "Contains bias metrics for a model.",
		//	      "properties": {
		//	        "PostTrainingReport": {
		//	          "additionalProperties": false,
		//	          "description": "Represents a Metric Source Object.",
		//	          "properties": {
		//	            "ContentDigest": {
		//	              "description": "The digest of the metric source.",
		//	              "maxLength": 72,
		//	              "pattern": "^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$",
		//	              "type": "string"
		//	            },
		//	            "ContentType": {
		//	              "description": "The type of content stored in the metric source.",
		//	              "maxLength": 256,
		//	              "pattern": ".*",
		//	              "type": "string"
		//	            },
		//	            "S3Uri": {
		//	              "description": "The Amazon S3 URI for the metric source.",
		//	              "maxLength": 1024,
		//	              "pattern": "^(https|s3)://([^/]+)/?(.*)$",
		//	              "type": "string"
		//	            }
		//	          },
		//	          "required": [
		//	            "ContentType",
		//	            "S3Uri"
		//	          ],
		//	          "type": "object"
		//	        },
		//	        "PreTrainingReport": {
		//	          "additionalProperties": false,
		//	          "description": "Represents a Metric Source Object.",
		//	          "properties": {
		//	            "ContentDigest": {
		//	              "description": "The digest of the metric source.",
		//	              "maxLength": 72,
		//	              "pattern": "^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$",
		//	              "type": "string"
		//	            },
		//	            "ContentType": {
		//	              "description": "The type of content stored in the metric source.",
		//	              "maxLength": 256,
		//	              "pattern": ".*",
		//	              "type": "string"
		//	            },
		//	            "S3Uri": {
		//	              "description": "The Amazon S3 URI for the metric source.",
		//	              "maxLength": 1024,
		//	              "pattern": "^(https|s3)://([^/]+)/?(.*)$",
		//	              "type": "string"
		//	            }
		//	          },
		//	          "required": [
		//	            "ContentType",
		//	            "S3Uri"
		//	          ],
		//	          "type": "object"
		//	        },
		//	        "Report": {
		//	          "additionalProperties": false,
		//	          "description": "Represents a Metric Source Object.",
		//	          "properties": {
		//	            "ContentDigest": {
		//	              "description": "The digest of the metric source.",
		//	              "maxLength": 72,
		//	              "pattern": "^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$",
		//	              "type": "string"
		//	            },
		//	            "ContentType": {
		//	              "description": "The type of content stored in the metric source.",
		//	              "maxLength": 256,
		//	              "pattern": ".*",
		//	              "type": "string"
		//	            },
		//	            "S3Uri": {
		//	              "description": "The Amazon S3 URI for the metric source.",
		//	              "maxLength": 1024,
		//	              "pattern": "^(https|s3)://([^/]+)/?(.*)$",
		//	              "type": "string"
		//	            }
		//	          },
		//	          "required": [
		//	            "ContentType",
		//	            "S3Uri"
		//	          ],
		//	          "type": "object"
		//	        }
		//	      },
		//	      "type": "object"
		//	    },
		//	    "Explainability": {
		//	      "additionalProperties": false,
		//	      "description": "Contains explainability metrics for a model.",
		//	      "properties": {
		//	        "Report": {
		//	          "additionalProperties": false,
		//	          "description": "Represents a Metric Source Object.",
		//	          "properties": {
		//	            "ContentDigest": {
		//	              "description": "The digest of the metric source.",
		//	              "maxLength": 72,
		//	              "pattern": "^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$",
		//	              "type": "string"
		//	            },
		//	            "ContentType": {
		//	              "description": "The type of content stored in the metric source.",
		//	              "maxLength": 256,
		//	              "pattern": ".*",
		//	              "type": "string"
		//	            },
		//	            "S3Uri": {
		//	              "description": "The Amazon S3 URI for the metric source.",
		//	              "maxLength": 1024,
		//	              "pattern": "^(https|s3)://([^/]+)/?(.*)$",
		//	              "type": "string"
		//	            }
		//	          },
		//	          "required": [
		//	            "ContentType",
		//	            "S3Uri"
		//	          ],
		//	          "type": "object"
		//	        }
		//	      },
		//	      "type": "object"
		//	    },
		//	    "ModelDataQuality": {
		//	      "additionalProperties": false,
		//	      "description": "Metrics that measure the quality of the input data for a model.",
		//	      "properties": {
		//	        "Constraints": {
		//	          "additionalProperties": false,
		//	          "description": "Represents a Metric Source Object.",
		//	          "properties": {
		//	            "ContentDigest": {
		//	              "description": "The digest of the metric source.",
		//	              "maxLength": 72,
		//	              "pattern": "^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$",
		//	              "type": "string"
		//	            },
		//	            "ContentType": {
		//	              "description": "The type of content stored in the metric source.",
		//	              "maxLength": 256,
		//	              "pattern": ".*",
		//	              "type": "string"
		//	            },
		//	            "S3Uri": {
		//	              "description": "The Amazon S3 URI for the metric source.",
		//	              "maxLength": 1024,
		//	              "pattern": "^(https|s3)://([^/]+)/?(.*)$",
		//	              "type": "string"
		//	            }
		//	          },
		//	          "required": [
		//	            "ContentType",
		//	            "S3Uri"
		//	          ],
		//	          "type": "object"
		//	        },
		//	        "Statistics": {
		//	          "additionalProperties": false,
		//	          "description": "Represents a Metric Source Object.",
		//	          "properties": {
		//	            "ContentDigest": {
		//	              "description": "The digest of the metric source.",
		//	              "maxLength": 72,
		//	              "pattern": "^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$",
		//	              "type": "string"
		//	            },
		//	            "ContentType": {
		//	              "description": "The type of content stored in the metric source.",
		//	              "maxLength": 256,
		//	              "pattern": ".*",
		//	              "type": "string"
		//	            },
		//	            "S3Uri": {
		//	              "description": "The Amazon S3 URI for the metric source.",
		//	              "maxLength": 1024,
		//	              "pattern": "^(https|s3)://([^/]+)/?(.*)$",
		//	              "type": "string"
		//	            }
		//	          },
		//	          "required": [
		//	            "ContentType",
		//	            "S3Uri"
		//	          ],
		//	          "type": "object"
		//	        }
		//	      },
		//	      "type": "object"
		//	    },
		//	    "ModelQuality": {
		//	      "additionalProperties": false,
		//	      "description": "Metrics that measure the quality of a model.",
		//	      "properties": {
		//	        "Constraints": {
		//	          "additionalProperties": false,
		//	          "description": "Represents a Metric Source Object.",
		//	          "properties": {
		//	            "ContentDigest": {
		//	              "description": "The digest of the metric source.",
		//	              "maxLength": 72,
		//	              "pattern": "^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$",
		//	              "type": "string"
		//	            },
		//	            "ContentType": {
		//	              "description": "The type of content stored in the metric source.",
		//	              "maxLength": 256,
		//	              "pattern": ".*",
		//	              "type": "string"
		//	            },
		//	            "S3Uri": {
		//	              "description": "The Amazon S3 URI for the metric source.",
		//	              "maxLength": 1024,
		//	              "pattern": "^(https|s3)://([^/]+)/?(.*)$",
		//	              "type": "string"
		//	            }
		//	          },
		//	          "required": [
		//	            "ContentType",
		//	            "S3Uri"
		//	          ],
		//	          "type": "object"
		//	        },
		//	        "Statistics": {
		//	          "additionalProperties": false,
		//	          "description": "Represents a Metric Source Object.",
		//	          "properties": {
		//	            "ContentDigest": {
		//	              "description": "The digest of the metric source.",
		//	              "maxLength": 72,
		//	              "pattern": "^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$",
		//	              "type": "string"
		//	            },
		//	            "ContentType": {
		//	              "description": "The type of content stored in the metric source.",
		//	              "maxLength": 256,
		//	              "pattern": ".*",
		//	              "type": "string"
		//	            },
		//	            "S3Uri": {
		//	              "description": "The Amazon S3 URI for the metric source.",
		//	              "maxLength": 1024,
		//	              "pattern": "^(https|s3)://([^/]+)/?(.*)$",
		//	              "type": "string"
		//	            }
		//	          },
		//	          "required": [
		//	            "ContentType",
		//	            "S3Uri"
		//	          ],
		//	          "type": "object"
		//	        }
		//	      },
		//	      "type": "object"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"model_metrics": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: Bias
				"bias": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
					Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
						// Property: PostTrainingReport
						"post_training_report": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: ContentDigest
								"content_digest": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The digest of the metric source.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(72),
										stringvalidator.RegexMatches(regexp.MustCompile("^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$"), ""),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: ContentType
								"content_type": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The type of content stored in the metric source.",
									Required:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(256),
										stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
									}, /*END VALIDATORS*/
								}, /*END ATTRIBUTE*/
								// Property: S3Uri
								"s3_uri": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The Amazon S3 URI for the metric source.",
									Required:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(1024),
										stringvalidator.RegexMatches(regexp.MustCompile("^(https|s3)://([^/]+)/?(.*)$"), ""),
									}, /*END VALIDATORS*/
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
							Description: "Represents a Metric Source Object.",
							Optional:    true,
							Computed:    true,
							PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
								objectplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
						// Property: PreTrainingReport
						"pre_training_report": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: ContentDigest
								"content_digest": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The digest of the metric source.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(72),
										stringvalidator.RegexMatches(regexp.MustCompile("^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$"), ""),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: ContentType
								"content_type": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The type of content stored in the metric source.",
									Required:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(256),
										stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
									}, /*END VALIDATORS*/
								}, /*END ATTRIBUTE*/
								// Property: S3Uri
								"s3_uri": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The Amazon S3 URI for the metric source.",
									Required:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(1024),
										stringvalidator.RegexMatches(regexp.MustCompile("^(https|s3)://([^/]+)/?(.*)$"), ""),
									}, /*END VALIDATORS*/
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
							Description: "Represents a Metric Source Object.",
							Optional:    true,
							Computed:    true,
							PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
								objectplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
						// Property: Report
						"report": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: ContentDigest
								"content_digest": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The digest of the metric source.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(72),
										stringvalidator.RegexMatches(regexp.MustCompile("^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$"), ""),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: ContentType
								"content_type": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The type of content stored in the metric source.",
									Required:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(256),
										stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
									}, /*END VALIDATORS*/
								}, /*END ATTRIBUTE*/
								// Property: S3Uri
								"s3_uri": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The Amazon S3 URI for the metric source.",
									Required:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(1024),
										stringvalidator.RegexMatches(regexp.MustCompile("^(https|s3)://([^/]+)/?(.*)$"), ""),
									}, /*END VALIDATORS*/
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
							Description: "Represents a Metric Source Object.",
							Optional:    true,
							Computed:    true,
							PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
								objectplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
					}, /*END SCHEMA*/
					Description: "Contains bias metrics for a model.",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
						objectplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: Explainability
				"explainability": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
					Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
						// Property: Report
						"report": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: ContentDigest
								"content_digest": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The digest of the metric source.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(72),
										stringvalidator.RegexMatches(regexp.MustCompile("^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$"), ""),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: ContentType
								"content_type": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The type of content stored in the metric source.",
									Required:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(256),
										stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
									}, /*END VALIDATORS*/
								}, /*END ATTRIBUTE*/
								// Property: S3Uri
								"s3_uri": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The Amazon S3 URI for the metric source.",
									Required:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(1024),
										stringvalidator.RegexMatches(regexp.MustCompile("^(https|s3)://([^/]+)/?(.*)$"), ""),
									}, /*END VALIDATORS*/
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
							Description: "Represents a Metric Source Object.",
							Optional:    true,
							Computed:    true,
							PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
								objectplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
					}, /*END SCHEMA*/
					Description: "Contains explainability metrics for a model.",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
						objectplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: ModelDataQuality
				"model_data_quality": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
					Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
						// Property: Constraints
						"constraints": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: ContentDigest
								"content_digest": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The digest of the metric source.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(72),
										stringvalidator.RegexMatches(regexp.MustCompile("^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$"), ""),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: ContentType
								"content_type": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The type of content stored in the metric source.",
									Required:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(256),
										stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
									}, /*END VALIDATORS*/
								}, /*END ATTRIBUTE*/
								// Property: S3Uri
								"s3_uri": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The Amazon S3 URI for the metric source.",
									Required:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(1024),
										stringvalidator.RegexMatches(regexp.MustCompile("^(https|s3)://([^/]+)/?(.*)$"), ""),
									}, /*END VALIDATORS*/
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
							Description: "Represents a Metric Source Object.",
							Optional:    true,
							Computed:    true,
							PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
								objectplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
						// Property: Statistics
						"statistics": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: ContentDigest
								"content_digest": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The digest of the metric source.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(72),
										stringvalidator.RegexMatches(regexp.MustCompile("^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$"), ""),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: ContentType
								"content_type": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The type of content stored in the metric source.",
									Required:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(256),
										stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
									}, /*END VALIDATORS*/
								}, /*END ATTRIBUTE*/
								// Property: S3Uri
								"s3_uri": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The Amazon S3 URI for the metric source.",
									Required:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(1024),
										stringvalidator.RegexMatches(regexp.MustCompile("^(https|s3)://([^/]+)/?(.*)$"), ""),
									}, /*END VALIDATORS*/
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
							Description: "Represents a Metric Source Object.",
							Optional:    true,
							Computed:    true,
							PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
								objectplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
					}, /*END SCHEMA*/
					Description: "Metrics that measure the quality of the input data for a model.",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
						objectplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: ModelQuality
				"model_quality": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
					Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
						// Property: Constraints
						"constraints": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: ContentDigest
								"content_digest": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The digest of the metric source.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(72),
										stringvalidator.RegexMatches(regexp.MustCompile("^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$"), ""),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: ContentType
								"content_type": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The type of content stored in the metric source.",
									Required:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(256),
										stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
									}, /*END VALIDATORS*/
								}, /*END ATTRIBUTE*/
								// Property: S3Uri
								"s3_uri": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The Amazon S3 URI for the metric source.",
									Required:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(1024),
										stringvalidator.RegexMatches(regexp.MustCompile("^(https|s3)://([^/]+)/?(.*)$"), ""),
									}, /*END VALIDATORS*/
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
							Description: "Represents a Metric Source Object.",
							Optional:    true,
							Computed:    true,
							PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
								objectplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
						// Property: Statistics
						"statistics": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: ContentDigest
								"content_digest": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The digest of the metric source.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(72),
										stringvalidator.RegexMatches(regexp.MustCompile("^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$"), ""),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: ContentType
								"content_type": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The type of content stored in the metric source.",
									Required:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(256),
										stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
									}, /*END VALIDATORS*/
								}, /*END ATTRIBUTE*/
								// Property: S3Uri
								"s3_uri": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The Amazon S3 URI for the metric source.",
									Required:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthAtMost(1024),
										stringvalidator.RegexMatches(regexp.MustCompile("^(https|s3)://([^/]+)/?(.*)$"), ""),
									}, /*END VALIDATORS*/
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
							Description: "Represents a Metric Source Object.",
							Optional:    true,
							Computed:    true,
							PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
								objectplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
					}, /*END SCHEMA*/
					Description: "Metrics that measure the quality of a model.",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
						objectplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "A structure that contains model metrics reports.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
				objectplanmodifier.RequiresReplace(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: ModelPackageArn
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The Amazon Resource Name (ARN) of the model package group.",
		//	  "maxLength": 2048,
		//	  "minLength": 1,
		//	  "pattern": "",
		//	  "type": "string"
		//	}
		"model_package_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The Amazon Resource Name (ARN) of the model package group.",
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: ModelPackageDescription
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The description of the model package.",
		//	  "maxLength": 1024,
		//	  "pattern": "[\\p{L}\\p{M}\\p{Z}\\p{S}\\p{N}\\p{P}]*",
		//	  "type": "string"
		//	}
		"model_package_description": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The description of the model package.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.LengthAtMost(1024),
				stringvalidator.RegexMatches(regexp.MustCompile("[\\p{L}\\p{M}\\p{Z}\\p{S}\\p{N}\\p{P}]*"), ""),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
				stringplanmodifier.RequiresReplace(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: ModelPackageGroupName
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The name of the model package group.",
		//	  "maxLength": 170,
		//	  "minLength": 1,
		//	  "pattern": "",
		//	  "type": "string"
		//	}
		"model_package_group_name": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The name of the model package group.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.LengthBetween(1, 170),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
				stringplanmodifier.RequiresReplace(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: ModelPackageName
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The name or arn of the model package.",
		//	  "type": "string"
		//	}
		"model_package_name": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The name or arn of the model package.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: ModelPackageStatus
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The current status of the model package.",
		//	  "enum": [
		//	    "Pending",
		//	    "Deleting",
		//	    "InProgress",
		//	    "Completed",
		//	    "Failed"
		//	  ],
		//	  "type": "string"
		//	}
		"model_package_status": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The current status of the model package.",
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: ModelPackageStatusDetails
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "Details about the current status of the model package.",
		//	  "properties": {
		//	    "ValidationStatuses": {
		//	      "insertionOrder": true,
		//	      "items": {
		//	        "additionalProperties": false,
		//	        "description": "Represents the overall status of a model package.",
		//	        "properties": {
		//	          "FailureReason": {
		//	            "description": "If the overall status is Failed, the reason for the failure.",
		//	            "type": "string"
		//	          },
		//	          "Name": {
		//	            "description": "The name of the model package for which the overall status is being reported.",
		//	            "maxLength": 63,
		//	            "minLength": 1,
		//	            "pattern": "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$",
		//	            "type": "string"
		//	          },
		//	          "Status": {
		//	            "description": "The current status.",
		//	            "enum": [
		//	              "NotStarted",
		//	              "Failed",
		//	              "InProgress",
		//	              "Completed"
		//	            ],
		//	            "type": "string"
		//	          }
		//	        },
		//	        "required": [
		//	          "Name",
		//	          "Status"
		//	        ],
		//	        "type": "object"
		//	      },
		//	      "type": "array"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"model_package_status_details": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: ValidationStatuses
				"validation_statuses": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
					NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: FailureReason
							"failure_reason": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "If the overall status is Failed, the reason for the failure.",
								Optional:    true,
								Computed:    true,
								PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
									stringplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: Name
							"name": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "The name of the model package for which the overall status is being reported.",
								Required:    true,
								Validators: []validator.String{ /*START VALIDATORS*/
									stringvalidator.LengthBetween(1, 63),
									stringvalidator.RegexMatches(regexp.MustCompile("^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$"), ""),
								}, /*END VALIDATORS*/
							}, /*END ATTRIBUTE*/
							// Property: Status
							"status": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "The current status.",
								Required:    true,
								Validators: []validator.String{ /*START VALIDATORS*/
									stringvalidator.OneOf(
										"NotStarted",
										"Failed",
										"InProgress",
										"Completed",
									),
								}, /*END VALIDATORS*/
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
					}, /*END NESTED OBJECT*/
					Optional: true,
					Computed: true,
					PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
						listplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "Details about the current status of the model package.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: ModelPackageVersion
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The version of the model package.",
		//	  "minimum": 1,
		//	  "type": "integer"
		//	}
		"model_package_version": schema.Int64Attribute{ /*START ATTRIBUTE*/
			Description: "The version of the model package.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.Int64{ /*START VALIDATORS*/
				int64validator.AtLeast(1),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
				int64planmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: SamplePayloadUrl
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The Amazon Simple Storage Service (Amazon S3) path where the sample payload are stored pointing to single gzip compressed tar archive.",
		//	  "maxLength": 1024,
		//	  "pattern": "^(https|s3)://([^/]+)/?(.*)$",
		//	  "type": "string"
		//	}
		"sample_payload_url": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The Amazon Simple Storage Service (Amazon S3) path where the sample payload are stored pointing to single gzip compressed tar archive.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.LengthAtMost(1024),
				stringvalidator.RegexMatches(regexp.MustCompile("^(https|s3)://([^/]+)/?(.*)$"), ""),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
				stringplanmodifier.RequiresReplace(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: SourceAlgorithmSpecification
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "Details about the algorithm that was used to create the model package.",
		//	  "insertionOrder": true,
		//	  "properties": {
		//	    "SourceAlgorithms": {
		//	      "description": "A list of algorithms that were used to create a model package.",
		//	      "insertionOrder": true,
		//	      "items": {
		//	        "additionalProperties": false,
		//	        "description": "Specifies an algorithm that was used to create the model package. The algorithm must be either an algorithm resource in your Amazon SageMaker account or an algorithm in AWS Marketplace that you are subscribed to.",
		//	        "properties": {
		//	          "AlgorithmName": {
		//	            "description": "The name of an algorithm that was used to create the model package. The algorithm must be either an algorithm resource in your Amazon SageMaker account or an algorithm in AWS Marketplace that you are subscribed to.",
		//	            "maxLength": 170,
		//	            "minLength": 1,
		//	            "pattern": "",
		//	            "type": "string"
		//	          },
		//	          "ModelDataUrl": {
		//	            "description": "The Amazon S3 path where the model artifacts, which result from model training, are stored. This path must point to a single gzip compressed tar archive (.tar.gz suffix).",
		//	            "maxLength": 1024,
		//	            "pattern": "^(https|s3)://([^/]+)/?(.*)$",
		//	            "type": "string"
		//	          }
		//	        },
		//	        "required": [
		//	          "AlgorithmName"
		//	        ],
		//	        "type": "object"
		//	      },
		//	      "maxItems": 1,
		//	      "minItems": 1,
		//	      "type": "array"
		//	    }
		//	  },
		//	  "required": [
		//	    "SourceAlgorithms"
		//	  ],
		//	  "type": "object"
		//	}
		"source_algorithm_specification": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: SourceAlgorithms
				"source_algorithms": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
					NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: AlgorithmName
							"algorithm_name": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "The name of an algorithm that was used to create the model package. The algorithm must be either an algorithm resource in your Amazon SageMaker account or an algorithm in AWS Marketplace that you are subscribed to.",
								Required:    true,
								Validators: []validator.String{ /*START VALIDATORS*/
									stringvalidator.LengthBetween(1, 170),
								}, /*END VALIDATORS*/
							}, /*END ATTRIBUTE*/
							// Property: ModelDataUrl
							"model_data_url": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "The Amazon S3 path where the model artifacts, which result from model training, are stored. This path must point to a single gzip compressed tar archive (.tar.gz suffix).",
								Optional:    true,
								Computed:    true,
								Validators: []validator.String{ /*START VALIDATORS*/
									stringvalidator.LengthAtMost(1024),
									stringvalidator.RegexMatches(regexp.MustCompile("^(https|s3)://([^/]+)/?(.*)$"), ""),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
									stringplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
					}, /*END NESTED OBJECT*/
					Description: "A list of algorithms that were used to create a model package.",
					Required:    true,
					Validators: []validator.List{ /*START VALIDATORS*/
						listvalidator.SizeBetween(1, 1),
					}, /*END VALIDATORS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "Details about the algorithm that was used to create the model package.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
				objectplanmodifier.RequiresReplace(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Tags
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "An array of key-value pairs to apply to this resource.",
		//	  "items": {
		//	    "additionalProperties": false,
		//	    "description": "A key-value pair to associate with a resource.",
		//	    "properties": {
		//	      "Key": {
		//	        "description": "The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.",
		//	        "maxLength": 128,
		//	        "minLength": 1,
		//	        "pattern": "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$",
		//	        "type": "string"
		//	      },
		//	      "Value": {
		//	        "description": "The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.",
		//	        "maxLength": 256,
		//	        "pattern": "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$",
		//	        "type": "string"
		//	      }
		//	    },
		//	    "required": [
		//	      "Key",
		//	      "Value"
		//	    ],
		//	    "type": "object"
		//	  },
		//	  "maxItems": 50,
		//	  "type": "array"
		//	}
		"tags": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: Key
					"key": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.",
						Required:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.LengthBetween(1, 128),
							stringvalidator.RegexMatches(regexp.MustCompile("^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$"), ""),
						}, /*END VALIDATORS*/
					}, /*END ATTRIBUTE*/
					// Property: Value
					"value": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.",
						Required:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.LengthAtMost(256),
							stringvalidator.RegexMatches(regexp.MustCompile("^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$"), ""),
						}, /*END VALIDATORS*/
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Description: "An array of key-value pairs to apply to this resource.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.List{ /*START VALIDATORS*/
				listvalidator.SizeAtMost(50),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
				listplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Task
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The machine learning task your model package accomplishes.",
		//	  "type": "string"
		//	}
		"task": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The machine learning task your model package accomplishes.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
				stringplanmodifier.RequiresReplace(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: ValidationSpecification
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "Specifies configurations for one or more transform jobs that Amazon SageMaker runs to test the model package.",
		//	  "insertionOrder": true,
		//	  "properties": {
		//	    "ValidationProfiles": {
		//	      "insertionOrder": true,
		//	      "items": {
		//	        "additionalProperties": false,
		//	        "description": "Contains data, such as the inputs and targeted instance types that are used in the process of validating the model package.",
		//	        "properties": {
		//	          "ProfileName": {
		//	            "description": "The name of the profile for the model package.",
		//	            "maxLength": 63,
		//	            "minLength": 1,
		//	            "pattern": "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$",
		//	            "type": "string"
		//	          },
		//	          "TransformJobDefinition": {
		//	            "additionalProperties": false,
		//	            "description": "Defines the input needed to run a transform job using the inference specification specified in the algorithm.",
		//	            "properties": {
		//	              "BatchStrategy": {
		//	                "description": "A string that determines the number of records included in a single mini-batch.",
		//	                "enum": [
		//	                  "MultiRecord",
		//	                  "SingleRecord"
		//	                ],
		//	                "type": "string"
		//	              },
		//	              "Environment": {
		//	                "additionalProperties": false,
		//	                "description": "Sets the environment variables in the Docker container",
		//	                "patternProperties": {
		//	                  "": {
		//	                    "maxLength": 1024,
		//	                    "type": "string"
		//	                  },
		//	                  "[\\S\\s]*": {
		//	                    "maxLength": 1024,
		//	                    "type": "string"
		//	                  }
		//	                },
		//	                "type": "object"
		//	              },
		//	              "MaxConcurrentTransforms": {
		//	                "description": "The maximum number of parallel requests that can be sent to each instance in a transform job. The default value is 1.",
		//	                "minimum": 0,
		//	                "type": "integer"
		//	              },
		//	              "MaxPayloadInMB": {
		//	                "description": "The maximum payload size allowed, in MB. A payload is the data portion of a record (without metadata).",
		//	                "minimum": 0,
		//	                "type": "integer"
		//	              },
		//	              "TransformInput": {
		//	                "additionalProperties": false,
		//	                "description": "Describes the input source of a transform job and the way the transform job consumes it.",
		//	                "properties": {
		//	                  "CompressionType": {
		//	                    "description": "If your transform data is compressed, specify the compression type. Amazon SageMaker automatically decompresses the data for the transform job accordingly. The default value is None.",
		//	                    "enum": [
		//	                      "None",
		//	                      "Gzip"
		//	                    ],
		//	                    "type": "string"
		//	                  },
		//	                  "ContentType": {
		//	                    "description": "The multipurpose internet mail extension (MIME) type of the data. Amazon SageMaker uses the MIME type with each http call to transfer data to the transform job.",
		//	                    "maxLength": 256,
		//	                    "pattern": ".*",
		//	                    "type": "string"
		//	                  },
		//	                  "DataSource": {
		//	                    "additionalProperties": false,
		//	                    "description": "Describes the input source of a transform job and the way the transform job consumes it.",
		//	                    "properties": {
		//	                      "S3DataSource": {
		//	                        "additionalProperties": false,
		//	                        "description": "Describes the S3 data source.",
		//	                        "properties": {
		//	                          "S3DataType": {
		//	                            "description": "The S3 Data Source Type",
		//	                            "enum": [
		//	                              "ManifestFile",
		//	                              "S3Prefix",
		//	                              "AugmentedManifestFile"
		//	                            ],
		//	                            "type": "string"
		//	                          },
		//	                          "S3Uri": {
		//	                            "description": "Depending on the value specified for the S3DataType, identifies either a key name prefix or a manifest.",
		//	                            "maxLength": 1024,
		//	                            "pattern": "^(https|s3)://([^/]+)/?(.*)$",
		//	                            "type": "string"
		//	                          }
		//	                        },
		//	                        "required": [
		//	                          "S3DataType",
		//	                          "S3Uri"
		//	                        ],
		//	                        "type": "object"
		//	                      }
		//	                    },
		//	                    "required": [
		//	                      "S3DataSource"
		//	                    ],
		//	                    "type": "object"
		//	                  },
		//	                  "SplitType": {
		//	                    "description": "The method to use to split the transform job's data files into smaller batches. ",
		//	                    "enum": [
		//	                      "None",
		//	                      "TFRecord",
		//	                      "Line",
		//	                      "RecordIO"
		//	                    ],
		//	                    "type": "string"
		//	                  }
		//	                },
		//	                "required": [
		//	                  "DataSource"
		//	                ],
		//	                "type": "object"
		//	              },
		//	              "TransformOutput": {
		//	                "additionalProperties": false,
		//	                "description": "Describes the results of a transform job.",
		//	                "properties": {
		//	                  "Accept": {
		//	                    "description": "The MIME type used to specify the output data. Amazon SageMaker uses the MIME type with each http call to transfer data from the transform job.",
		//	                    "maxLength": 256,
		//	                    "pattern": ".*",
		//	                    "type": "string"
		//	                  },
		//	                  "AssembleWith": {
		//	                    "description": "Defines how to assemble the results of the transform job as a single S3 object.",
		//	                    "enum": [
		//	                      "None",
		//	                      "Line"
		//	                    ],
		//	                    "type": "string"
		//	                  },
		//	                  "KmsKeyId": {
		//	                    "description": "The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.",
		//	                    "maxLength": 2048,
		//	                    "pattern": ".*",
		//	                    "type": "string"
		//	                  },
		//	                  "S3OutputPath": {
		//	                    "description": "The Amazon S3 path where you want Amazon SageMaker to store the results of the transform job.",
		//	                    "maxLength": 1024,
		//	                    "pattern": "^(https|s3)://([^/]+)/?(.*)$",
		//	                    "type": "string"
		//	                  }
		//	                },
		//	                "required": [
		//	                  "S3OutputPath"
		//	                ],
		//	                "type": "object"
		//	              },
		//	              "TransformResources": {
		//	                "additionalProperties": false,
		//	                "description": "Describes the resources, including ML instance types and ML instance count, to use for transform job.",
		//	                "properties": {
		//	                  "InstanceCount": {
		//	                    "description": "The number of ML compute instances to use in the transform job. For distributed transform jobs, specify a value greater than 1. The default value is 1.",
		//	                    "minimum": 1,
		//	                    "type": "integer"
		//	                  },
		//	                  "InstanceType": {
		//	                    "description": "The ML compute instance type for the transform job.",
		//	                    "type": "string"
		//	                  },
		//	                  "VolumeKmsKeyId": {
		//	                    "description": "The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt model data on the storage volume attached to the ML compute instance(s) that run the batch transform job.",
		//	                    "maxLength": 2048,
		//	                    "pattern": ".*",
		//	                    "type": "string"
		//	                  }
		//	                },
		//	                "required": [
		//	                  "InstanceCount",
		//	                  "InstanceType"
		//	                ],
		//	                "type": "object"
		//	              }
		//	            },
		//	            "required": [
		//	              "TransformResources",
		//	              "TransformOutput",
		//	              "TransformInput"
		//	            ],
		//	            "type": "object"
		//	          }
		//	        },
		//	        "required": [
		//	          "TransformJobDefinition",
		//	          "ProfileName"
		//	        ],
		//	        "type": "object"
		//	      },
		//	      "maxItems": 1,
		//	      "minItems": 0,
		//	      "type": "array"
		//	    },
		//	    "ValidationRole": {
		//	      "description": "The IAM roles to be used for the validation of the model package.",
		//	      "maxLength": 2048,
		//	      "minLength": 20,
		//	      "pattern": "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$",
		//	      "type": "string"
		//	    }
		//	  },
		//	  "required": [
		//	    "ValidationProfiles",
		//	    "ValidationRole"
		//	  ],
		//	  "type": "object"
		//	}
		"validation_specification": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: ValidationProfiles
				"validation_profiles": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
					NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: ProfileName
							"profile_name": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "The name of the profile for the model package.",
								Required:    true,
								Validators: []validator.String{ /*START VALIDATORS*/
									stringvalidator.LengthBetween(1, 63),
									stringvalidator.RegexMatches(regexp.MustCompile("^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,62}$"), ""),
								}, /*END VALIDATORS*/
							}, /*END ATTRIBUTE*/
							// Property: TransformJobDefinition
							"transform_job_definition": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
								Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
									// Property: BatchStrategy
									"batch_strategy": schema.StringAttribute{ /*START ATTRIBUTE*/
										Description: "A string that determines the number of records included in a single mini-batch.",
										Optional:    true,
										Computed:    true,
										Validators: []validator.String{ /*START VALIDATORS*/
											stringvalidator.OneOf(
												"MultiRecord",
												"SingleRecord",
											),
										}, /*END VALIDATORS*/
										PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
											stringplanmodifier.UseStateForUnknown(),
										}, /*END PLAN MODIFIERS*/
									}, /*END ATTRIBUTE*/
									// Property: Environment
									"environment":       // Pattern: ""
									schema.MapAttribute{ /*START ATTRIBUTE*/
										ElementType: types.StringType,
										// Pattern "[\\S\\s]*" ignored.
										Description: "Sets the environment variables in the Docker container",
										Optional:    true,
										Computed:    true,
										PlanModifiers: []planmodifier.Map{ /*START PLAN MODIFIERS*/
											mapplanmodifier.UseStateForUnknown(),
										}, /*END PLAN MODIFIERS*/
									}, /*END ATTRIBUTE*/
									// Property: MaxConcurrentTransforms
									"max_concurrent_transforms": schema.Int64Attribute{ /*START ATTRIBUTE*/
										Description: "The maximum number of parallel requests that can be sent to each instance in a transform job. The default value is 1.",
										Optional:    true,
										Computed:    true,
										Validators: []validator.Int64{ /*START VALIDATORS*/
											int64validator.AtLeast(0),
										}, /*END VALIDATORS*/
										PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
											int64planmodifier.UseStateForUnknown(),
										}, /*END PLAN MODIFIERS*/
									}, /*END ATTRIBUTE*/
									// Property: MaxPayloadInMB
									"max_payload_in_mb": schema.Int64Attribute{ /*START ATTRIBUTE*/
										Description: "The maximum payload size allowed, in MB. A payload is the data portion of a record (without metadata).",
										Optional:    true,
										Computed:    true,
										Validators: []validator.Int64{ /*START VALIDATORS*/
											int64validator.AtLeast(0),
										}, /*END VALIDATORS*/
										PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
											int64planmodifier.UseStateForUnknown(),
										}, /*END PLAN MODIFIERS*/
									}, /*END ATTRIBUTE*/
									// Property: TransformInput
									"transform_input": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
										Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
											// Property: CompressionType
											"compression_type": schema.StringAttribute{ /*START ATTRIBUTE*/
												Description: "If your transform data is compressed, specify the compression type. Amazon SageMaker automatically decompresses the data for the transform job accordingly. The default value is None.",
												Optional:    true,
												Computed:    true,
												Validators: []validator.String{ /*START VALIDATORS*/
													stringvalidator.OneOf(
														"None",
														"Gzip",
													),
												}, /*END VALIDATORS*/
												PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
													stringplanmodifier.UseStateForUnknown(),
												}, /*END PLAN MODIFIERS*/
											}, /*END ATTRIBUTE*/
											// Property: ContentType
											"content_type": schema.StringAttribute{ /*START ATTRIBUTE*/
												Description: "The multipurpose internet mail extension (MIME) type of the data. Amazon SageMaker uses the MIME type with each http call to transfer data to the transform job.",
												Optional:    true,
												Computed:    true,
												Validators: []validator.String{ /*START VALIDATORS*/
													stringvalidator.LengthAtMost(256),
													stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
												}, /*END VALIDATORS*/
												PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
													stringplanmodifier.UseStateForUnknown(),
												}, /*END PLAN MODIFIERS*/
											}, /*END ATTRIBUTE*/
											// Property: DataSource
											"data_source": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
												Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
													// Property: S3DataSource
													"s3_data_source": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
														Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
															// Property: S3DataType
															"s3_data_type": schema.StringAttribute{ /*START ATTRIBUTE*/
																Description: "The S3 Data Source Type",
																Required:    true,
																Validators: []validator.String{ /*START VALIDATORS*/
																	stringvalidator.OneOf(
																		"ManifestFile",
																		"S3Prefix",
																		"AugmentedManifestFile",
																	),
																}, /*END VALIDATORS*/
															}, /*END ATTRIBUTE*/
															// Property: S3Uri
															"s3_uri": schema.StringAttribute{ /*START ATTRIBUTE*/
																Description: "Depending on the value specified for the S3DataType, identifies either a key name prefix or a manifest.",
																Required:    true,
																Validators: []validator.String{ /*START VALIDATORS*/
																	stringvalidator.LengthAtMost(1024),
																	stringvalidator.RegexMatches(regexp.MustCompile("^(https|s3)://([^/]+)/?(.*)$"), ""),
																}, /*END VALIDATORS*/
															}, /*END ATTRIBUTE*/
														}, /*END SCHEMA*/
														Description: "Describes the S3 data source.",
														Required:    true,
													}, /*END ATTRIBUTE*/
												}, /*END SCHEMA*/
												Description: "Describes the input source of a transform job and the way the transform job consumes it.",
												Required:    true,
											}, /*END ATTRIBUTE*/
											// Property: SplitType
											"split_type": schema.StringAttribute{ /*START ATTRIBUTE*/
												Description: "The method to use to split the transform job's data files into smaller batches. ",
												Optional:    true,
												Computed:    true,
												Validators: []validator.String{ /*START VALIDATORS*/
													stringvalidator.OneOf(
														"None",
														"TFRecord",
														"Line",
														"RecordIO",
													),
												}, /*END VALIDATORS*/
												PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
													stringplanmodifier.UseStateForUnknown(),
												}, /*END PLAN MODIFIERS*/
											}, /*END ATTRIBUTE*/
										}, /*END SCHEMA*/
										Description: "Describes the input source of a transform job and the way the transform job consumes it.",
										Required:    true,
									}, /*END ATTRIBUTE*/
									// Property: TransformOutput
									"transform_output": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
										Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
											// Property: Accept
											"accept": schema.StringAttribute{ /*START ATTRIBUTE*/
												Description: "The MIME type used to specify the output data. Amazon SageMaker uses the MIME type with each http call to transfer data from the transform job.",
												Optional:    true,
												Computed:    true,
												Validators: []validator.String{ /*START VALIDATORS*/
													stringvalidator.LengthAtMost(256),
													stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
												}, /*END VALIDATORS*/
												PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
													stringplanmodifier.UseStateForUnknown(),
												}, /*END PLAN MODIFIERS*/
											}, /*END ATTRIBUTE*/
											// Property: AssembleWith
											"assemble_with": schema.StringAttribute{ /*START ATTRIBUTE*/
												Description: "Defines how to assemble the results of the transform job as a single S3 object.",
												Optional:    true,
												Computed:    true,
												Validators: []validator.String{ /*START VALIDATORS*/
													stringvalidator.OneOf(
														"None",
														"Line",
													),
												}, /*END VALIDATORS*/
												PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
													stringplanmodifier.UseStateForUnknown(),
												}, /*END PLAN MODIFIERS*/
											}, /*END ATTRIBUTE*/
											// Property: KmsKeyId
											"kms_key_id": schema.StringAttribute{ /*START ATTRIBUTE*/
												Description: "The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.",
												Optional:    true,
												Computed:    true,
												Validators: []validator.String{ /*START VALIDATORS*/
													stringvalidator.LengthAtMost(2048),
													stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
												}, /*END VALIDATORS*/
												PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
													stringplanmodifier.UseStateForUnknown(),
												}, /*END PLAN MODIFIERS*/
											}, /*END ATTRIBUTE*/
											// Property: S3OutputPath
											"s3_output_path": schema.StringAttribute{ /*START ATTRIBUTE*/
												Description: "The Amazon S3 path where you want Amazon SageMaker to store the results of the transform job.",
												Required:    true,
												Validators: []validator.String{ /*START VALIDATORS*/
													stringvalidator.LengthAtMost(1024),
													stringvalidator.RegexMatches(regexp.MustCompile("^(https|s3)://([^/]+)/?(.*)$"), ""),
												}, /*END VALIDATORS*/
											}, /*END ATTRIBUTE*/
										}, /*END SCHEMA*/
										Description: "Describes the results of a transform job.",
										Required:    true,
									}, /*END ATTRIBUTE*/
									// Property: TransformResources
									"transform_resources": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
										Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
											// Property: InstanceCount
											"instance_count": schema.Int64Attribute{ /*START ATTRIBUTE*/
												Description: "The number of ML compute instances to use in the transform job. For distributed transform jobs, specify a value greater than 1. The default value is 1.",
												Required:    true,
												Validators: []validator.Int64{ /*START VALIDATORS*/
													int64validator.AtLeast(1),
												}, /*END VALIDATORS*/
											}, /*END ATTRIBUTE*/
											// Property: InstanceType
											"instance_type": schema.StringAttribute{ /*START ATTRIBUTE*/
												Description: "The ML compute instance type for the transform job.",
												Required:    true,
											}, /*END ATTRIBUTE*/
											// Property: VolumeKmsKeyId
											"volume_kms_key_id": schema.StringAttribute{ /*START ATTRIBUTE*/
												Description: "The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt model data on the storage volume attached to the ML compute instance(s) that run the batch transform job.",
												Optional:    true,
												Computed:    true,
												Validators: []validator.String{ /*START VALIDATORS*/
													stringvalidator.LengthAtMost(2048),
													stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
												}, /*END VALIDATORS*/
												PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
													stringplanmodifier.UseStateForUnknown(),
												}, /*END PLAN MODIFIERS*/
											}, /*END ATTRIBUTE*/
										}, /*END SCHEMA*/
										Description: "Describes the resources, including ML instance types and ML instance count, to use for transform job.",
										Required:    true,
									}, /*END ATTRIBUTE*/
								}, /*END SCHEMA*/
								Description: "Defines the input needed to run a transform job using the inference specification specified in the algorithm.",
								Required:    true,
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
					}, /*END NESTED OBJECT*/
					Required: true,
					Validators: []validator.List{ /*START VALIDATORS*/
						listvalidator.SizeBetween(0, 1),
					}, /*END VALIDATORS*/
				}, /*END ATTRIBUTE*/
				// Property: ValidationRole
				"validation_role": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "The IAM roles to be used for the validation of the model package.",
					Required:    true,
					Validators: []validator.String{ /*START VALIDATORS*/
						stringvalidator.LengthBetween(20, 2048),
						stringvalidator.RegexMatches(regexp.MustCompile("^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$"), ""),
					}, /*END VALIDATORS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "Specifies configurations for one or more transform jobs that Amazon SageMaker runs to test the model package.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
				objectplanmodifier.RequiresReplace(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
	} /*END SCHEMA*/

	attributes["id"] = schema.StringAttribute{
		Description: "Uniquely identifies the resource.",
		Computed:    true,
		PlanModifiers: []planmodifier.String{
			stringplanmodifier.UseStateForUnknown(),
		},
	}

	schema := schema.Schema{
		Description: "Resource Type definition for AWS::SageMaker::ModelPackage",
		Version:     1,
		Attributes:  attributes,
	}

	var opts generic.ResourceOptions

	opts = opts.WithCloudFormationTypeName("AWS::SageMaker::ModelPackage").WithTerraformTypeName("awscc_sagemaker_model_package")
	opts = opts.WithTerraformSchema(schema)
	opts = opts.WithSyntheticIDAttribute(true)
	opts = opts.WithAttributeNameMap(map[string]string{
		"accept":                              "Accept",
		"additional_inference_specifications": "AdditionalInferenceSpecifications",
		"additional_inference_specifications_to_add": "AdditionalInferenceSpecificationsToAdd",
		"algorithm_name":                 "AlgorithmName",
		"approval_description":           "ApprovalDescription",
		"assemble_with":                  "AssembleWith",
		"batch_strategy":                 "BatchStrategy",
		"bias":                           "Bias",
		"certify_for_marketplace":        "CertifyForMarketplace",
		"client_token":                   "ClientToken",
		"commit_id":                      "CommitId",
		"compression_type":               "CompressionType",
		"config_file":                    "ConfigFile",
		"constraints":                    "Constraints",
		"container_hostname":             "ContainerHostname",
		"containers":                     "Containers",
		"content_digest":                 "ContentDigest",
		"content_type":                   "ContentType",
		"creation_time":                  "CreationTime",
		"customer_metadata_properties":   "CustomerMetadataProperties",
		"data_input_config":              "DataInputConfig",
		"data_source":                    "DataSource",
		"description":                    "Description",
		"domain":                         "Domain",
		"drift_check_baselines":          "DriftCheckBaselines",
		"environment":                    "Environment",
		"explainability":                 "Explainability",
		"failure_reason":                 "FailureReason",
		"framework":                      "Framework",
		"framework_version":              "FrameworkVersion",
		"generated_by":                   "GeneratedBy",
		"image":                          "Image",
		"image_digest":                   "ImageDigest",
		"inference_specification":        "InferenceSpecification",
		"instance_count":                 "InstanceCount",
		"instance_type":                  "InstanceType",
		"key":                            "Key",
		"kms_key_id":                     "KmsKeyId",
		"last_modified_time":             "LastModifiedTime",
		"max_concurrent_transforms":      "MaxConcurrentTransforms",
		"max_payload_in_mb":              "MaxPayloadInMB",
		"metadata_properties":            "MetadataProperties",
		"model_approval_status":          "ModelApprovalStatus",
		"model_data_quality":             "ModelDataQuality",
		"model_data_url":                 "ModelDataUrl",
		"model_input":                    "ModelInput",
		"model_metrics":                  "ModelMetrics",
		"model_package_arn":              "ModelPackageArn",
		"model_package_description":      "ModelPackageDescription",
		"model_package_group_name":       "ModelPackageGroupName",
		"model_package_name":             "ModelPackageName",
		"model_package_status":           "ModelPackageStatus",
		"model_package_status_details":   "ModelPackageStatusDetails",
		"model_package_version":          "ModelPackageVersion",
		"model_quality":                  "ModelQuality",
		"name":                           "Name",
		"nearest_model_name":             "NearestModelName",
		"post_training_constraints":      "PostTrainingConstraints",
		"post_training_report":           "PostTrainingReport",
		"pre_training_constraints":       "PreTrainingConstraints",
		"pre_training_report":            "PreTrainingReport",
		"profile_name":                   "ProfileName",
		"project_id":                     "ProjectId",
		"report":                         "Report",
		"repository":                     "Repository",
		"s3_data_source":                 "S3DataSource",
		"s3_data_type":                   "S3DataType",
		"s3_output_path":                 "S3OutputPath",
		"s3_uri":                         "S3Uri",
		"sample_payload_url":             "SamplePayloadUrl",
		"source_algorithm_specification": "SourceAlgorithmSpecification",
		"source_algorithms":              "SourceAlgorithms",
		"split_type":                     "SplitType",
		"statistics":                     "Statistics",
		"status":                         "Status",
		"supported_content_types":        "SupportedContentTypes",
		"supported_realtime_inference_instance_types": "SupportedRealtimeInferenceInstanceTypes",
		"supported_response_mime_types":               "SupportedResponseMIMETypes",
		"supported_transform_instance_types":          "SupportedTransformInstanceTypes",
		"tags":                                        "Tags",
		"task":                                        "Task",
		"transform_input":                             "TransformInput",
		"transform_job_definition":                    "TransformJobDefinition",
		"transform_output":                            "TransformOutput",
		"transform_resources":                         "TransformResources",
		"validation_profiles":                         "ValidationProfiles",
		"validation_role":                             "ValidationRole",
		"validation_specification":                    "ValidationSpecification",
		"validation_statuses":                         "ValidationStatuses",
		"value":                                       "Value",
		"volume_kms_key_id":                           "VolumeKmsKeyId",
	})

	opts = opts.WithWriteOnlyPropertyPaths([]string{
		"/properties/ClientToken",
		"/properties/AdditionalInferenceSpecificationsToAdd",
	})
	opts = opts.WithCreateTimeoutInMinutes(0).WithDeleteTimeoutInMinutes(0)

	opts = opts.WithUpdateTimeoutInMinutes(0)

	v, err := generic.NewResource(ctx, opts...)

	if err != nil {
		return nil, err
	}

	return v, nil
}
