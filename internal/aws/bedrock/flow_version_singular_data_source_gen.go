// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// Code generated by generators/singular-data-source/main.go; DO NOT EDIT.

package bedrock

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework-jsontypes/jsontypes"
	"github.com/hashicorp/terraform-plugin-framework-timetypes/timetypes"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-provider-awscc/internal/generic"
	"github.com/hashicorp/terraform-provider-awscc/internal/registry"
)

func init() {
	registry.AddDataSourceFactory("awscc_bedrock_flow_version", flowVersionDataSource)
}

// flowVersionDataSource returns the Terraform awscc_bedrock_flow_version data source.
// This Terraform data source corresponds to the CloudFormation AWS::Bedrock::FlowVersion resource.
func flowVersionDataSource(ctx context.Context) (datasource.DataSource, error) {
	attributes := map[string]schema.Attribute{ /*START SCHEMA*/
		// Property: CreatedAt
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "Time Stamp.",
		//	  "format": "date-time",
		//	  "type": "string"
		//	}
		"created_at": schema.StringAttribute{ /*START ATTRIBUTE*/
			CustomType:  timetypes.RFC3339Type{},
			Description: "Time Stamp.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: Definition
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "Flow definition",
		//	  "properties": {
		//	    "Connections": {
		//	      "description": "List of connections",
		//	      "insertionOrder": true,
		//	      "items": {
		//	        "additionalProperties": false,
		//	        "description": "Flow connection",
		//	        "properties": {
		//	          "Configuration": {
		//	            "description": "Connection configuration",
		//	            "properties": {
		//	              "Conditional": {
		//	                "additionalProperties": false,
		//	                "description": "Conditional connection configuration",
		//	                "properties": {
		//	                  "Condition": {
		//	                    "description": "Name of a condition in a flow",
		//	                    "pattern": "^[a-zA-Z]([_]?[0-9a-zA-Z]){1,50}$",
		//	                    "type": "string"
		//	                  }
		//	                },
		//	                "required": [
		//	                  "Condition"
		//	                ],
		//	                "type": "object"
		//	              },
		//	              "Data": {
		//	                "additionalProperties": false,
		//	                "description": "Data connection configuration",
		//	                "properties": {
		//	                  "SourceOutput": {
		//	                    "description": "Name of a node output in a flow",
		//	                    "pattern": "^[a-zA-Z]([_]?[0-9a-zA-Z]){1,50}$",
		//	                    "type": "string"
		//	                  },
		//	                  "TargetInput": {
		//	                    "description": "Name of a node input in a flow",
		//	                    "pattern": "^[a-zA-Z]([_]?[0-9a-zA-Z]){1,50}$",
		//	                    "type": "string"
		//	                  }
		//	                },
		//	                "required": [
		//	                  "SourceOutput",
		//	                  "TargetInput"
		//	                ],
		//	                "type": "object"
		//	              }
		//	            },
		//	            "type": "object"
		//	          },
		//	          "Name": {
		//	            "description": "Name of a connection in a flow",
		//	            "pattern": "^[a-zA-Z]([_]?[0-9a-zA-Z]){1,100}$",
		//	            "type": "string"
		//	          },
		//	          "Source": {
		//	            "description": "Name of a node in a flow",
		//	            "pattern": "^[a-zA-Z]([_]?[0-9a-zA-Z]){1,50}$",
		//	            "type": "string"
		//	          },
		//	          "Target": {
		//	            "description": "Name of a node in a flow",
		//	            "pattern": "^[a-zA-Z]([_]?[0-9a-zA-Z]){1,50}$",
		//	            "type": "string"
		//	          },
		//	          "Type": {
		//	            "description": "Connection type",
		//	            "enum": [
		//	              "Data",
		//	              "Conditional"
		//	            ],
		//	            "type": "string"
		//	          }
		//	        },
		//	        "required": [
		//	          "Name",
		//	          "Source",
		//	          "Target",
		//	          "Type"
		//	        ],
		//	        "type": "object"
		//	      },
		//	      "maxItems": 20,
		//	      "type": "array"
		//	    },
		//	    "Nodes": {
		//	      "description": "List of nodes in a flow",
		//	      "insertionOrder": true,
		//	      "items": {
		//	        "additionalProperties": false,
		//	        "description": "Internal mixin for flow node",
		//	        "properties": {
		//	          "Configuration": {
		//	            "description": "Node configuration in a flow",
		//	            "properties": {
		//	              "Condition": {
		//	                "additionalProperties": false,
		//	                "description": "Condition flow node configuration",
		//	                "properties": {
		//	                  "Conditions": {
		//	                    "description": "List of conditions in a condition node",
		//	                    "insertionOrder": true,
		//	                    "items": {
		//	                      "additionalProperties": false,
		//	                      "description": "Condition branch for a condition node",
		//	                      "properties": {
		//	                        "Expression": {
		//	                          "description": "Expression for a condition in a flow",
		//	                          "maxLength": 64,
		//	                          "minLength": 1,
		//	                          "type": "string"
		//	                        },
		//	                        "Name": {
		//	                          "description": "Name of a condition in a flow",
		//	                          "pattern": "^[a-zA-Z]([_]?[0-9a-zA-Z]){1,50}$",
		//	                          "type": "string"
		//	                        }
		//	                      },
		//	                      "required": [
		//	                        "Name"
		//	                      ],
		//	                      "type": "object"
		//	                    },
		//	                    "maxItems": 5,
		//	                    "minItems": 1,
		//	                    "type": "array"
		//	                  }
		//	                },
		//	                "required": [
		//	                  "Conditions"
		//	                ],
		//	                "type": "object"
		//	              },
		//	              "Input": {
		//	                "additionalProperties": false,
		//	                "description": "Input flow node configuration",
		//	                "type": "object"
		//	              },
		//	              "KnowledgeBase": {
		//	                "additionalProperties": false,
		//	                "description": "Knowledge base flow node configuration",
		//	                "properties": {
		//	                  "KnowledgeBaseId": {
		//	                    "description": "Identifier of the KnowledgeBase",
		//	                    "maxLength": 10,
		//	                    "pattern": "^[0-9a-zA-Z]+$",
		//	                    "type": "string"
		//	                  },
		//	                  "ModelId": {
		//	                    "description": "ARN or name of a Bedrock model.",
		//	                    "maxLength": 2048,
		//	                    "minLength": 1,
		//	                    "pattern": "^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}(([:][a-z0-9-]{1,63}){0,2})?/[a-z0-9]{12})|(:foundation-model/([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.]?[a-z0-9-]{1,63})([:][a-z0-9-]{1,63}){0,2})))|(([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.]?[a-z0-9-]{1,63})([:][a-z0-9-]{1,63}){0,2}))|(([0-9a-zA-Z][_-]?)+)$",
		//	                    "type": "string"
		//	                  }
		//	                },
		//	                "required": [
		//	                  "KnowledgeBaseId"
		//	                ],
		//	                "type": "object"
		//	              },
		//	              "LambdaFunction": {
		//	                "additionalProperties": false,
		//	                "description": "Lambda function flow node configuration",
		//	                "properties": {
		//	                  "LambdaArn": {
		//	                    "description": "ARN of a Lambda.",
		//	                    "maxLength": 2048,
		//	                    "pattern": "^arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\\d{1}:\\d{12}:function:[a-zA-Z0-9-_\\.]+(:(\\$LATEST|[a-zA-Z0-9-_]+))?$",
		//	                    "type": "string"
		//	                  }
		//	                },
		//	                "required": [
		//	                  "LambdaArn"
		//	                ],
		//	                "type": "object"
		//	              },
		//	              "Lex": {
		//	                "additionalProperties": false,
		//	                "description": "Lex flow node configuration",
		//	                "properties": {
		//	                  "BotAliasArn": {
		//	                    "description": "ARN of a Lex bot alias",
		//	                    "maxLength": 78,
		//	                    "pattern": "^arn:aws(|-us-gov):lex:[a-z]{2}(-gov)?-[a-z]+-\\d{1}:\\d{12}:bot-alias/[0-9a-zA-Z]+/[0-9a-zA-Z]+$",
		//	                    "type": "string"
		//	                  },
		//	                  "LocaleId": {
		//	                    "description": "Lex bot locale id",
		//	                    "maxLength": 10,
		//	                    "minLength": 1,
		//	                    "type": "string"
		//	                  }
		//	                },
		//	                "required": [
		//	                  "BotAliasArn",
		//	                  "LocaleId"
		//	                ],
		//	                "type": "object"
		//	              },
		//	              "Output": {
		//	                "additionalProperties": false,
		//	                "description": "Output flow node configuration",
		//	                "type": "object"
		//	              },
		//	              "Prompt": {
		//	                "additionalProperties": false,
		//	                "description": "Prompt flow node configuration",
		//	                "properties": {
		//	                  "SourceConfiguration": {
		//	                    "description": "Prompt source configuration for prompt node",
		//	                    "properties": {
		//	                      "Inline": {
		//	                        "additionalProperties": false,
		//	                        "description": "Inline prompt configuration for prompt node",
		//	                        "properties": {
		//	                          "InferenceConfiguration": {
		//	                            "description": "Model inference configuration",
		//	                            "properties": {
		//	                              "Text": {
		//	                                "additionalProperties": false,
		//	                                "description": "Prompt model inference configuration",
		//	                                "properties": {
		//	                                  "MaxTokens": {
		//	                                    "description": "Maximum length of output",
		//	                                    "maximum": 4096,
		//	                                    "minimum": 0,
		//	                                    "type": "number"
		//	                                  },
		//	                                  "StopSequences": {
		//	                                    "description": "List of stop sequences",
		//	                                    "insertionOrder": true,
		//	                                    "items": {
		//	                                      "type": "string"
		//	                                    },
		//	                                    "maxItems": 4,
		//	                                    "minItems": 0,
		//	                                    "type": "array"
		//	                                  },
		//	                                  "Temperature": {
		//	                                    "description": "Controls randomness, higher values increase diversity",
		//	                                    "maximum": 1,
		//	                                    "minimum": 0,
		//	                                    "type": "number"
		//	                                  },
		//	                                  "TopK": {
		//	                                    "description": "Sample from the k most likely next tokens",
		//	                                    "maximum": 500,
		//	                                    "minimum": 0,
		//	                                    "type": "number"
		//	                                  },
		//	                                  "TopP": {
		//	                                    "description": "Cumulative probability cutoff for token selection",
		//	                                    "maximum": 1,
		//	                                    "minimum": 0,
		//	                                    "type": "number"
		//	                                  }
		//	                                },
		//	                                "type": "object"
		//	                              }
		//	                            },
		//	                            "type": "object"
		//	                          },
		//	                          "ModelId": {
		//	                            "description": "ARN or name of a Bedrock model.",
		//	                            "maxLength": 2048,
		//	                            "minLength": 1,
		//	                            "pattern": "^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}/[a-z0-9]{12})|(:foundation-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.:]?[a-z0-9-]{1,63}))|([0-9]{12}:provisioned-model/[a-z0-9]{12})))|([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.:]?[a-z0-9-]{1,63}))|(([0-9a-zA-Z][_-]?)+)$",
		//	                            "type": "string"
		//	                          },
		//	                          "TemplateConfiguration": {
		//	                            "description": "Prompt template configuration",
		//	                            "properties": {
		//	                              "Text": {
		//	                                "additionalProperties": false,
		//	                                "description": "Configuration for text prompt template",
		//	                                "properties": {
		//	                                  "InputVariables": {
		//	                                    "description": "List of input variables",
		//	                                    "insertionOrder": true,
		//	                                    "items": {
		//	                                      "additionalProperties": false,
		//	                                      "description": "Input variable",
		//	                                      "properties": {
		//	                                        "Name": {
		//	                                          "description": "Name for an input variable",
		//	                                          "pattern": "^([0-9a-zA-Z][_-]?){1,100}$",
		//	                                          "type": "string"
		//	                                        }
		//	                                      },
		//	                                      "type": "object"
		//	                                    },
		//	                                    "maxItems": 5,
		//	                                    "minItems": 0,
		//	                                    "type": "array"
		//	                                  },
		//	                                  "Text": {
		//	                                    "description": "Prompt content for String prompt template",
		//	                                    "maxLength": 200000,
		//	                                    "minLength": 1,
		//	                                    "type": "string"
		//	                                  }
		//	                                },
		//	                                "required": [
		//	                                  "Text"
		//	                                ],
		//	                                "type": "object"
		//	                              }
		//	                            },
		//	                            "type": "object"
		//	                          },
		//	                          "TemplateType": {
		//	                            "description": "Prompt template type",
		//	                            "enum": [
		//	                              "TEXT"
		//	                            ],
		//	                            "type": "string"
		//	                          }
		//	                        },
		//	                        "required": [
		//	                          "ModelId",
		//	                          "TemplateConfiguration",
		//	                          "TemplateType"
		//	                        ],
		//	                        "type": "object"
		//	                      },
		//	                      "Resource": {
		//	                        "additionalProperties": false,
		//	                        "description": "Resource prompt configuration for prompt node",
		//	                        "properties": {
		//	                          "PromptArn": {
		//	                            "description": "ARN of a prompt resource possibly with a version",
		//	                            "pattern": "^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:prompt/[0-9a-zA-Z]{10}(?::[0-9]{1,5})?)$",
		//	                            "type": "string"
		//	                          }
		//	                        },
		//	                        "required": [
		//	                          "PromptArn"
		//	                        ],
		//	                        "type": "object"
		//	                      }
		//	                    },
		//	                    "type": "object"
		//	                  }
		//	                },
		//	                "required": [
		//	                  "SourceConfiguration"
		//	                ],
		//	                "type": "object"
		//	              }
		//	            },
		//	            "type": "object"
		//	          },
		//	          "Inputs": {
		//	            "description": "List of node inputs in a flow",
		//	            "insertionOrder": true,
		//	            "items": {
		//	              "additionalProperties": false,
		//	              "description": "Input to a node in a flow",
		//	              "properties": {
		//	                "Expression": {
		//	                  "description": "Expression for a node input in a flow",
		//	                  "maxLength": 64,
		//	                  "minLength": 1,
		//	                  "type": "string"
		//	                },
		//	                "Name": {
		//	                  "description": "Name of a node input in a flow",
		//	                  "pattern": "^[a-zA-Z]([_]?[0-9a-zA-Z]){1,50}$",
		//	                  "type": "string"
		//	                },
		//	                "Type": {
		//	                  "description": "Type of input/output for a node in a flow",
		//	                  "enum": [
		//	                    "String",
		//	                    "Number",
		//	                    "Boolean",
		//	                    "Object",
		//	                    "Array"
		//	                  ],
		//	                  "type": "string"
		//	                }
		//	              },
		//	              "required": [
		//	                "Expression",
		//	                "Name",
		//	                "Type"
		//	              ],
		//	              "type": "object"
		//	            },
		//	            "maxItems": 5,
		//	            "type": "array"
		//	          },
		//	          "Name": {
		//	            "description": "Name of a node in a flow",
		//	            "pattern": "^[a-zA-Z]([_]?[0-9a-zA-Z]){1,50}$",
		//	            "type": "string"
		//	          },
		//	          "Outputs": {
		//	            "description": "List of node outputs in a flow",
		//	            "insertionOrder": true,
		//	            "items": {
		//	              "additionalProperties": false,
		//	              "description": "Output of a node in a flow",
		//	              "properties": {
		//	                "Name": {
		//	                  "description": "Name of a node output in a flow",
		//	                  "pattern": "^[a-zA-Z]([_]?[0-9a-zA-Z]){1,50}$",
		//	                  "type": "string"
		//	                },
		//	                "Type": {
		//	                  "description": "Type of input/output for a node in a flow",
		//	                  "enum": [
		//	                    "String",
		//	                    "Number",
		//	                    "Boolean",
		//	                    "Object",
		//	                    "Array"
		//	                  ],
		//	                  "type": "string"
		//	                }
		//	              },
		//	              "required": [
		//	                "Name",
		//	                "Type"
		//	              ],
		//	              "type": "object"
		//	            },
		//	            "maxItems": 5,
		//	            "type": "array"
		//	          },
		//	          "Type": {
		//	            "description": "Flow node types",
		//	            "enum": [
		//	              "Input",
		//	              "Output",
		//	              "KnowledgeBase",
		//	              "Condition",
		//	              "Lex",
		//	              "Prompt",
		//	              "LambdaFunction"
		//	            ],
		//	            "type": "string"
		//	          }
		//	        },
		//	        "required": [
		//	          "Name",
		//	          "Type"
		//	        ],
		//	        "type": "object"
		//	      },
		//	      "maxItems": 20,
		//	      "type": "array"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"definition": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: Connections
				"connections": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
					NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: Configuration
							"configuration": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
								Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
									// Property: Conditional
									"conditional": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
										Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
											// Property: Condition
											"condition": schema.StringAttribute{ /*START ATTRIBUTE*/
												Description: "Name of a condition in a flow",
												Computed:    true,
											}, /*END ATTRIBUTE*/
										}, /*END SCHEMA*/
										Description: "Conditional connection configuration",
										Computed:    true,
									}, /*END ATTRIBUTE*/
									// Property: Data
									"data": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
										Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
											// Property: SourceOutput
											"source_output": schema.StringAttribute{ /*START ATTRIBUTE*/
												Description: "Name of a node output in a flow",
												Computed:    true,
											}, /*END ATTRIBUTE*/
											// Property: TargetInput
											"target_input": schema.StringAttribute{ /*START ATTRIBUTE*/
												Description: "Name of a node input in a flow",
												Computed:    true,
											}, /*END ATTRIBUTE*/
										}, /*END SCHEMA*/
										Description: "Data connection configuration",
										Computed:    true,
									}, /*END ATTRIBUTE*/
								}, /*END SCHEMA*/
								Description: "Connection configuration",
								Computed:    true,
							}, /*END ATTRIBUTE*/
							// Property: Name
							"name": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "Name of a connection in a flow",
								Computed:    true,
							}, /*END ATTRIBUTE*/
							// Property: Source
							"source": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "Name of a node in a flow",
								Computed:    true,
							}, /*END ATTRIBUTE*/
							// Property: Target
							"target": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "Name of a node in a flow",
								Computed:    true,
							}, /*END ATTRIBUTE*/
							// Property: Type
							"type": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "Connection type",
								Computed:    true,
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
					}, /*END NESTED OBJECT*/
					Description: "List of connections",
					Computed:    true,
				}, /*END ATTRIBUTE*/
				// Property: Nodes
				"nodes": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
					NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: Configuration
							"configuration": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
								Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
									// Property: Condition
									"condition": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
										Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
											// Property: Conditions
											"conditions": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
												NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
													Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
														// Property: Expression
														"expression": schema.StringAttribute{ /*START ATTRIBUTE*/
															Description: "Expression for a condition in a flow",
															Computed:    true,
														}, /*END ATTRIBUTE*/
														// Property: Name
														"name": schema.StringAttribute{ /*START ATTRIBUTE*/
															Description: "Name of a condition in a flow",
															Computed:    true,
														}, /*END ATTRIBUTE*/
													}, /*END SCHEMA*/
												}, /*END NESTED OBJECT*/
												Description: "List of conditions in a condition node",
												Computed:    true,
											}, /*END ATTRIBUTE*/
										}, /*END SCHEMA*/
										Description: "Condition flow node configuration",
										Computed:    true,
									}, /*END ATTRIBUTE*/
									// Property: Input
									"input": schema.StringAttribute{ /*START ATTRIBUTE*/
										CustomType:  jsontypes.NormalizedType{},
										Description: "Input flow node configuration",
										Computed:    true,
									}, /*END ATTRIBUTE*/
									// Property: KnowledgeBase
									"knowledge_base": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
										Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
											// Property: KnowledgeBaseId
											"knowledge_base_id": schema.StringAttribute{ /*START ATTRIBUTE*/
												Description: "Identifier of the KnowledgeBase",
												Computed:    true,
											}, /*END ATTRIBUTE*/
											// Property: ModelId
											"model_id": schema.StringAttribute{ /*START ATTRIBUTE*/
												Description: "ARN or name of a Bedrock model.",
												Computed:    true,
											}, /*END ATTRIBUTE*/
										}, /*END SCHEMA*/
										Description: "Knowledge base flow node configuration",
										Computed:    true,
									}, /*END ATTRIBUTE*/
									// Property: LambdaFunction
									"lambda_function": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
										Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
											// Property: LambdaArn
											"lambda_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
												Description: "ARN of a Lambda.",
												Computed:    true,
											}, /*END ATTRIBUTE*/
										}, /*END SCHEMA*/
										Description: "Lambda function flow node configuration",
										Computed:    true,
									}, /*END ATTRIBUTE*/
									// Property: Lex
									"lex": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
										Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
											// Property: BotAliasArn
											"bot_alias_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
												Description: "ARN of a Lex bot alias",
												Computed:    true,
											}, /*END ATTRIBUTE*/
											// Property: LocaleId
											"locale_id": schema.StringAttribute{ /*START ATTRIBUTE*/
												Description: "Lex bot locale id",
												Computed:    true,
											}, /*END ATTRIBUTE*/
										}, /*END SCHEMA*/
										Description: "Lex flow node configuration",
										Computed:    true,
									}, /*END ATTRIBUTE*/
									// Property: Output
									"output": schema.StringAttribute{ /*START ATTRIBUTE*/
										CustomType:  jsontypes.NormalizedType{},
										Description: "Output flow node configuration",
										Computed:    true,
									}, /*END ATTRIBUTE*/
									// Property: Prompt
									"prompt": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
										Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
											// Property: SourceConfiguration
											"source_configuration": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
												Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
													// Property: Inline
													"inline": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
														Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
															// Property: InferenceConfiguration
															"inference_configuration": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
																Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
																	// Property: Text
																	"text": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
																		Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
																			// Property: MaxTokens
																			"max_tokens": schema.Float64Attribute{ /*START ATTRIBUTE*/
																				Description: "Maximum length of output",
																				Computed:    true,
																			}, /*END ATTRIBUTE*/
																			// Property: StopSequences
																			"stop_sequences": schema.ListAttribute{ /*START ATTRIBUTE*/
																				ElementType: types.StringType,
																				Description: "List of stop sequences",
																				Computed:    true,
																			}, /*END ATTRIBUTE*/
																			// Property: Temperature
																			"temperature": schema.Float64Attribute{ /*START ATTRIBUTE*/
																				Description: "Controls randomness, higher values increase diversity",
																				Computed:    true,
																			}, /*END ATTRIBUTE*/
																			// Property: TopK
																			"top_k": schema.Float64Attribute{ /*START ATTRIBUTE*/
																				Description: "Sample from the k most likely next tokens",
																				Computed:    true,
																			}, /*END ATTRIBUTE*/
																			// Property: TopP
																			"top_p": schema.Float64Attribute{ /*START ATTRIBUTE*/
																				Description: "Cumulative probability cutoff for token selection",
																				Computed:    true,
																			}, /*END ATTRIBUTE*/
																		}, /*END SCHEMA*/
																		Description: "Prompt model inference configuration",
																		Computed:    true,
																	}, /*END ATTRIBUTE*/
																}, /*END SCHEMA*/
																Description: "Model inference configuration",
																Computed:    true,
															}, /*END ATTRIBUTE*/
															// Property: ModelId
															"model_id": schema.StringAttribute{ /*START ATTRIBUTE*/
																Description: "ARN or name of a Bedrock model.",
																Computed:    true,
															}, /*END ATTRIBUTE*/
															// Property: TemplateConfiguration
															"template_configuration": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
																Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
																	// Property: Text
																	"text": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
																		Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
																			// Property: InputVariables
																			"input_variables": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
																				NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
																					Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
																						// Property: Name
																						"name": schema.StringAttribute{ /*START ATTRIBUTE*/
																							Description: "Name for an input variable",
																							Computed:    true,
																						}, /*END ATTRIBUTE*/
																					}, /*END SCHEMA*/
																				}, /*END NESTED OBJECT*/
																				Description: "List of input variables",
																				Computed:    true,
																			}, /*END ATTRIBUTE*/
																			// Property: Text
																			"text": schema.StringAttribute{ /*START ATTRIBUTE*/
																				Description: "Prompt content for String prompt template",
																				Computed:    true,
																			}, /*END ATTRIBUTE*/
																		}, /*END SCHEMA*/
																		Description: "Configuration for text prompt template",
																		Computed:    true,
																	}, /*END ATTRIBUTE*/
																}, /*END SCHEMA*/
																Description: "Prompt template configuration",
																Computed:    true,
															}, /*END ATTRIBUTE*/
															// Property: TemplateType
															"template_type": schema.StringAttribute{ /*START ATTRIBUTE*/
																Description: "Prompt template type",
																Computed:    true,
															}, /*END ATTRIBUTE*/
														}, /*END SCHEMA*/
														Description: "Inline prompt configuration for prompt node",
														Computed:    true,
													}, /*END ATTRIBUTE*/
													// Property: Resource
													"resource": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
														Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
															// Property: PromptArn
															"prompt_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
																Description: "ARN of a prompt resource possibly with a version",
																Computed:    true,
															}, /*END ATTRIBUTE*/
														}, /*END SCHEMA*/
														Description: "Resource prompt configuration for prompt node",
														Computed:    true,
													}, /*END ATTRIBUTE*/
												}, /*END SCHEMA*/
												Description: "Prompt source configuration for prompt node",
												Computed:    true,
											}, /*END ATTRIBUTE*/
										}, /*END SCHEMA*/
										Description: "Prompt flow node configuration",
										Computed:    true,
									}, /*END ATTRIBUTE*/
								}, /*END SCHEMA*/
								Description: "Node configuration in a flow",
								Computed:    true,
							}, /*END ATTRIBUTE*/
							// Property: Inputs
							"inputs": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
								NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
									Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
										// Property: Expression
										"expression": schema.StringAttribute{ /*START ATTRIBUTE*/
											Description: "Expression for a node input in a flow",
											Computed:    true,
										}, /*END ATTRIBUTE*/
										// Property: Name
										"name": schema.StringAttribute{ /*START ATTRIBUTE*/
											Description: "Name of a node input in a flow",
											Computed:    true,
										}, /*END ATTRIBUTE*/
										// Property: Type
										"type": schema.StringAttribute{ /*START ATTRIBUTE*/
											Description: "Type of input/output for a node in a flow",
											Computed:    true,
										}, /*END ATTRIBUTE*/
									}, /*END SCHEMA*/
								}, /*END NESTED OBJECT*/
								Description: "List of node inputs in a flow",
								Computed:    true,
							}, /*END ATTRIBUTE*/
							// Property: Name
							"name": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "Name of a node in a flow",
								Computed:    true,
							}, /*END ATTRIBUTE*/
							// Property: Outputs
							"outputs": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
								NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
									Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
										// Property: Name
										"name": schema.StringAttribute{ /*START ATTRIBUTE*/
											Description: "Name of a node output in a flow",
											Computed:    true,
										}, /*END ATTRIBUTE*/
										// Property: Type
										"type": schema.StringAttribute{ /*START ATTRIBUTE*/
											Description: "Type of input/output for a node in a flow",
											Computed:    true,
										}, /*END ATTRIBUTE*/
									}, /*END SCHEMA*/
								}, /*END NESTED OBJECT*/
								Description: "List of node outputs in a flow",
								Computed:    true,
							}, /*END ATTRIBUTE*/
							// Property: Type
							"type": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "Flow node types",
								Computed:    true,
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
					}, /*END NESTED OBJECT*/
					Description: "List of nodes in a flow",
					Computed:    true,
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "Flow definition",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: Description
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "Description of the flow version",
		//	  "maxLength": 200,
		//	  "minLength": 1,
		//	  "type": "string"
		//	}
		"description": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "Description of the flow version",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: ExecutionRoleArn
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "ARN of a IAM role",
		//	  "maxLength": 2048,
		//	  "pattern": "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/(service-role/)?.+$",
		//	  "type": "string"
		//	}
		"execution_role_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "ARN of a IAM role",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: FlowArn
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "Arn representation of the Flow",
		//	  "pattern": "^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:flow/[0-9a-zA-Z]{10}$",
		//	  "type": "string"
		//	}
		"flow_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "Arn representation of the Flow",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: FlowId
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "Identifier for a Flow",
		//	  "pattern": "^[0-9a-zA-Z]{10}$",
		//	  "type": "string"
		//	}
		"flow_id": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "Identifier for a Flow",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: Name
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "Name for the flow",
		//	  "pattern": "^([0-9a-zA-Z][_-]?){1,100}$",
		//	  "type": "string"
		//	}
		"name": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "Name for the flow",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: Status
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "Schema Type for Flow APIs",
		//	  "enum": [
		//	    "Failed",
		//	    "Prepared",
		//	    "Preparing",
		//	    "NotPrepared"
		//	  ],
		//	  "type": "string"
		//	}
		"status": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "Schema Type for Flow APIs",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: Version
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "Numerical Version.",
		//	  "pattern": "^[0-9]{1,5}$",
		//	  "type": "string"
		//	}
		"version": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "Numerical Version.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
	} /*END SCHEMA*/

	attributes["id"] = schema.StringAttribute{
		Description: "Uniquely identifies the resource.",
		Required:    true,
	}

	schema := schema.Schema{
		Description: "Data Source schema for AWS::Bedrock::FlowVersion",
		Attributes:  attributes,
	}

	var opts generic.DataSourceOptions

	opts = opts.WithCloudFormationTypeName("AWS::Bedrock::FlowVersion").WithTerraformTypeName("awscc_bedrock_flow_version")
	opts = opts.WithTerraformSchema(schema)
	opts = opts.WithAttributeNameMap(map[string]string{
		"bot_alias_arn":           "BotAliasArn",
		"condition":               "Condition",
		"conditional":             "Conditional",
		"conditions":              "Conditions",
		"configuration":           "Configuration",
		"connections":             "Connections",
		"created_at":              "CreatedAt",
		"data":                    "Data",
		"definition":              "Definition",
		"description":             "Description",
		"execution_role_arn":      "ExecutionRoleArn",
		"expression":              "Expression",
		"flow_arn":                "FlowArn",
		"flow_id":                 "FlowId",
		"inference_configuration": "InferenceConfiguration",
		"inline":                  "Inline",
		"input":                   "Input",
		"input_variables":         "InputVariables",
		"inputs":                  "Inputs",
		"knowledge_base":          "KnowledgeBase",
		"knowledge_base_id":       "KnowledgeBaseId",
		"lambda_arn":              "LambdaArn",
		"lambda_function":         "LambdaFunction",
		"lex":                     "Lex",
		"locale_id":               "LocaleId",
		"max_tokens":              "MaxTokens",
		"model_id":                "ModelId",
		"name":                    "Name",
		"nodes":                   "Nodes",
		"output":                  "Output",
		"outputs":                 "Outputs",
		"prompt":                  "Prompt",
		"prompt_arn":              "PromptArn",
		"resource":                "Resource",
		"source":                  "Source",
		"source_configuration":    "SourceConfiguration",
		"source_output":           "SourceOutput",
		"status":                  "Status",
		"stop_sequences":          "StopSequences",
		"target":                  "Target",
		"target_input":            "TargetInput",
		"temperature":             "Temperature",
		"template_configuration":  "TemplateConfiguration",
		"template_type":           "TemplateType",
		"text":                    "Text",
		"top_k":                   "TopK",
		"top_p":                   "TopP",
		"type":                    "Type",
		"version":                 "Version",
	})

	v, err := generic.NewSingularDataSource(ctx, opts...)

	if err != nil {
		return nil, err
	}

	return v, nil
}
