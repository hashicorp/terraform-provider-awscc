// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// Code generated by generators/resource/main.go; DO NOT EDIT.

package medialive

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-provider-awscc/internal/generic"
	"github.com/hashicorp/terraform-provider-awscc/internal/registry"
	fwvalidators "github.com/hashicorp/terraform-provider-awscc/internal/validators"
)

func init() {
	registry.AddResourceFactory("awscc_medialive_multiplexprogram", multiplexprogramResource)
}

// multiplexprogramResource returns the Terraform awscc_medialive_multiplexprogram resource.
// This Terraform resource corresponds to the CloudFormation AWS::MediaLive::Multiplexprogram resource.
func multiplexprogramResource(ctx context.Context) (resource.Resource, error) {
	attributes := map[string]schema.Attribute{ /*START SCHEMA*/
		// Property: ChannelId
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The MediaLive channel associated with the program.",
		//	  "type": "string"
		//	}
		"channel_id": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The MediaLive channel associated with the program.",
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: MultiplexId
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The ID of the multiplex that the program belongs to.",
		//	  "type": "string"
		//	}
		"multiplex_id": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The ID of the multiplex that the program belongs to.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
				stringplanmodifier.RequiresReplaceIfConfigured(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: MultiplexProgramSettings
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "The settings for this multiplex program.",
		//	  "properties": {
		//	    "PreferredChannelPipeline": {
		//	      "description": "Indicates which pipeline is preferred by the multiplex for program ingest.\nIf set to \\\"PIPELINE_0\\\" or \\\"PIPELINE_1\\\" and an unhealthy ingest causes the multiplex to switch to the non-preferred pipeline,\nit will switch back once that ingest is healthy again. If set to \\\"CURRENTLY_ACTIVE\\\",\nit will not switch back to the other pipeline based on it recovering to a healthy state,\nit will only switch if the active pipeline becomes unhealthy.\n",
		//	      "enum": [
		//	        "CURRENTLY_ACTIVE",
		//	        "PIPELINE_0",
		//	        "PIPELINE_1"
		//	      ],
		//	      "type": "string"
		//	    },
		//	    "ProgramNumber": {
		//	      "description": "Unique program number.",
		//	      "maximum": 65535,
		//	      "minimum": 0,
		//	      "type": "integer"
		//	    },
		//	    "ServiceDescriptor": {
		//	      "additionalProperties": false,
		//	      "description": "Transport stream service descriptor configuration for the Multiplex program.",
		//	      "properties": {
		//	        "ProviderName": {
		//	          "description": "Name of the provider.",
		//	          "maxLength": 256,
		//	          "minLength": 1,
		//	          "type": "string"
		//	        },
		//	        "ServiceName": {
		//	          "description": "Name of the service.",
		//	          "maxLength": 256,
		//	          "minLength": 1,
		//	          "type": "string"
		//	        }
		//	      },
		//	      "required": [
		//	        "ProviderName",
		//	        "ServiceName"
		//	      ],
		//	      "type": "object"
		//	    },
		//	    "VideoSettings": {
		//	      "description": "Program video settings configuration.",
		//	      "properties": {
		//	        "ConstantBitrate": {
		//	          "description": "The constant bitrate configuration for the video encode.\nWhen this field is defined, StatmuxSettings must be undefined.",
		//	          "maximum": 100000000,
		//	          "minimum": 100000,
		//	          "type": "integer"
		//	        },
		//	        "StatmuxSettings": {
		//	          "additionalProperties": false,
		//	          "description": "Statmux rate control settings.\nWhen this field is defined, ConstantBitrate must be undefined.",
		//	          "properties": {
		//	            "MaximumBitrate": {
		//	              "description": "Maximum statmux bitrate.",
		//	              "maximum": 100000000,
		//	              "minimum": 100000,
		//	              "type": "integer"
		//	            },
		//	            "MinimumBitrate": {
		//	              "description": "Minimum statmux bitrate.",
		//	              "maximum": 100000000,
		//	              "minimum": 100000,
		//	              "type": "integer"
		//	            },
		//	            "Priority": {
		//	              "description": "The purpose of the priority is to use a combination of the\\nmultiplex rate control algorithm and the QVBR capability of the\\nencoder to prioritize the video quality of some channels in a\\nmultiplex over others.  Channels that have a higher priority will\\nget higher video quality at the expense of the video quality of\\nother channels in the multiplex with lower priority.",
		//	              "maximum": 5,
		//	              "minimum": -5,
		//	              "type": "integer"
		//	            }
		//	          },
		//	          "type": "object"
		//	        }
		//	      },
		//	      "type": "object"
		//	    }
		//	  },
		//	  "required": [
		//	    "ProgramNumber"
		//	  ],
		//	  "type": "object"
		//	}
		"multiplex_program_settings": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: PreferredChannelPipeline
				"preferred_channel_pipeline": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "Indicates which pipeline is preferred by the multiplex for program ingest.\nIf set to \\\"PIPELINE_0\\\" or \\\"PIPELINE_1\\\" and an unhealthy ingest causes the multiplex to switch to the non-preferred pipeline,\nit will switch back once that ingest is healthy again. If set to \\\"CURRENTLY_ACTIVE\\\",\nit will not switch back to the other pipeline based on it recovering to a healthy state,\nit will only switch if the active pipeline becomes unhealthy.\n",
					Optional:    true,
					Computed:    true,
					Validators: []validator.String{ /*START VALIDATORS*/
						stringvalidator.OneOf(
							"CURRENTLY_ACTIVE",
							"PIPELINE_0",
							"PIPELINE_1",
						),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: ProgramNumber
				"program_number": schema.Int64Attribute{ /*START ATTRIBUTE*/
					Description: "Unique program number.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.Int64{ /*START VALIDATORS*/
						int64validator.Between(0, 65535),
						fwvalidators.NotNullInt64(),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
						int64planmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: ServiceDescriptor
				"service_descriptor": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
					Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
						// Property: ProviderName
						"provider_name": schema.StringAttribute{ /*START ATTRIBUTE*/
							Description: "Name of the provider.",
							Optional:    true,
							Computed:    true,
							Validators: []validator.String{ /*START VALIDATORS*/
								stringvalidator.LengthBetween(1, 256),
								fwvalidators.NotNullString(),
							}, /*END VALIDATORS*/
							PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
								stringplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
						// Property: ServiceName
						"service_name": schema.StringAttribute{ /*START ATTRIBUTE*/
							Description: "Name of the service.",
							Optional:    true,
							Computed:    true,
							Validators: []validator.String{ /*START VALIDATORS*/
								stringvalidator.LengthBetween(1, 256),
								fwvalidators.NotNullString(),
							}, /*END VALIDATORS*/
							PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
								stringplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
					}, /*END SCHEMA*/
					Description: "Transport stream service descriptor configuration for the Multiplex program.",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
						objectplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: VideoSettings
				"video_settings": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
					Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
						// Property: ConstantBitrate
						"constant_bitrate": schema.Int64Attribute{ /*START ATTRIBUTE*/
							Description: "The constant bitrate configuration for the video encode.\nWhen this field is defined, StatmuxSettings must be undefined.",
							Optional:    true,
							Computed:    true,
							Validators: []validator.Int64{ /*START VALIDATORS*/
								int64validator.Between(100000, 100000000),
							}, /*END VALIDATORS*/
							PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
								int64planmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
						// Property: StatmuxSettings
						"statmux_settings": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: MaximumBitrate
								"maximum_bitrate": schema.Int64Attribute{ /*START ATTRIBUTE*/
									Description: "Maximum statmux bitrate.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.Int64{ /*START VALIDATORS*/
										int64validator.Between(100000, 100000000),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
										int64planmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: MinimumBitrate
								"minimum_bitrate": schema.Int64Attribute{ /*START ATTRIBUTE*/
									Description: "Minimum statmux bitrate.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.Int64{ /*START VALIDATORS*/
										int64validator.Between(100000, 100000000),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
										int64planmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: Priority
								"priority": schema.Int64Attribute{ /*START ATTRIBUTE*/
									Description: "The purpose of the priority is to use a combination of the\\nmultiplex rate control algorithm and the QVBR capability of the\\nencoder to prioritize the video quality of some channels in a\\nmultiplex over others.  Channels that have a higher priority will\\nget higher video quality at the expense of the video quality of\\nother channels in the multiplex with lower priority.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.Int64{ /*START VALIDATORS*/
										int64validator.Between(-5, 5),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
										int64planmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
							Description: "Statmux rate control settings.\nWhen this field is defined, ConstantBitrate must be undefined.",
							Optional:    true,
							Computed:    true,
							PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
								objectplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
					}, /*END SCHEMA*/
					Description: "Program video settings configuration.",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
						objectplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "The settings for this multiplex program.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: PacketIdentifiersMap
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "The packet identifier map for this multiplex program.",
		//	  "properties": {
		//	    "AudioPids": {
		//	      "insertionOrder": true,
		//	      "items": {
		//	        "type": "integer"
		//	      },
		//	      "type": "array"
		//	    },
		//	    "DvbSubPids": {
		//	      "insertionOrder": true,
		//	      "items": {
		//	        "type": "integer"
		//	      },
		//	      "type": "array"
		//	    },
		//	    "DvbTeletextPid": {
		//	      "type": "integer"
		//	    },
		//	    "EtvPlatformPid": {
		//	      "type": "integer"
		//	    },
		//	    "EtvSignalPid": {
		//	      "type": "integer"
		//	    },
		//	    "KlvDataPids": {
		//	      "insertionOrder": true,
		//	      "items": {
		//	        "type": "integer"
		//	      },
		//	      "type": "array"
		//	    },
		//	    "PcrPid": {
		//	      "type": "integer"
		//	    },
		//	    "PmtPid": {
		//	      "type": "integer"
		//	    },
		//	    "PrivateMetadataPid": {
		//	      "type": "integer"
		//	    },
		//	    "Scte27Pids": {
		//	      "insertionOrder": true,
		//	      "items": {
		//	        "type": "integer"
		//	      },
		//	      "type": "array"
		//	    },
		//	    "Scte35Pid": {
		//	      "type": "integer"
		//	    },
		//	    "TimedMetadataPid": {
		//	      "type": "integer"
		//	    },
		//	    "VideoPid": {
		//	      "type": "integer"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"packet_identifiers_map": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: AudioPids
				"audio_pids": schema.ListAttribute{ /*START ATTRIBUTE*/
					ElementType: types.Int64Type,
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
						listplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: DvbSubPids
				"dvb_sub_pids": schema.ListAttribute{ /*START ATTRIBUTE*/
					ElementType: types.Int64Type,
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
						listplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: DvbTeletextPid
				"dvb_teletext_pid": schema.Int64Attribute{ /*START ATTRIBUTE*/
					Optional: true,
					Computed: true,
					PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
						int64planmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: EtvPlatformPid
				"etv_platform_pid": schema.Int64Attribute{ /*START ATTRIBUTE*/
					Optional: true,
					Computed: true,
					PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
						int64planmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: EtvSignalPid
				"etv_signal_pid": schema.Int64Attribute{ /*START ATTRIBUTE*/
					Optional: true,
					Computed: true,
					PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
						int64planmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: KlvDataPids
				"klv_data_pids": schema.ListAttribute{ /*START ATTRIBUTE*/
					ElementType: types.Int64Type,
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
						listplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: PcrPid
				"pcr_pid": schema.Int64Attribute{ /*START ATTRIBUTE*/
					Optional: true,
					Computed: true,
					PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
						int64planmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: PmtPid
				"pmt_pid": schema.Int64Attribute{ /*START ATTRIBUTE*/
					Optional: true,
					Computed: true,
					PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
						int64planmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: PrivateMetadataPid
				"private_metadata_pid": schema.Int64Attribute{ /*START ATTRIBUTE*/
					Optional: true,
					Computed: true,
					PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
						int64planmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: Scte27Pids
				"scte_27_pids": schema.ListAttribute{ /*START ATTRIBUTE*/
					ElementType: types.Int64Type,
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
						listplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: Scte35Pid
				"scte_35_pid": schema.Int64Attribute{ /*START ATTRIBUTE*/
					Optional: true,
					Computed: true,
					PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
						int64planmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: TimedMetadataPid
				"timed_metadata_pid": schema.Int64Attribute{ /*START ATTRIBUTE*/
					Optional: true,
					Computed: true,
					PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
						int64planmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: VideoPid
				"video_pid": schema.Int64Attribute{ /*START ATTRIBUTE*/
					Optional: true,
					Computed: true,
					PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
						int64planmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "The packet identifier map for this multiplex program.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: PipelineDetails
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "Contains information about the current sources for the specified program in the specified multiplex. Keep in mind that each multiplex pipeline connects to both pipelines in a given source channel (the channel identified by the program). But only one of those channel pipelines is ever active at one time.",
		//	  "insertionOrder": true,
		//	  "items": {
		//	    "additionalProperties": false,
		//	    "description": "The current source for one of the pipelines in the multiplex.",
		//	    "properties": {
		//	      "ActiveChannelPipeline": {
		//	        "description": "Identifies the channel pipeline that is currently active for the pipeline (identified by PipelineId) in the multiplex.",
		//	        "type": "string"
		//	      },
		//	      "PipelineId": {
		//	        "description": "Identifies a specific pipeline in the multiplex.",
		//	        "type": "string"
		//	      }
		//	    },
		//	    "type": "object"
		//	  },
		//	  "type": "array"
		//	}
		"pipeline_details": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: ActiveChannelPipeline
					"active_channel_pipeline": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "Identifies the channel pipeline that is currently active for the pipeline (identified by PipelineId) in the multiplex.",
						Optional:    true,
						Computed:    true,
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: PipelineId
					"pipeline_id": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "Identifies a specific pipeline in the multiplex.",
						Optional:    true,
						Computed:    true,
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Description: "Contains information about the current sources for the specified program in the specified multiplex. Keep in mind that each multiplex pipeline connects to both pipelines in a given source channel (the channel identified by the program). But only one of those channel pipelines is ever active at one time.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
				listplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: PreferredChannelPipeline
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The settings for this multiplex program.",
		//	  "enum": [
		//	    "CURRENTLY_ACTIVE",
		//	    "PIPELINE_0",
		//	    "PIPELINE_1"
		//	  ],
		//	  "type": "string"
		//	}
		"preferred_channel_pipeline": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The settings for this multiplex program.",
			Optional:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.OneOf(
					"CURRENTLY_ACTIVE",
					"PIPELINE_0",
					"PIPELINE_1",
				),
			}, /*END VALIDATORS*/
			// PreferredChannelPipeline is a write-only property.
		}, /*END ATTRIBUTE*/
		// Property: ProgramName
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The name of the multiplex program.",
		//	  "type": "string"
		//	}
		"program_name": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The name of the multiplex program.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
				stringplanmodifier.RequiresReplaceIfConfigured(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
	} /*END SCHEMA*/

	// Corresponds to CloudFormation primaryIdentifier.
	attributes["id"] = schema.StringAttribute{
		Description: "Uniquely identifies the resource.",
		Computed:    true,
		PlanModifiers: []planmodifier.String{
			stringplanmodifier.UseStateForUnknown(),
		},
	}

	schema := schema.Schema{
		Description: "Resource schema for AWS::MediaLive::Multiplexprogram",
		Version:     1,
		Attributes:  attributes,
	}

	var opts generic.ResourceOptions

	opts = opts.WithCloudFormationTypeName("AWS::MediaLive::Multiplexprogram").WithTerraformTypeName("awscc_medialive_multiplexprogram")
	opts = opts.WithTerraformSchema(schema)
	opts = opts.WithAttributeNameMap(map[string]string{
		"active_channel_pipeline":    "ActiveChannelPipeline",
		"audio_pids":                 "AudioPids",
		"channel_id":                 "ChannelId",
		"constant_bitrate":           "ConstantBitrate",
		"dvb_sub_pids":               "DvbSubPids",
		"dvb_teletext_pid":           "DvbTeletextPid",
		"etv_platform_pid":           "EtvPlatformPid",
		"etv_signal_pid":             "EtvSignalPid",
		"klv_data_pids":              "KlvDataPids",
		"maximum_bitrate":            "MaximumBitrate",
		"minimum_bitrate":            "MinimumBitrate",
		"multiplex_id":               "MultiplexId",
		"multiplex_program_settings": "MultiplexProgramSettings",
		"packet_identifiers_map":     "PacketIdentifiersMap",
		"pcr_pid":                    "PcrPid",
		"pipeline_details":           "PipelineDetails",
		"pipeline_id":                "PipelineId",
		"pmt_pid":                    "PmtPid",
		"preferred_channel_pipeline": "PreferredChannelPipeline",
		"priority":                   "Priority",
		"private_metadata_pid":       "PrivateMetadataPid",
		"program_name":               "ProgramName",
		"program_number":             "ProgramNumber",
		"provider_name":              "ProviderName",
		"scte_27_pids":               "Scte27Pids",
		"scte_35_pid":                "Scte35Pid",
		"service_descriptor":         "ServiceDescriptor",
		"service_name":               "ServiceName",
		"statmux_settings":           "StatmuxSettings",
		"timed_metadata_pid":         "TimedMetadataPid",
		"video_pid":                  "VideoPid",
		"video_settings":             "VideoSettings",
	})

	opts = opts.WithWriteOnlyPropertyPaths([]string{
		"/properties/PreferredChannelPipeline",
	})
	opts = opts.WithCreateTimeoutInMinutes(0).WithDeleteTimeoutInMinutes(0)

	opts = opts.WithUpdateTimeoutInMinutes(0)

	v, err := generic.NewResource(ctx, opts...)

	if err != nil {
		return nil, err
	}

	return v, nil
}
