// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// Code generated by generators/singular-data-source/main.go; DO NOT EDIT.

package medialive

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework-timetypes/timetypes"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-provider-awscc/internal/generic"
	"github.com/hashicorp/terraform-provider-awscc/internal/registry"
)

func init() {
	registry.AddDataSourceFactory("awscc_medialive_signal_map", signalMapDataSource)
}

// signalMapDataSource returns the Terraform awscc_medialive_signal_map data source.
// This Terraform data source corresponds to the CloudFormation AWS::MediaLive::SignalMap resource.
func signalMapDataSource(ctx context.Context) (datasource.DataSource, error) {
	attributes := map[string]schema.Attribute{ /*START SCHEMA*/
		// Property: Arn
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A signal map's ARN (Amazon Resource Name)",
		//	  "pattern": "^arn:.+:medialive:.+:signal-map:.+$",
		//	  "type": "string"
		//	}
		"arn": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "A signal map's ARN (Amazon Resource Name)",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: CloudWatchAlarmTemplateGroupIdentifiers
		// CloudFormation resource type schema:
		//
		//	{
		//	  "items": {
		//	    "pattern": "^[^\\s]+$",
		//	    "type": "string"
		//	  },
		//	  "type": "array"
		//	}
		"cloudwatch_alarm_template_group_identifiers": schema.ListAttribute{ /*START ATTRIBUTE*/
			ElementType: types.StringType,
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: CloudWatchAlarmTemplateGroupIds
		// CloudFormation resource type schema:
		//
		//	{
		//	  "items": {
		//	    "maxLength": 11,
		//	    "minLength": 7,
		//	    "pattern": "^(aws-)?[0-9]{7}$",
		//	    "type": "string"
		//	  },
		//	  "type": "array"
		//	}
		"cloudwatch_alarm_template_group_ids": schema.ListAttribute{ /*START ATTRIBUTE*/
			ElementType: types.StringType,
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: CreatedAt
		// CloudFormation resource type schema:
		//
		//	{
		//	  "format": "date-time",
		//	  "type": "string"
		//	}
		"created_at": schema.StringAttribute{ /*START ATTRIBUTE*/
			CustomType: timetypes.RFC3339Type{},
			Computed:   true,
		}, /*END ATTRIBUTE*/
		// Property: Description
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A resource's optional description.",
		//	  "maxLength": 1024,
		//	  "minLength": 0,
		//	  "type": "string"
		//	}
		"description": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "A resource's optional description.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: DiscoveryEntryPointArn
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A top-level supported AWS resource ARN to discovery a signal map from.",
		//	  "maxLength": 2048,
		//	  "minLength": 1,
		//	  "type": "string"
		//	}
		"discovery_entry_point_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "A top-level supported AWS resource ARN to discovery a signal map from.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: ErrorMessage
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "Error message associated with a failed creation or failed update attempt of a signal map.",
		//	  "maxLength": 2048,
		//	  "minLength": 0,
		//	  "type": "string"
		//	}
		"error_message": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "Error message associated with a failed creation or failed update attempt of a signal map.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: EventBridgeRuleTemplateGroupIdentifiers
		// CloudFormation resource type schema:
		//
		//	{
		//	  "items": {
		//	    "pattern": "^[^\\s]+$",
		//	    "type": "string"
		//	  },
		//	  "type": "array"
		//	}
		"event_bridge_rule_template_group_identifiers": schema.ListAttribute{ /*START ATTRIBUTE*/
			ElementType: types.StringType,
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: EventBridgeRuleTemplateGroupIds
		// CloudFormation resource type schema:
		//
		//	{
		//	  "items": {
		//	    "maxLength": 11,
		//	    "minLength": 7,
		//	    "pattern": "^(aws-)?[0-9]{7}$",
		//	    "type": "string"
		//	  },
		//	  "type": "array"
		//	}
		"event_bridge_rule_template_group_ids": schema.ListAttribute{ /*START ATTRIBUTE*/
			ElementType: types.StringType,
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: FailedMediaResourceMap
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "A map representing an incomplete AWS media workflow as a graph.",
		//	  "patternProperties": {
		//	    "": {
		//	      "additionalProperties": false,
		//	      "description": "An AWS resource used in media workflows.",
		//	      "properties": {
		//	        "Destinations": {
		//	          "items": {
		//	            "additionalProperties": false,
		//	            "description": "A direct source or destination neighbor to an AWS media resource.",
		//	            "properties": {
		//	              "Arn": {
		//	                "description": "The ARN of a resource used in AWS media workflows.",
		//	                "maxLength": 2048,
		//	                "minLength": 1,
		//	                "pattern": "^arn.+$",
		//	                "type": "string"
		//	              },
		//	              "Name": {
		//	                "description": "The logical name of an AWS media resource.",
		//	                "maxLength": 256,
		//	                "minLength": 0,
		//	                "type": "string"
		//	              }
		//	            },
		//	            "required": [
		//	              "Arn"
		//	            ],
		//	            "type": "object"
		//	          },
		//	          "type": "array"
		//	        },
		//	        "Name": {
		//	          "description": "The logical name of an AWS media resource.",
		//	          "maxLength": 256,
		//	          "minLength": 0,
		//	          "type": "string"
		//	        },
		//	        "Sources": {
		//	          "items": {
		//	            "additionalProperties": false,
		//	            "description": "A direct source or destination neighbor to an AWS media resource.",
		//	            "properties": {
		//	              "Arn": {
		//	                "description": "The ARN of a resource used in AWS media workflows.",
		//	                "maxLength": 2048,
		//	                "minLength": 1,
		//	                "pattern": "^arn.+$",
		//	                "type": "string"
		//	              },
		//	              "Name": {
		//	                "description": "The logical name of an AWS media resource.",
		//	                "maxLength": 256,
		//	                "minLength": 0,
		//	                "type": "string"
		//	              }
		//	            },
		//	            "required": [
		//	              "Arn"
		//	            ],
		//	            "type": "object"
		//	          },
		//	          "type": "array"
		//	        }
		//	      },
		//	      "type": "object"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"failed_media_resource_map": // Pattern: ""
		schema.MapNestedAttribute{   /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: Destinations
					"destinations": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
						NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: Arn
								"arn": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The ARN of a resource used in AWS media workflows.",
									Computed:    true,
								}, /*END ATTRIBUTE*/
								// Property: Name
								"name": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The logical name of an AWS media resource.",
									Computed:    true,
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
						}, /*END NESTED OBJECT*/
						Computed: true,
					}, /*END ATTRIBUTE*/
					// Property: Name
					"name": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The logical name of an AWS media resource.",
						Computed:    true,
					}, /*END ATTRIBUTE*/
					// Property: Sources
					"sources": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
						NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: Arn
								"arn": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The ARN of a resource used in AWS media workflows.",
									Computed:    true,
								}, /*END ATTRIBUTE*/
								// Property: Name
								"name": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The logical name of an AWS media resource.",
									Computed:    true,
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
						}, /*END NESTED OBJECT*/
						Computed: true,
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Description: "A map representing an incomplete AWS media workflow as a graph.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: ForceRediscovery
		// CloudFormation resource type schema:
		//
		//	{
		//	  "default": false,
		//	  "description": "If true, will force a rediscovery of a signal map if an unchanged discoveryEntryPointArn is provided.",
		//	  "type": "boolean"
		//	}
		"force_rediscovery": schema.BoolAttribute{ /*START ATTRIBUTE*/
			Description: "If true, will force a rediscovery of a signal map if an unchanged discoveryEntryPointArn is provided.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: Id
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A signal map's id.",
		//	  "maxLength": 11,
		//	  "minLength": 7,
		//	  "pattern": "^(aws-)?[0-9]{7}$",
		//	  "type": "string"
		//	}
		"signal_map_id": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "A signal map's id.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: Identifier
		// CloudFormation resource type schema:
		//
		//	{
		//	  "type": "string"
		//	}
		"identifier": schema.StringAttribute{ /*START ATTRIBUTE*/
			Computed: true,
		}, /*END ATTRIBUTE*/
		// Property: LastDiscoveredAt
		// CloudFormation resource type schema:
		//
		//	{
		//	  "format": "date-time",
		//	  "type": "string"
		//	}
		"last_discovered_at": schema.StringAttribute{ /*START ATTRIBUTE*/
			CustomType: timetypes.RFC3339Type{},
			Computed:   true,
		}, /*END ATTRIBUTE*/
		// Property: LastSuccessfulMonitorDeployment
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "Represents the latest successful monitor deployment of a signal map.",
		//	  "properties": {
		//	    "DetailsUri": {
		//	      "description": "URI associated with a signal map's monitor deployment.",
		//	      "maxLength": 2048,
		//	      "minLength": 0,
		//	      "type": "string"
		//	    },
		//	    "Status": {
		//	      "description": "A signal map's monitor deployment status.",
		//	      "enum": [
		//	        "NOT_DEPLOYED",
		//	        "DRY_RUN_DEPLOYMENT_COMPLETE",
		//	        "DRY_RUN_DEPLOYMENT_FAILED",
		//	        "DRY_RUN_DEPLOYMENT_IN_PROGRESS",
		//	        "DEPLOYMENT_COMPLETE",
		//	        "DEPLOYMENT_FAILED",
		//	        "DEPLOYMENT_IN_PROGRESS",
		//	        "DELETE_COMPLETE",
		//	        "DELETE_FAILED",
		//	        "DELETE_IN_PROGRESS"
		//	      ],
		//	      "type": "string"
		//	    }
		//	  },
		//	  "required": [
		//	    "DetailsUri",
		//	    "Status"
		//	  ],
		//	  "type": "object"
		//	}
		"last_successful_monitor_deployment": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: DetailsUri
				"details_uri": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "URI associated with a signal map's monitor deployment.",
					Computed:    true,
				}, /*END ATTRIBUTE*/
				// Property: Status
				"status": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "A signal map's monitor deployment status.",
					Computed:    true,
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "Represents the latest successful monitor deployment of a signal map.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: MediaResourceMap
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "A map representing an AWS media workflow as a graph.",
		//	  "patternProperties": {
		//	    "": {
		//	      "additionalProperties": false,
		//	      "description": "An AWS resource used in media workflows.",
		//	      "properties": {
		//	        "Destinations": {
		//	          "items": {
		//	            "additionalProperties": false,
		//	            "description": "A direct source or destination neighbor to an AWS media resource.",
		//	            "properties": {
		//	              "Arn": {
		//	                "description": "The ARN of a resource used in AWS media workflows.",
		//	                "maxLength": 2048,
		//	                "minLength": 1,
		//	                "pattern": "^arn.+$",
		//	                "type": "string"
		//	              },
		//	              "Name": {
		//	                "description": "The logical name of an AWS media resource.",
		//	                "maxLength": 256,
		//	                "minLength": 0,
		//	                "type": "string"
		//	              }
		//	            },
		//	            "required": [
		//	              "Arn"
		//	            ],
		//	            "type": "object"
		//	          },
		//	          "type": "array"
		//	        },
		//	        "Name": {
		//	          "description": "The logical name of an AWS media resource.",
		//	          "maxLength": 256,
		//	          "minLength": 0,
		//	          "type": "string"
		//	        },
		//	        "Sources": {
		//	          "items": {
		//	            "additionalProperties": false,
		//	            "description": "A direct source or destination neighbor to an AWS media resource.",
		//	            "properties": {
		//	              "Arn": {
		//	                "description": "The ARN of a resource used in AWS media workflows.",
		//	                "maxLength": 2048,
		//	                "minLength": 1,
		//	                "pattern": "^arn.+$",
		//	                "type": "string"
		//	              },
		//	              "Name": {
		//	                "description": "The logical name of an AWS media resource.",
		//	                "maxLength": 256,
		//	                "minLength": 0,
		//	                "type": "string"
		//	              }
		//	            },
		//	            "required": [
		//	              "Arn"
		//	            ],
		//	            "type": "object"
		//	          },
		//	          "type": "array"
		//	        }
		//	      },
		//	      "type": "object"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"media_resource_map":      // Pattern: ""
		schema.MapNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: Destinations
					"destinations": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
						NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: Arn
								"arn": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The ARN of a resource used in AWS media workflows.",
									Computed:    true,
								}, /*END ATTRIBUTE*/
								// Property: Name
								"name": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The logical name of an AWS media resource.",
									Computed:    true,
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
						}, /*END NESTED OBJECT*/
						Computed: true,
					}, /*END ATTRIBUTE*/
					// Property: Name
					"name": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The logical name of an AWS media resource.",
						Computed:    true,
					}, /*END ATTRIBUTE*/
					// Property: Sources
					"sources": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
						NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: Arn
								"arn": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The ARN of a resource used in AWS media workflows.",
									Computed:    true,
								}, /*END ATTRIBUTE*/
								// Property: Name
								"name": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The logical name of an AWS media resource.",
									Computed:    true,
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
						}, /*END NESTED OBJECT*/
						Computed: true,
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Description: "A map representing an AWS media workflow as a graph.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: ModifiedAt
		// CloudFormation resource type schema:
		//
		//	{
		//	  "format": "date-time",
		//	  "type": "string"
		//	}
		"modified_at": schema.StringAttribute{ /*START ATTRIBUTE*/
			CustomType: timetypes.RFC3339Type{},
			Computed:   true,
		}, /*END ATTRIBUTE*/
		// Property: MonitorChangesPendingDeployment
		// CloudFormation resource type schema:
		//
		//	{
		//	  "default": false,
		//	  "description": "If true, there are pending monitor changes for this signal map that can be deployed.",
		//	  "type": "boolean"
		//	}
		"monitor_changes_pending_deployment": schema.BoolAttribute{ /*START ATTRIBUTE*/
			Description: "If true, there are pending monitor changes for this signal map that can be deployed.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: MonitorDeployment
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "Represents the latest monitor deployment of a signal map.",
		//	  "properties": {
		//	    "DetailsUri": {
		//	      "description": "URI associated with a signal map's monitor deployment.",
		//	      "maxLength": 2048,
		//	      "minLength": 0,
		//	      "type": "string"
		//	    },
		//	    "ErrorMessage": {
		//	      "description": "Error message associated with a failed monitor deployment of a signal map.",
		//	      "maxLength": 2048,
		//	      "minLength": 0,
		//	      "type": "string"
		//	    },
		//	    "Status": {
		//	      "description": "A signal map's monitor deployment status.",
		//	      "enum": [
		//	        "NOT_DEPLOYED",
		//	        "DRY_RUN_DEPLOYMENT_COMPLETE",
		//	        "DRY_RUN_DEPLOYMENT_FAILED",
		//	        "DRY_RUN_DEPLOYMENT_IN_PROGRESS",
		//	        "DEPLOYMENT_COMPLETE",
		//	        "DEPLOYMENT_FAILED",
		//	        "DEPLOYMENT_IN_PROGRESS",
		//	        "DELETE_COMPLETE",
		//	        "DELETE_FAILED",
		//	        "DELETE_IN_PROGRESS"
		//	      ],
		//	      "type": "string"
		//	    }
		//	  },
		//	  "required": [
		//	    "Status"
		//	  ],
		//	  "type": "object"
		//	}
		"monitor_deployment": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: DetailsUri
				"details_uri": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "URI associated with a signal map's monitor deployment.",
					Computed:    true,
				}, /*END ATTRIBUTE*/
				// Property: ErrorMessage
				"error_message": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "Error message associated with a failed monitor deployment of a signal map.",
					Computed:    true,
				}, /*END ATTRIBUTE*/
				// Property: Status
				"status": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "A signal map's monitor deployment status.",
					Computed:    true,
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "Represents the latest monitor deployment of a signal map.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: Name
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A resource's name. Names must be unique within the scope of a resource type in a specific region.",
		//	  "maxLength": 255,
		//	  "minLength": 1,
		//	  "pattern": "^[^\\s]+$",
		//	  "type": "string"
		//	}
		"name": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "A resource's name. Names must be unique within the scope of a resource type in a specific region.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: Status
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A signal map's current status which is dependent on its lifecycle actions or associated jobs.",
		//	  "enum": [
		//	    "CREATE_IN_PROGRESS",
		//	    "CREATE_COMPLETE",
		//	    "CREATE_FAILED",
		//	    "UPDATE_IN_PROGRESS",
		//	    "UPDATE_COMPLETE",
		//	    "UPDATE_REVERTED",
		//	    "UPDATE_FAILED",
		//	    "READY",
		//	    "NOT_READY"
		//	  ],
		//	  "type": "string"
		//	}
		"status": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "A signal map's current status which is dependent on its lifecycle actions or associated jobs.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: Tags
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "Represents the tags associated with a resource.",
		//	  "patternProperties": {
		//	    "": {
		//	      "type": "string"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"tags":              // Pattern: ""
		schema.MapAttribute{ /*START ATTRIBUTE*/
			ElementType: types.StringType,
			Description: "Represents the tags associated with a resource.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
	} /*END SCHEMA*/

	attributes["id"] = schema.StringAttribute{
		Description: "Uniquely identifies the resource.",
		Required:    true,
	}

	schema := schema.Schema{
		Description: "Data Source schema for AWS::MediaLive::SignalMap",
		Attributes:  attributes,
	}

	var opts generic.DataSourceOptions

	opts = opts.WithCloudFormationTypeName("AWS::MediaLive::SignalMap").WithTerraformTypeName("awscc_medialive_signal_map")
	opts = opts.WithTerraformSchema(schema)
	opts = opts.WithAttributeNameMap(map[string]string{
		"arn": "Arn",
		"cloudwatch_alarm_template_group_identifiers":  "CloudWatchAlarmTemplateGroupIdentifiers",
		"cloudwatch_alarm_template_group_ids":          "CloudWatchAlarmTemplateGroupIds",
		"created_at":                                   "CreatedAt",
		"description":                                  "Description",
		"destinations":                                 "Destinations",
		"details_uri":                                  "DetailsUri",
		"discovery_entry_point_arn":                    "DiscoveryEntryPointArn",
		"error_message":                                "ErrorMessage",
		"event_bridge_rule_template_group_identifiers": "EventBridgeRuleTemplateGroupIdentifiers",
		"event_bridge_rule_template_group_ids":         "EventBridgeRuleTemplateGroupIds",
		"failed_media_resource_map":                    "FailedMediaResourceMap",
		"force_rediscovery":                            "ForceRediscovery",
		"identifier":                                   "Identifier",
		"last_discovered_at":                           "LastDiscoveredAt",
		"last_successful_monitor_deployment":           "LastSuccessfulMonitorDeployment",
		"media_resource_map":                           "MediaResourceMap",
		"modified_at":                                  "ModifiedAt",
		"monitor_changes_pending_deployment":           "MonitorChangesPendingDeployment",
		"monitor_deployment":                           "MonitorDeployment",
		"name":                                         "Name",
		"signal_map_id":                                "Id",
		"sources":                                      "Sources",
		"status":                                       "Status",
		"tags":                                         "Tags",
	})

	v, err := generic.NewSingularDataSource(ctx, opts...)

	if err != nil {
		return nil, err
	}

	return v, nil
}
