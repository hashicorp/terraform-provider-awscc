// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// Code generated by generators/resource/main.go; DO NOT EDIT.

package gamelift

import (
	"context"
	"regexp"

	"github.com/hashicorp/terraform-plugin-framework-validators/float64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/setvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/float64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/setplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-provider-awscc/internal/generic"
	"github.com/hashicorp/terraform-provider-awscc/internal/registry"
	fwvalidators "github.com/hashicorp/terraform-provider-awscc/internal/validators"
)

func init() {
	registry.AddResourceFactory("awscc_gamelift_container_group_definition", containerGroupDefinitionResource)
}

// containerGroupDefinitionResource returns the Terraform awscc_gamelift_container_group_definition resource.
// This Terraform resource corresponds to the CloudFormation AWS::GameLift::ContainerGroupDefinition resource.
func containerGroupDefinitionResource(ctx context.Context) (resource.Resource, error) {
	attributes := map[string]schema.Attribute{ /*START SCHEMA*/
		// Property: ContainerGroupDefinitionArn
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The Amazon Resource Name (ARN) that is assigned to a Amazon GameLift container group resource and uniquely identifies it across all AWS Regions.",
		//	  "maxLength": 512,
		//	  "minLength": 1,
		//	  "pattern": "^arn:.*:containergroupdefinition\\/[a-zA-Z0-9\\-]+(:[0-9]+)?$",
		//	  "type": "string"
		//	}
		"container_group_definition_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The Amazon Resource Name (ARN) that is assigned to a Amazon GameLift container group resource and uniquely identifies it across all AWS Regions.",
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: ContainerGroupType
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The scope of the container group",
		//	  "enum": [
		//	    "GAME_SERVER",
		//	    "PER_INSTANCE"
		//	  ],
		//	  "type": "string"
		//	}
		"container_group_type": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The scope of the container group",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.OneOf(
					"GAME_SERVER",
					"PER_INSTANCE",
				),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
				stringplanmodifier.RequiresReplaceIfConfigured(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: CreationTime
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A time stamp indicating when this data object was created. Format is a number expressed in Unix time as milliseconds (for example \"1469498468.057\").",
		//	  "type": "string"
		//	}
		"creation_time": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "A time stamp indicating when this data object was created. Format is a number expressed in Unix time as milliseconds (for example \"1469498468.057\").",
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: GameServerContainerDefinition
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "Specifies the information required to run game servers with this container group",
		//	  "properties": {
		//	    "ContainerName": {
		//	      "description": "A descriptive label for the container definition. Container definition names must be unique with a container group definition.",
		//	      "maxLength": 128,
		//	      "minLength": 1,
		//	      "pattern": "^[a-zA-Z0-9-]+$",
		//	      "type": "string"
		//	    },
		//	    "DependsOn": {
		//	      "description": "A list of container dependencies that determines when this container starts up and shuts down. For container groups with multiple containers, dependencies let you define a startup/shutdown sequence across the containers.",
		//	      "insertionOrder": true,
		//	      "items": {
		//	        "additionalProperties": false,
		//	        "description": "A dependency that impacts a container's startup and shutdown.",
		//	        "properties": {
		//	          "Condition": {
		//	            "description": "The type of dependency.",
		//	            "enum": [
		//	              "START",
		//	              "COMPLETE",
		//	              "SUCCESS",
		//	              "HEALTHY"
		//	            ],
		//	            "type": "string"
		//	          },
		//	          "ContainerName": {
		//	            "description": "A descriptive label for the container definition. The container being defined depends on this container's condition.",
		//	            "maxLength": 128,
		//	            "minLength": 1,
		//	            "pattern": "^[a-zA-Z0-9-]+$",
		//	            "type": "string"
		//	          }
		//	        },
		//	        "required": [
		//	          "ContainerName",
		//	          "Condition"
		//	        ],
		//	        "type": "object"
		//	      },
		//	      "maxItems": 10,
		//	      "minItems": 1,
		//	      "type": "array",
		//	      "uniqueItems": true
		//	    },
		//	    "EnvironmentOverride": {
		//	      "description": "The environment variables to pass to a container.",
		//	      "insertionOrder": false,
		//	      "items": {
		//	        "additionalProperties": false,
		//	        "description": "An environment variable to set inside a container, in the form of a key-value pair.",
		//	        "properties": {
		//	          "Name": {
		//	            "description": "The environment variable name.",
		//	            "maxLength": 255,
		//	            "minLength": 1,
		//	            "pattern": "^.*$",
		//	            "type": "string"
		//	          },
		//	          "Value": {
		//	            "description": "The environment variable value.",
		//	            "maxLength": 255,
		//	            "minLength": 1,
		//	            "pattern": "^.*$",
		//	            "type": "string"
		//	          }
		//	        },
		//	        "required": [
		//	          "Name",
		//	          "Value"
		//	        ],
		//	        "type": "object"
		//	      },
		//	      "maxItems": 20,
		//	      "minItems": 1,
		//	      "type": "array",
		//	      "uniqueItems": true
		//	    },
		//	    "ImageUri": {
		//	      "description": "Specifies the image URI of this container.",
		//	      "maxLength": 255,
		//	      "minLength": 1,
		//	      "pattern": "^[a-zA-Z0-9-_\\.@\\/:]+$",
		//	      "type": "string"
		//	    },
		//	    "MountPoints": {
		//	      "description": "A list of mount point configurations to be used in a container.",
		//	      "insertionOrder": false,
		//	      "items": {
		//	        "additionalProperties": false,
		//	        "description": "Defines the mount point configuration within a container.",
		//	        "properties": {
		//	          "AccessLevel": {
		//	            "description": "The access permissions for the mounted path.",
		//	            "enum": [
		//	              "READ_ONLY",
		//	              "READ_AND_WRITE"
		//	            ],
		//	            "type": "string"
		//	          },
		//	          "ContainerPath": {
		//	            "description": "The path inside the container where the mount is accessible.",
		//	            "maxLength": 1024,
		//	            "minLength": 1,
		//	            "pattern": "^(\\/+[^\\/]+\\/*)+$",
		//	            "type": "string"
		//	          },
		//	          "InstancePath": {
		//	            "description": "The path on the host that will be mounted in the container.",
		//	            "maxLength": 1024,
		//	            "minLength": 1,
		//	            "pattern": "^\\/[\\s\\S]*$",
		//	            "type": "string"
		//	          }
		//	        },
		//	        "required": [
		//	          "InstancePath"
		//	        ],
		//	        "type": "object"
		//	      },
		//	      "maxItems": 10,
		//	      "minItems": 1,
		//	      "type": "array",
		//	      "uniqueItems": true
		//	    },
		//	    "PortConfiguration": {
		//	      "additionalProperties": false,
		//	      "description": "Defines the ports on the container.",
		//	      "properties": {
		//	        "ContainerPortRanges": {
		//	          "description": "Specifies one or more ranges of ports on a container.",
		//	          "insertionOrder": false,
		//	          "items": {
		//	            "additionalProperties": false,
		//	            "description": "A set of one or more port numbers that can be opened on the container.",
		//	            "properties": {
		//	              "FromPort": {
		//	                "description": "A starting value for the range of allowed port numbers.",
		//	                "maximum": 60000,
		//	                "minimum": 1,
		//	                "type": "integer"
		//	              },
		//	              "Protocol": {
		//	                "description": "Defines the protocol of these ports.",
		//	                "enum": [
		//	                  "TCP",
		//	                  "UDP"
		//	                ],
		//	                "type": "string"
		//	              },
		//	              "ToPort": {
		//	                "description": "An ending value for the range of allowed port numbers. Port numbers are end-inclusive. This value must be equal to or greater than FromPort.",
		//	                "maximum": 60000,
		//	                "minimum": 1,
		//	                "type": "integer"
		//	              }
		//	            },
		//	            "required": [
		//	              "FromPort",
		//	              "Protocol",
		//	              "ToPort"
		//	            ],
		//	            "type": "object"
		//	          },
		//	          "maxItems": 100,
		//	          "minItems": 1,
		//	          "type": "array",
		//	          "uniqueItems": true
		//	        }
		//	      },
		//	      "required": [
		//	        "ContainerPortRanges"
		//	      ],
		//	      "type": "object"
		//	    },
		//	    "ResolvedImageDigest": {
		//	      "description": "The digest of the container image.",
		//	      "pattern": "^sha256:[a-fA-F0-9]{64}$",
		//	      "type": "string"
		//	    },
		//	    "ServerSdkVersion": {
		//	      "description": "The version of the server SDK used in this container group",
		//	      "maxLength": 128,
		//	      "pattern": "^\\d+\\.\\d+\\.\\d+$",
		//	      "type": "string"
		//	    }
		//	  },
		//	  "required": [
		//	    "ContainerName",
		//	    "ImageUri",
		//	    "ServerSdkVersion"
		//	  ],
		//	  "type": "object"
		//	}
		"game_server_container_definition": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: ContainerName
				"container_name": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "A descriptive label for the container definition. Container definition names must be unique with a container group definition.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.String{ /*START VALIDATORS*/
						stringvalidator.LengthBetween(1, 128),
						stringvalidator.RegexMatches(regexp.MustCompile("^[a-zA-Z0-9-]+$"), ""),
						fwvalidators.NotNullString(),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: DependsOn
				"depends_on": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
					NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: Condition
							"condition": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "The type of dependency.",
								Optional:    true,
								Computed:    true,
								Validators: []validator.String{ /*START VALIDATORS*/
									stringvalidator.OneOf(
										"START",
										"COMPLETE",
										"SUCCESS",
										"HEALTHY",
									),
									fwvalidators.NotNullString(),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
									stringplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: ContainerName
							"container_name": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "A descriptive label for the container definition. The container being defined depends on this container's condition.",
								Optional:    true,
								Computed:    true,
								Validators: []validator.String{ /*START VALIDATORS*/
									stringvalidator.LengthBetween(1, 128),
									stringvalidator.RegexMatches(regexp.MustCompile("^[a-zA-Z0-9-]+$"), ""),
									fwvalidators.NotNullString(),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
									stringplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
					}, /*END NESTED OBJECT*/
					Description: "A list of container dependencies that determines when this container starts up and shuts down. For container groups with multiple containers, dependencies let you define a startup/shutdown sequence across the containers.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.List{ /*START VALIDATORS*/
						listvalidator.SizeBetween(1, 10),
						listvalidator.UniqueValues(),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
						listplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: EnvironmentOverride
				"environment_override": schema.SetNestedAttribute{ /*START ATTRIBUTE*/
					NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: Name
							"name": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "The environment variable name.",
								Optional:    true,
								Computed:    true,
								Validators: []validator.String{ /*START VALIDATORS*/
									stringvalidator.LengthBetween(1, 255),
									stringvalidator.RegexMatches(regexp.MustCompile("^.*$"), ""),
									fwvalidators.NotNullString(),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
									stringplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: Value
							"value": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "The environment variable value.",
								Optional:    true,
								Computed:    true,
								Validators: []validator.String{ /*START VALIDATORS*/
									stringvalidator.LengthBetween(1, 255),
									stringvalidator.RegexMatches(regexp.MustCompile("^.*$"), ""),
									fwvalidators.NotNullString(),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
									stringplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
					}, /*END NESTED OBJECT*/
					Description: "The environment variables to pass to a container.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.Set{ /*START VALIDATORS*/
						setvalidator.SizeBetween(1, 20),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.Set{ /*START PLAN MODIFIERS*/
						setplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: ImageUri
				"image_uri": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "Specifies the image URI of this container.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.String{ /*START VALIDATORS*/
						stringvalidator.LengthBetween(1, 255),
						stringvalidator.RegexMatches(regexp.MustCompile("^[a-zA-Z0-9-_\\.@\\/:]+$"), ""),
						fwvalidators.NotNullString(),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: MountPoints
				"mount_points": schema.SetNestedAttribute{ /*START ATTRIBUTE*/
					NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: AccessLevel
							"access_level": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "The access permissions for the mounted path.",
								Optional:    true,
								Computed:    true,
								Validators: []validator.String{ /*START VALIDATORS*/
									stringvalidator.OneOf(
										"READ_ONLY",
										"READ_AND_WRITE",
									),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
									stringplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: ContainerPath
							"container_path": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "The path inside the container where the mount is accessible.",
								Optional:    true,
								Computed:    true,
								Validators: []validator.String{ /*START VALIDATORS*/
									stringvalidator.LengthBetween(1, 1024),
									stringvalidator.RegexMatches(regexp.MustCompile("^(\\/+[^\\/]+\\/*)+$"), ""),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
									stringplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: InstancePath
							"instance_path": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "The path on the host that will be mounted in the container.",
								Optional:    true,
								Computed:    true,
								Validators: []validator.String{ /*START VALIDATORS*/
									stringvalidator.LengthBetween(1, 1024),
									stringvalidator.RegexMatches(regexp.MustCompile("^\\/[\\s\\S]*$"), ""),
									fwvalidators.NotNullString(),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
									stringplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
					}, /*END NESTED OBJECT*/
					Description: "A list of mount point configurations to be used in a container.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.Set{ /*START VALIDATORS*/
						setvalidator.SizeBetween(1, 10),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.Set{ /*START PLAN MODIFIERS*/
						setplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: PortConfiguration
				"port_configuration": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
					Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
						// Property: ContainerPortRanges
						"container_port_ranges": schema.SetNestedAttribute{ /*START ATTRIBUTE*/
							NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
								Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
									// Property: FromPort
									"from_port": schema.Int64Attribute{ /*START ATTRIBUTE*/
										Description: "A starting value for the range of allowed port numbers.",
										Optional:    true,
										Computed:    true,
										Validators: []validator.Int64{ /*START VALIDATORS*/
											int64validator.Between(1, 60000),
											fwvalidators.NotNullInt64(),
										}, /*END VALIDATORS*/
										PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
											int64planmodifier.UseStateForUnknown(),
										}, /*END PLAN MODIFIERS*/
									}, /*END ATTRIBUTE*/
									// Property: Protocol
									"protocol": schema.StringAttribute{ /*START ATTRIBUTE*/
										Description: "Defines the protocol of these ports.",
										Optional:    true,
										Computed:    true,
										Validators: []validator.String{ /*START VALIDATORS*/
											stringvalidator.OneOf(
												"TCP",
												"UDP",
											),
											fwvalidators.NotNullString(),
										}, /*END VALIDATORS*/
										PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
											stringplanmodifier.UseStateForUnknown(),
										}, /*END PLAN MODIFIERS*/
									}, /*END ATTRIBUTE*/
									// Property: ToPort
									"to_port": schema.Int64Attribute{ /*START ATTRIBUTE*/
										Description: "An ending value for the range of allowed port numbers. Port numbers are end-inclusive. This value must be equal to or greater than FromPort.",
										Optional:    true,
										Computed:    true,
										Validators: []validator.Int64{ /*START VALIDATORS*/
											int64validator.Between(1, 60000),
											fwvalidators.NotNullInt64(),
										}, /*END VALIDATORS*/
										PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
											int64planmodifier.UseStateForUnknown(),
										}, /*END PLAN MODIFIERS*/
									}, /*END ATTRIBUTE*/
								}, /*END SCHEMA*/
							}, /*END NESTED OBJECT*/
							Description: "Specifies one or more ranges of ports on a container.",
							Optional:    true,
							Computed:    true,
							Validators: []validator.Set{ /*START VALIDATORS*/
								setvalidator.SizeBetween(1, 100),
								fwvalidators.NotNullSet(),
							}, /*END VALIDATORS*/
							PlanModifiers: []planmodifier.Set{ /*START PLAN MODIFIERS*/
								setplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
					}, /*END SCHEMA*/
					Description: "Defines the ports on the container.",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
						objectplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: ResolvedImageDigest
				"resolved_image_digest": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "The digest of the container image.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.String{ /*START VALIDATORS*/
						stringvalidator.RegexMatches(regexp.MustCompile("^sha256:[a-fA-F0-9]{64}$"), ""),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: ServerSdkVersion
				"server_sdk_version": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "The version of the server SDK used in this container group",
					Optional:    true,
					Computed:    true,
					Validators: []validator.String{ /*START VALIDATORS*/
						stringvalidator.LengthAtMost(128),
						stringvalidator.RegexMatches(regexp.MustCompile("^\\d+\\.\\d+\\.\\d+$"), ""),
						fwvalidators.NotNullString(),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "Specifies the information required to run game servers with this container group",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Name
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A descriptive label for the container group definition.",
		//	  "maxLength": 128,
		//	  "minLength": 1,
		//	  "pattern": "^[a-zA-Z0-9-]+$",
		//	  "type": "string"
		//	}
		"name": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "A descriptive label for the container group definition.",
			Required:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.LengthBetween(1, 128),
				stringvalidator.RegexMatches(regexp.MustCompile("^[a-zA-Z0-9-]+$"), ""),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.RequiresReplace(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: OperatingSystem
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The operating system of the container group",
		//	  "enum": [
		//	    "AMAZON_LINUX_2023"
		//	  ],
		//	  "type": "string"
		//	}
		"operating_system": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The operating system of the container group",
			Required:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.OneOf(
					"AMAZON_LINUX_2023",
				),
			}, /*END VALIDATORS*/
		}, /*END ATTRIBUTE*/
		// Property: SourceVersionNumber
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A specific ContainerGroupDefinition version to be updated",
		//	  "minimum": 0,
		//	  "type": "integer"
		//	}
		"source_version_number": schema.Int64Attribute{ /*START ATTRIBUTE*/
			Description: "A specific ContainerGroupDefinition version to be updated",
			Optional:    true,
			Computed:    true,
			Validators: []validator.Int64{ /*START VALIDATORS*/
				int64validator.AtLeast(0),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
				int64planmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Status
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A string indicating ContainerGroupDefinition status.",
		//	  "enum": [
		//	    "READY",
		//	    "COPYING",
		//	    "FAILED"
		//	  ],
		//	  "type": "string"
		//	}
		"status": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "A string indicating ContainerGroupDefinition status.",
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: StatusReason
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A string indicating the reason for ContainerGroupDefinition status.",
		//	  "type": "string"
		//	}
		"status_reason": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "A string indicating the reason for ContainerGroupDefinition status.",
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: SupportContainerDefinitions
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A collection of support container definitions that define the containers in this group.",
		//	  "insertionOrder": false,
		//	  "items": {
		//	    "additionalProperties": false,
		//	    "description": "Supports the function of the main container group",
		//	    "properties": {
		//	      "ContainerName": {
		//	        "description": "A descriptive label for the container definition.",
		//	        "maxLength": 128,
		//	        "minLength": 1,
		//	        "pattern": "^[a-zA-Z0-9-]+$",
		//	        "type": "string"
		//	      },
		//	      "DependsOn": {
		//	        "description": "A list of container dependencies that determines when this container starts up and shuts down. For container groups with multiple containers, dependencies let you define a startup/shutdown sequence across the containers.",
		//	        "insertionOrder": true,
		//	        "items": {
		//	          "additionalProperties": false,
		//	          "description": "A dependency that impacts a container's startup and shutdown.",
		//	          "properties": {
		//	            "Condition": {
		//	              "description": "The type of dependency.",
		//	              "enum": [
		//	                "START",
		//	                "COMPLETE",
		//	                "SUCCESS",
		//	                "HEALTHY"
		//	              ],
		//	              "type": "string"
		//	            },
		//	            "ContainerName": {
		//	              "description": "A descriptive label for the container definition. The container being defined depends on this container's condition.",
		//	              "maxLength": 128,
		//	              "minLength": 1,
		//	              "pattern": "^[a-zA-Z0-9-]+$",
		//	              "type": "string"
		//	            }
		//	          },
		//	          "required": [
		//	            "ContainerName",
		//	            "Condition"
		//	          ],
		//	          "type": "object"
		//	        },
		//	        "maxItems": 10,
		//	        "minItems": 1,
		//	        "type": "array",
		//	        "uniqueItems": true
		//	      },
		//	      "EnvironmentOverride": {
		//	        "description": "The environment variables to pass to a container.",
		//	        "insertionOrder": false,
		//	        "items": {
		//	          "additionalProperties": false,
		//	          "description": "An environment variable to set inside a container, in the form of a key-value pair.",
		//	          "properties": {
		//	            "Name": {
		//	              "description": "The environment variable name.",
		//	              "maxLength": 255,
		//	              "minLength": 1,
		//	              "pattern": "^.*$",
		//	              "type": "string"
		//	            },
		//	            "Value": {
		//	              "description": "The environment variable value.",
		//	              "maxLength": 255,
		//	              "minLength": 1,
		//	              "pattern": "^.*$",
		//	              "type": "string"
		//	            }
		//	          },
		//	          "required": [
		//	            "Name",
		//	            "Value"
		//	          ],
		//	          "type": "object"
		//	        },
		//	        "maxItems": 20,
		//	        "minItems": 1,
		//	        "type": "array",
		//	        "uniqueItems": true
		//	      },
		//	      "Essential": {
		//	        "description": "Specifies if the container is essential. If an essential container fails a health check, then all containers in the container group will be restarted. You must specify exactly 1 essential container in a container group.",
		//	        "type": "boolean"
		//	      },
		//	      "HealthCheck": {
		//	        "additionalProperties": false,
		//	        "description": "Specifies how the health of the containers will be checked.",
		//	        "properties": {
		//	          "Command": {
		//	            "description": "A string array representing the command that the container runs to determine if it is healthy.",
		//	            "insertionOrder": true,
		//	            "items": {
		//	              "maxLength": 255,
		//	              "minLength": 1,
		//	              "pattern": "^.*$",
		//	              "type": "string"
		//	            },
		//	            "maxItems": 20,
		//	            "minItems": 1,
		//	            "type": "array",
		//	            "uniqueItems": false
		//	          },
		//	          "Interval": {
		//	            "description": "How often (in seconds) the health is checked.",
		//	            "maximum": 300,
		//	            "minimum": 60,
		//	            "type": "integer"
		//	          },
		//	          "Retries": {
		//	            "description": "How many times the process manager will retry the command after a timeout. (The first run of the command does not count as a retry.)",
		//	            "maximum": 10,
		//	            "minimum": 5,
		//	            "type": "integer"
		//	          },
		//	          "StartPeriod": {
		//	            "description": "The optional grace period (in seconds) to give a container time to boostrap before teh health check is declared failed.",
		//	            "maximum": 300,
		//	            "minimum": 0,
		//	            "type": "integer"
		//	          },
		//	          "Timeout": {
		//	            "description": "How many seconds the process manager allows the command to run before canceling it.",
		//	            "maximum": 60,
		//	            "minimum": 30,
		//	            "type": "integer"
		//	          }
		//	        },
		//	        "required": [
		//	          "Command"
		//	        ],
		//	        "type": "object"
		//	      },
		//	      "ImageUri": {
		//	        "description": "Specifies the image URI of this container.",
		//	        "maxLength": 255,
		//	        "minLength": 1,
		//	        "pattern": "^[a-zA-Z0-9-_\\.@\\/:]+$",
		//	        "type": "string"
		//	      },
		//	      "MemoryHardLimitMebibytes": {
		//	        "description": "The total memory limit of container groups following this definition in MiB",
		//	        "maximum": 1024000,
		//	        "minimum": 4,
		//	        "type": "integer"
		//	      },
		//	      "MountPoints": {
		//	        "description": "A list of mount point configurations to be used in a container.",
		//	        "insertionOrder": false,
		//	        "items": {
		//	          "additionalProperties": false,
		//	          "description": "Defines the mount point configuration within a container.",
		//	          "properties": {
		//	            "AccessLevel": {
		//	              "description": "The access permissions for the mounted path.",
		//	              "enum": [
		//	                "READ_ONLY",
		//	                "READ_AND_WRITE"
		//	              ],
		//	              "type": "string"
		//	            },
		//	            "ContainerPath": {
		//	              "description": "The path inside the container where the mount is accessible.",
		//	              "maxLength": 1024,
		//	              "minLength": 1,
		//	              "pattern": "^(\\/+[^\\/]+\\/*)+$",
		//	              "type": "string"
		//	            },
		//	            "InstancePath": {
		//	              "description": "The path on the host that will be mounted in the container.",
		//	              "maxLength": 1024,
		//	              "minLength": 1,
		//	              "pattern": "^\\/[\\s\\S]*$",
		//	              "type": "string"
		//	            }
		//	          },
		//	          "required": [
		//	            "InstancePath"
		//	          ],
		//	          "type": "object"
		//	        },
		//	        "maxItems": 10,
		//	        "minItems": 1,
		//	        "type": "array",
		//	        "uniqueItems": true
		//	      },
		//	      "PortConfiguration": {
		//	        "additionalProperties": false,
		//	        "description": "Defines the ports on the container.",
		//	        "properties": {
		//	          "ContainerPortRanges": {
		//	            "description": "Specifies one or more ranges of ports on a container.",
		//	            "insertionOrder": false,
		//	            "items": {
		//	              "additionalProperties": false,
		//	              "description": "A set of one or more port numbers that can be opened on the container.",
		//	              "properties": {
		//	                "FromPort": {
		//	                  "description": "A starting value for the range of allowed port numbers.",
		//	                  "maximum": 60000,
		//	                  "minimum": 1,
		//	                  "type": "integer"
		//	                },
		//	                "Protocol": {
		//	                  "description": "Defines the protocol of these ports.",
		//	                  "enum": [
		//	                    "TCP",
		//	                    "UDP"
		//	                  ],
		//	                  "type": "string"
		//	                },
		//	                "ToPort": {
		//	                  "description": "An ending value for the range of allowed port numbers. Port numbers are end-inclusive. This value must be equal to or greater than FromPort.",
		//	                  "maximum": 60000,
		//	                  "minimum": 1,
		//	                  "type": "integer"
		//	                }
		//	              },
		//	              "required": [
		//	                "FromPort",
		//	                "Protocol",
		//	                "ToPort"
		//	              ],
		//	              "type": "object"
		//	            },
		//	            "maxItems": 100,
		//	            "minItems": 1,
		//	            "type": "array",
		//	            "uniqueItems": true
		//	          }
		//	        },
		//	        "required": [
		//	          "ContainerPortRanges"
		//	        ],
		//	        "type": "object"
		//	      },
		//	      "ResolvedImageDigest": {
		//	        "description": "The digest of the container image.",
		//	        "pattern": "^sha256:[a-fA-F0-9]{64}$",
		//	        "type": "string"
		//	      },
		//	      "Vcpu": {
		//	        "description": "The number of virtual CPUs to give to the support group",
		//	        "maximum": 10,
		//	        "minimum": 0.125,
		//	        "type": "number"
		//	      }
		//	    },
		//	    "required": [
		//	      "ContainerName",
		//	      "ImageUri"
		//	    ],
		//	    "type": "object"
		//	  },
		//	  "maxItems": 10,
		//	  "minItems": 1,
		//	  "type": "array",
		//	  "uniqueItems": true
		//	}
		"support_container_definitions": schema.SetNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: ContainerName
					"container_name": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "A descriptive label for the container definition.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.LengthBetween(1, 128),
							stringvalidator.RegexMatches(regexp.MustCompile("^[a-zA-Z0-9-]+$"), ""),
							fwvalidators.NotNullString(),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: DependsOn
					"depends_on": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
						NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: Condition
								"condition": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The type of dependency.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.OneOf(
											"START",
											"COMPLETE",
											"SUCCESS",
											"HEALTHY",
										),
										fwvalidators.NotNullString(),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: ContainerName
								"container_name": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "A descriptive label for the container definition. The container being defined depends on this container's condition.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthBetween(1, 128),
										stringvalidator.RegexMatches(regexp.MustCompile("^[a-zA-Z0-9-]+$"), ""),
										fwvalidators.NotNullString(),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
						}, /*END NESTED OBJECT*/
						Description: "A list of container dependencies that determines when this container starts up and shuts down. For container groups with multiple containers, dependencies let you define a startup/shutdown sequence across the containers.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.List{ /*START VALIDATORS*/
							listvalidator.SizeBetween(1, 10),
							listvalidator.UniqueValues(),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
							listplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: EnvironmentOverride
					"environment_override": schema.SetNestedAttribute{ /*START ATTRIBUTE*/
						NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: Name
								"name": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The environment variable name.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthBetween(1, 255),
										stringvalidator.RegexMatches(regexp.MustCompile("^.*$"), ""),
										fwvalidators.NotNullString(),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: Value
								"value": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The environment variable value.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthBetween(1, 255),
										stringvalidator.RegexMatches(regexp.MustCompile("^.*$"), ""),
										fwvalidators.NotNullString(),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
						}, /*END NESTED OBJECT*/
						Description: "The environment variables to pass to a container.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.Set{ /*START VALIDATORS*/
							setvalidator.SizeBetween(1, 20),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.Set{ /*START PLAN MODIFIERS*/
							setplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: Essential
					"essential": schema.BoolAttribute{ /*START ATTRIBUTE*/
						Description: "Specifies if the container is essential. If an essential container fails a health check, then all containers in the container group will be restarted. You must specify exactly 1 essential container in a container group.",
						Optional:    true,
						Computed:    true,
						PlanModifiers: []planmodifier.Bool{ /*START PLAN MODIFIERS*/
							boolplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: HealthCheck
					"health_check": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: Command
							"command": schema.ListAttribute{ /*START ATTRIBUTE*/
								ElementType: types.StringType,
								Description: "A string array representing the command that the container runs to determine if it is healthy.",
								Optional:    true,
								Computed:    true,
								Validators: []validator.List{ /*START VALIDATORS*/
									listvalidator.SizeBetween(1, 20),
									listvalidator.ValueStringsAre(
										stringvalidator.LengthBetween(1, 255),
										stringvalidator.RegexMatches(regexp.MustCompile("^.*$"), ""),
									),
									fwvalidators.NotNullList(),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
									listplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: Interval
							"interval": schema.Int64Attribute{ /*START ATTRIBUTE*/
								Description: "How often (in seconds) the health is checked.",
								Optional:    true,
								Computed:    true,
								Validators: []validator.Int64{ /*START VALIDATORS*/
									int64validator.Between(60, 300),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
									int64planmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: Retries
							"retries": schema.Int64Attribute{ /*START ATTRIBUTE*/
								Description: "How many times the process manager will retry the command after a timeout. (The first run of the command does not count as a retry.)",
								Optional:    true,
								Computed:    true,
								Validators: []validator.Int64{ /*START VALIDATORS*/
									int64validator.Between(5, 10),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
									int64planmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: StartPeriod
							"start_period": schema.Int64Attribute{ /*START ATTRIBUTE*/
								Description: "The optional grace period (in seconds) to give a container time to boostrap before teh health check is declared failed.",
								Optional:    true,
								Computed:    true,
								Validators: []validator.Int64{ /*START VALIDATORS*/
									int64validator.Between(0, 300),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
									int64planmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: Timeout
							"timeout": schema.Int64Attribute{ /*START ATTRIBUTE*/
								Description: "How many seconds the process manager allows the command to run before canceling it.",
								Optional:    true,
								Computed:    true,
								Validators: []validator.Int64{ /*START VALIDATORS*/
									int64validator.Between(30, 60),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
									int64planmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
						Description: "Specifies how the health of the containers will be checked.",
						Optional:    true,
						Computed:    true,
						PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
							objectplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: ImageUri
					"image_uri": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "Specifies the image URI of this container.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.LengthBetween(1, 255),
							stringvalidator.RegexMatches(regexp.MustCompile("^[a-zA-Z0-9-_\\.@\\/:]+$"), ""),
							fwvalidators.NotNullString(),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: MemoryHardLimitMebibytes
					"memory_hard_limit_mebibytes": schema.Int64Attribute{ /*START ATTRIBUTE*/
						Description: "The total memory limit of container groups following this definition in MiB",
						Optional:    true,
						Computed:    true,
						Validators: []validator.Int64{ /*START VALIDATORS*/
							int64validator.Between(4, 1024000),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
							int64planmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: MountPoints
					"mount_points": schema.SetNestedAttribute{ /*START ATTRIBUTE*/
						NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: AccessLevel
								"access_level": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The access permissions for the mounted path.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.OneOf(
											"READ_ONLY",
											"READ_AND_WRITE",
										),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: ContainerPath
								"container_path": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The path inside the container where the mount is accessible.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthBetween(1, 1024),
										stringvalidator.RegexMatches(regexp.MustCompile("^(\\/+[^\\/]+\\/*)+$"), ""),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: InstancePath
								"instance_path": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The path on the host that will be mounted in the container.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthBetween(1, 1024),
										stringvalidator.RegexMatches(regexp.MustCompile("^\\/[\\s\\S]*$"), ""),
										fwvalidators.NotNullString(),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
						}, /*END NESTED OBJECT*/
						Description: "A list of mount point configurations to be used in a container.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.Set{ /*START VALIDATORS*/
							setvalidator.SizeBetween(1, 10),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.Set{ /*START PLAN MODIFIERS*/
							setplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: PortConfiguration
					"port_configuration": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: ContainerPortRanges
							"container_port_ranges": schema.SetNestedAttribute{ /*START ATTRIBUTE*/
								NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
									Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
										// Property: FromPort
										"from_port": schema.Int64Attribute{ /*START ATTRIBUTE*/
											Description: "A starting value for the range of allowed port numbers.",
											Optional:    true,
											Computed:    true,
											Validators: []validator.Int64{ /*START VALIDATORS*/
												int64validator.Between(1, 60000),
												fwvalidators.NotNullInt64(),
											}, /*END VALIDATORS*/
											PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
												int64planmodifier.UseStateForUnknown(),
											}, /*END PLAN MODIFIERS*/
										}, /*END ATTRIBUTE*/
										// Property: Protocol
										"protocol": schema.StringAttribute{ /*START ATTRIBUTE*/
											Description: "Defines the protocol of these ports.",
											Optional:    true,
											Computed:    true,
											Validators: []validator.String{ /*START VALIDATORS*/
												stringvalidator.OneOf(
													"TCP",
													"UDP",
												),
												fwvalidators.NotNullString(),
											}, /*END VALIDATORS*/
											PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
												stringplanmodifier.UseStateForUnknown(),
											}, /*END PLAN MODIFIERS*/
										}, /*END ATTRIBUTE*/
										// Property: ToPort
										"to_port": schema.Int64Attribute{ /*START ATTRIBUTE*/
											Description: "An ending value for the range of allowed port numbers. Port numbers are end-inclusive. This value must be equal to or greater than FromPort.",
											Optional:    true,
											Computed:    true,
											Validators: []validator.Int64{ /*START VALIDATORS*/
												int64validator.Between(1, 60000),
												fwvalidators.NotNullInt64(),
											}, /*END VALIDATORS*/
											PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
												int64planmodifier.UseStateForUnknown(),
											}, /*END PLAN MODIFIERS*/
										}, /*END ATTRIBUTE*/
									}, /*END SCHEMA*/
								}, /*END NESTED OBJECT*/
								Description: "Specifies one or more ranges of ports on a container.",
								Optional:    true,
								Computed:    true,
								Validators: []validator.Set{ /*START VALIDATORS*/
									setvalidator.SizeBetween(1, 100),
									fwvalidators.NotNullSet(),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.Set{ /*START PLAN MODIFIERS*/
									setplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
						Description: "Defines the ports on the container.",
						Optional:    true,
						Computed:    true,
						PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
							objectplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: ResolvedImageDigest
					"resolved_image_digest": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The digest of the container image.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.RegexMatches(regexp.MustCompile("^sha256:[a-fA-F0-9]{64}$"), ""),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: Vcpu
					"vcpu": schema.Float64Attribute{ /*START ATTRIBUTE*/
						Description: "The number of virtual CPUs to give to the support group",
						Optional:    true,
						Computed:    true,
						Validators: []validator.Float64{ /*START VALIDATORS*/
							float64validator.Between(0.125000, 10.000000),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.Float64{ /*START PLAN MODIFIERS*/
							float64planmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Description: "A collection of support container definitions that define the containers in this group.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.Set{ /*START VALIDATORS*/
				setvalidator.SizeBetween(1, 10),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.Set{ /*START PLAN MODIFIERS*/
				setplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Tags
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "An array of key-value pairs to apply to this resource.",
		//	  "insertionOrder": false,
		//	  "items": {
		//	    "additionalProperties": false,
		//	    "description": "A key-value pair to associate with a resource.",
		//	    "properties": {
		//	      "Key": {
		//	        "description": "The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length.",
		//	        "maxLength": 128,
		//	        "minLength": 1,
		//	        "pattern": "^.*$",
		//	        "type": "string"
		//	      },
		//	      "Value": {
		//	        "description": "The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length.",
		//	        "maxLength": 256,
		//	        "minLength": 0,
		//	        "pattern": "^.*$",
		//	        "type": "string"
		//	      }
		//	    },
		//	    "required": [
		//	      "Key",
		//	      "Value"
		//	    ],
		//	    "type": "object"
		//	  },
		//	  "maxItems": 200,
		//	  "minItems": 0,
		//	  "type": "array",
		//	  "uniqueItems": true
		//	}
		"tags": schema.SetNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: Key
					"key": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.LengthBetween(1, 128),
							stringvalidator.RegexMatches(regexp.MustCompile("^.*$"), ""),
							fwvalidators.NotNullString(),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: Value
					"value": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.LengthBetween(0, 256),
							stringvalidator.RegexMatches(regexp.MustCompile("^.*$"), ""),
							fwvalidators.NotNullString(),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Description: "An array of key-value pairs to apply to this resource.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.Set{ /*START VALIDATORS*/
				setvalidator.SizeBetween(0, 200),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.Set{ /*START PLAN MODIFIERS*/
				setplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: TotalMemoryLimitMebibytes
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The total memory limit of container groups following this definition in MiB",
		//	  "maximum": 1024000,
		//	  "minimum": 4,
		//	  "type": "integer"
		//	}
		"total_memory_limit_mebibytes": schema.Int64Attribute{ /*START ATTRIBUTE*/
			Description: "The total memory limit of container groups following this definition in MiB",
			Required:    true,
			Validators: []validator.Int64{ /*START VALIDATORS*/
				int64validator.Between(4, 1024000),
			}, /*END VALIDATORS*/
		}, /*END ATTRIBUTE*/
		// Property: TotalVcpuLimit
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The total amount of virtual CPUs on the container group definition",
		//	  "maximum": 10,
		//	  "minimum": 0.125,
		//	  "type": "number"
		//	}
		"total_vcpu_limit": schema.Float64Attribute{ /*START ATTRIBUTE*/
			Description: "The total amount of virtual CPUs on the container group definition",
			Required:    true,
			Validators: []validator.Float64{ /*START VALIDATORS*/
				float64validator.Between(0.125000, 10.000000),
			}, /*END VALIDATORS*/
		}, /*END ATTRIBUTE*/
		// Property: VersionDescription
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The description of this version",
		//	  "maxLength": 1024,
		//	  "minLength": 1,
		//	  "type": "string"
		//	}
		"version_description": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The description of this version",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.LengthBetween(1, 1024),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: VersionNumber
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The version of this ContainerGroupDefinition",
		//	  "minimum": 0,
		//	  "type": "integer"
		//	}
		"version_number": schema.Int64Attribute{ /*START ATTRIBUTE*/
			Description: "The version of this ContainerGroupDefinition",
			Computed:    true,
			PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
				int64planmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
	} /*END SCHEMA*/

	// Corresponds to CloudFormation primaryIdentifier.
	attributes["id"] = schema.StringAttribute{
		Description: "Uniquely identifies the resource.",
		Computed:    true,
		PlanModifiers: []planmodifier.String{
			stringplanmodifier.UseStateForUnknown(),
		},
	}

	schema := schema.Schema{
		Description: "The AWS::GameLift::ContainerGroupDefinition resource creates an Amazon GameLift container group definition.",
		Version:     1,
		Attributes:  attributes,
	}

	var opts generic.ResourceOptions

	opts = opts.WithCloudFormationTypeName("AWS::GameLift::ContainerGroupDefinition").WithTerraformTypeName("awscc_gamelift_container_group_definition")
	opts = opts.WithTerraformSchema(schema)
	opts = opts.WithAttributeNameMap(map[string]string{
		"access_level":                     "AccessLevel",
		"command":                          "Command",
		"condition":                        "Condition",
		"container_group_definition_arn":   "ContainerGroupDefinitionArn",
		"container_group_type":             "ContainerGroupType",
		"container_name":                   "ContainerName",
		"container_path":                   "ContainerPath",
		"container_port_ranges":            "ContainerPortRanges",
		"creation_time":                    "CreationTime",
		"depends_on":                       "DependsOn",
		"environment_override":             "EnvironmentOverride",
		"essential":                        "Essential",
		"from_port":                        "FromPort",
		"game_server_container_definition": "GameServerContainerDefinition",
		"health_check":                     "HealthCheck",
		"image_uri":                        "ImageUri",
		"instance_path":                    "InstancePath",
		"interval":                         "Interval",
		"key":                              "Key",
		"memory_hard_limit_mebibytes":      "MemoryHardLimitMebibytes",
		"mount_points":                     "MountPoints",
		"name":                             "Name",
		"operating_system":                 "OperatingSystem",
		"port_configuration":               "PortConfiguration",
		"protocol":                         "Protocol",
		"resolved_image_digest":            "ResolvedImageDigest",
		"retries":                          "Retries",
		"server_sdk_version":               "ServerSdkVersion",
		"source_version_number":            "SourceVersionNumber",
		"start_period":                     "StartPeriod",
		"status":                           "Status",
		"status_reason":                    "StatusReason",
		"support_container_definitions":    "SupportContainerDefinitions",
		"tags":                             "Tags",
		"timeout":                          "Timeout",
		"to_port":                          "ToPort",
		"total_memory_limit_mebibytes":     "TotalMemoryLimitMebibytes",
		"total_vcpu_limit":                 "TotalVcpuLimit",
		"value":                            "Value",
		"vcpu":                             "Vcpu",
		"version_description":              "VersionDescription",
		"version_number":                   "VersionNumber",
	})

	opts = opts.WithCreateTimeoutInMinutes(0).WithDeleteTimeoutInMinutes(0)

	opts = opts.WithUpdateTimeoutInMinutes(0)

	v, err := generic.NewResource(ctx, opts...)

	if err != nil {
		return nil, err
	}

	return v, nil
}
