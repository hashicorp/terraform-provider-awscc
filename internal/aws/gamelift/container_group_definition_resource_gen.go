// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// Code generated by generators/resource/main.go; DO NOT EDIT.

package gamelift

import (
	"context"
	"regexp"

	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/setvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/setplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-provider-awscc/internal/generic"
	"github.com/hashicorp/terraform-provider-awscc/internal/registry"
	fwvalidators "github.com/hashicorp/terraform-provider-awscc/internal/validators"
)

func init() {
	registry.AddResourceFactory("awscc_gamelift_container_group_definition", containerGroupDefinitionResource)
}

// containerGroupDefinitionResource returns the Terraform awscc_gamelift_container_group_definition resource.
// This Terraform resource corresponds to the CloudFormation AWS::GameLift::ContainerGroupDefinition resource.
func containerGroupDefinitionResource(ctx context.Context) (resource.Resource, error) {
	attributes := map[string]schema.Attribute{ /*START SCHEMA*/
		// Property: ContainerDefinitions
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A collection of container definitions that define the containers in this group.",
		//	  "insertionOrder": false,
		//	  "items": {
		//	    "additionalProperties": false,
		//	    "description": "Details about a container that is used in a container fleet",
		//	    "properties": {
		//	      "Command": {
		//	        "description": "The command that's passed to the container.",
		//	        "insertionOrder": true,
		//	        "items": {
		//	          "maxLength": 255,
		//	          "minLength": 1,
		//	          "pattern": "^.*$",
		//	          "type": "string"
		//	        },
		//	        "maxItems": 20,
		//	        "minItems": 1,
		//	        "type": "array",
		//	        "uniqueItems": false
		//	      },
		//	      "ContainerName": {
		//	        "description": "A descriptive label for the container definition. Container definition names must be unique with a container group definition.",
		//	        "maxLength": 128,
		//	        "minLength": 1,
		//	        "pattern": "^[a-zA-Z0-9-]+$",
		//	        "type": "string"
		//	      },
		//	      "Cpu": {
		//	        "description": "The maximum number of CPU units reserved for this container. The value is expressed as an integer amount of CPU units. 1 vCPU is equal to 1024 CPU units",
		//	        "maximum": 10240,
		//	        "minimum": 1,
		//	        "type": "integer"
		//	      },
		//	      "DependsOn": {
		//	        "description": "A list of container dependencies that determines when this container starts up and shuts down. For container groups with multiple containers, dependencies let you define a startup/shutdown sequence across the containers.",
		//	        "insertionOrder": true,
		//	        "items": {
		//	          "additionalProperties": false,
		//	          "description": "A dependency that impacts a container's startup and shutdown.",
		//	          "properties": {
		//	            "Condition": {
		//	              "description": "The type of dependency.",
		//	              "enum": [
		//	                "START",
		//	                "COMPLETE",
		//	                "SUCCESS",
		//	                "HEALTHY"
		//	              ],
		//	              "type": "string"
		//	            },
		//	            "ContainerName": {
		//	              "description": "A descriptive label for the container definition. The container being defined depends on this container's condition.",
		//	              "maxLength": 128,
		//	              "minLength": 1,
		//	              "pattern": "^[a-zA-Z0-9-]+$",
		//	              "type": "string"
		//	            }
		//	          },
		//	          "required": [
		//	            "ContainerName",
		//	            "Condition"
		//	          ],
		//	          "type": "object"
		//	        },
		//	        "maxItems": 10,
		//	        "minItems": 1,
		//	        "type": "array",
		//	        "uniqueItems": true
		//	      },
		//	      "EntryPoint": {
		//	        "description": "The entry point that's passed to the container so that it will run as an executable. If there are multiple arguments, each argument is a string in the array.",
		//	        "insertionOrder": true,
		//	        "items": {
		//	          "maxLength": 1024,
		//	          "minLength": 1,
		//	          "type": "string"
		//	        },
		//	        "maxItems": 20,
		//	        "minItems": 1,
		//	        "type": "array",
		//	        "uniqueItems": false
		//	      },
		//	      "Environment": {
		//	        "description": "The environment variables to pass to a container.",
		//	        "insertionOrder": false,
		//	        "items": {
		//	          "additionalProperties": false,
		//	          "description": "An environment variable to set inside a container, in the form of a key-value pair.",
		//	          "properties": {
		//	            "Name": {
		//	              "description": "The environment variable name.",
		//	              "maxLength": 255,
		//	              "minLength": 1,
		//	              "pattern": "^.*$",
		//	              "type": "string"
		//	            },
		//	            "Value": {
		//	              "description": "The environment variable value.",
		//	              "maxLength": 255,
		//	              "minLength": 1,
		//	              "pattern": "^.*$",
		//	              "type": "string"
		//	            }
		//	          },
		//	          "required": [
		//	            "Name",
		//	            "Value"
		//	          ],
		//	          "type": "object"
		//	        },
		//	        "maxItems": 20,
		//	        "minItems": 1,
		//	        "type": "array",
		//	        "uniqueItems": true
		//	      },
		//	      "Essential": {
		//	        "description": "Specifies if the container is essential. If an essential container fails a health check, then all containers in the container group will be restarted. You must specify exactly 1 essential container in a container group.",
		//	        "type": "boolean"
		//	      },
		//	      "HealthCheck": {
		//	        "additionalProperties": false,
		//	        "description": "Specifies how the health of the containers will be checked.",
		//	        "properties": {
		//	          "Command": {
		//	            "description": "A string array representing the command that the container runs to determine if it is healthy.",
		//	            "insertionOrder": true,
		//	            "items": {
		//	              "maxLength": 255,
		//	              "minLength": 1,
		//	              "pattern": "^.*$",
		//	              "type": "string"
		//	            },
		//	            "maxItems": 20,
		//	            "minItems": 1,
		//	            "type": "array",
		//	            "uniqueItems": false
		//	          },
		//	          "Interval": {
		//	            "description": "How often (in seconds) the health is checked.",
		//	            "maximum": 300,
		//	            "minimum": 60,
		//	            "type": "integer"
		//	          },
		//	          "Retries": {
		//	            "description": "How many times the process manager will retry the command after a timeout. (The first run of the command does not count as a retry.)",
		//	            "maximum": 10,
		//	            "minimum": 5,
		//	            "type": "integer"
		//	          },
		//	          "StartPeriod": {
		//	            "description": "The optional grace period (in seconds) to give a container time to boostrap before teh health check is declared failed.",
		//	            "maximum": 300,
		//	            "minimum": 0,
		//	            "type": "integer"
		//	          },
		//	          "Timeout": {
		//	            "description": "How many seconds the process manager allows the command to run before canceling it.",
		//	            "maximum": 60,
		//	            "minimum": 30,
		//	            "type": "integer"
		//	          }
		//	        },
		//	        "required": [
		//	          "Command"
		//	        ],
		//	        "type": "object"
		//	      },
		//	      "ImageUri": {
		//	        "description": "Specifies the image URI of this container.",
		//	        "maxLength": 255,
		//	        "minLength": 1,
		//	        "pattern": "^[a-zA-Z0-9-_\\.@\\/:]+$",
		//	        "type": "string"
		//	      },
		//	      "MemoryLimits": {
		//	        "additionalProperties": false,
		//	        "description": "Specifies how much memory is available to the container. You must specify at least this parameter or the TotalMemoryLimit parameter of the ContainerGroupDefinition.",
		//	        "properties": {
		//	          "HardLimit": {
		//	            "description": "The hard limit of memory to reserve for the container.",
		//	            "maximum": 1024000,
		//	            "minimum": 4,
		//	            "type": "integer"
		//	          },
		//	          "SoftLimit": {
		//	            "description": "The amount of memory that is reserved for the container.",
		//	            "maximum": 1024000,
		//	            "minimum": 4,
		//	            "type": "integer"
		//	          }
		//	        },
		//	        "type": "object"
		//	      },
		//	      "PortConfiguration": {
		//	        "additionalProperties": false,
		//	        "description": "Defines the ports on the container.",
		//	        "properties": {
		//	          "ContainerPortRanges": {
		//	            "description": "Specifies one or more ranges of ports on a container.",
		//	            "insertionOrder": false,
		//	            "items": {
		//	              "additionalProperties": false,
		//	              "description": "A set of one or more port numbers that can be opened on the container.",
		//	              "properties": {
		//	                "FromPort": {
		//	                  "description": "A starting value for the range of allowed port numbers.",
		//	                  "maximum": 60000,
		//	                  "minimum": 1,
		//	                  "type": "integer"
		//	                },
		//	                "Protocol": {
		//	                  "description": "Defines the protocol of these ports.",
		//	                  "enum": [
		//	                    "TCP",
		//	                    "UDP"
		//	                  ],
		//	                  "type": "string"
		//	                },
		//	                "ToPort": {
		//	                  "description": "An ending value for the range of allowed port numbers. Port numbers are end-inclusive. This value must be equal to or greater than FromPort.",
		//	                  "maximum": 60000,
		//	                  "minimum": 1,
		//	                  "type": "integer"
		//	                }
		//	              },
		//	              "required": [
		//	                "FromPort",
		//	                "Protocol",
		//	                "ToPort"
		//	              ],
		//	              "type": "object"
		//	            },
		//	            "maxItems": 100,
		//	            "minItems": 1,
		//	            "type": "array",
		//	            "uniqueItems": true
		//	          }
		//	        },
		//	        "required": [
		//	          "ContainerPortRanges"
		//	        ],
		//	        "type": "object"
		//	      },
		//	      "ResolvedImageDigest": {
		//	        "description": "The digest of the container image.",
		//	        "pattern": "^sha256:[a-fA-F0-9]{64}$",
		//	        "type": "string"
		//	      },
		//	      "WorkingDirectory": {
		//	        "description": "The working directory to run commands inside the container in.",
		//	        "maxLength": 255,
		//	        "minLength": 1,
		//	        "pattern": "^.*$",
		//	        "type": "string"
		//	      }
		//	    },
		//	    "required": [
		//	      "ContainerName",
		//	      "ImageUri"
		//	    ],
		//	    "type": "object"
		//	  },
		//	  "maxItems": 10,
		//	  "minItems": 1,
		//	  "type": "array",
		//	  "uniqueItems": true
		//	}
		"container_definitions": schema.SetNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: Command
					"command": schema.ListAttribute{ /*START ATTRIBUTE*/
						ElementType: types.StringType,
						Description: "The command that's passed to the container.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.List{ /*START VALIDATORS*/
							listvalidator.SizeBetween(1, 20),
							listvalidator.ValueStringsAre(
								stringvalidator.LengthBetween(1, 255),
								stringvalidator.RegexMatches(regexp.MustCompile("^.*$"), ""),
							),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
							listplanmodifier.UseStateForUnknown(),
							listplanmodifier.RequiresReplaceIfConfigured(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: ContainerName
					"container_name": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "A descriptive label for the container definition. Container definition names must be unique with a container group definition.",
						Required:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.LengthBetween(1, 128),
							stringvalidator.RegexMatches(regexp.MustCompile("^[a-zA-Z0-9-]+$"), ""),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.RequiresReplace(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: Cpu
					"cpu": schema.Int64Attribute{ /*START ATTRIBUTE*/
						Description: "The maximum number of CPU units reserved for this container. The value is expressed as an integer amount of CPU units. 1 vCPU is equal to 1024 CPU units",
						Optional:    true,
						Computed:    true,
						Validators: []validator.Int64{ /*START VALIDATORS*/
							int64validator.Between(1, 10240),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
							int64planmodifier.UseStateForUnknown(),
							int64planmodifier.RequiresReplaceIfConfigured(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: DependsOn
					"depends_on": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
						NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: Condition
								"condition": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The type of dependency.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.OneOf(
											"START",
											"COMPLETE",
											"SUCCESS",
											"HEALTHY",
										),
										fwvalidators.NotNullString(),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
										stringplanmodifier.RequiresReplaceIfConfigured(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: ContainerName
								"container_name": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "A descriptive label for the container definition. The container being defined depends on this container's condition.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthBetween(1, 128),
										stringvalidator.RegexMatches(regexp.MustCompile("^[a-zA-Z0-9-]+$"), ""),
										fwvalidators.NotNullString(),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
										stringplanmodifier.RequiresReplaceIfConfigured(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
						}, /*END NESTED OBJECT*/
						Description: "A list of container dependencies that determines when this container starts up and shuts down. For container groups with multiple containers, dependencies let you define a startup/shutdown sequence across the containers.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.List{ /*START VALIDATORS*/
							listvalidator.SizeBetween(1, 10),
							listvalidator.UniqueValues(),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
							listplanmodifier.UseStateForUnknown(),
							listplanmodifier.RequiresReplaceIfConfigured(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: EntryPoint
					"entry_point": schema.ListAttribute{ /*START ATTRIBUTE*/
						ElementType: types.StringType,
						Description: "The entry point that's passed to the container so that it will run as an executable. If there are multiple arguments, each argument is a string in the array.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.List{ /*START VALIDATORS*/
							listvalidator.SizeBetween(1, 20),
							listvalidator.ValueStringsAre(
								stringvalidator.LengthBetween(1, 1024),
							),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
							listplanmodifier.UseStateForUnknown(),
							listplanmodifier.RequiresReplaceIfConfigured(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: Environment
					"environment": schema.SetNestedAttribute{ /*START ATTRIBUTE*/
						NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: Name
								"name": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The environment variable name.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthBetween(1, 255),
										stringvalidator.RegexMatches(regexp.MustCompile("^.*$"), ""),
										fwvalidators.NotNullString(),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
										stringplanmodifier.RequiresReplaceIfConfigured(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: Value
								"value": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The environment variable value.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.LengthBetween(1, 255),
										stringvalidator.RegexMatches(regexp.MustCompile("^.*$"), ""),
										fwvalidators.NotNullString(),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
										stringplanmodifier.RequiresReplaceIfConfigured(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
						}, /*END NESTED OBJECT*/
						Description: "The environment variables to pass to a container.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.Set{ /*START VALIDATORS*/
							setvalidator.SizeBetween(1, 20),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.Set{ /*START PLAN MODIFIERS*/
							setplanmodifier.UseStateForUnknown(),
							setplanmodifier.RequiresReplaceIfConfigured(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: Essential
					"essential": schema.BoolAttribute{ /*START ATTRIBUTE*/
						Description: "Specifies if the container is essential. If an essential container fails a health check, then all containers in the container group will be restarted. You must specify exactly 1 essential container in a container group.",
						Optional:    true,
						Computed:    true,
						PlanModifiers: []planmodifier.Bool{ /*START PLAN MODIFIERS*/
							boolplanmodifier.UseStateForUnknown(),
							boolplanmodifier.RequiresReplaceIfConfigured(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: HealthCheck
					"health_check": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: Command
							"command": schema.ListAttribute{ /*START ATTRIBUTE*/
								ElementType: types.StringType,
								Description: "A string array representing the command that the container runs to determine if it is healthy.",
								Optional:    true,
								Computed:    true,
								Validators: []validator.List{ /*START VALIDATORS*/
									listvalidator.SizeBetween(1, 20),
									listvalidator.ValueStringsAre(
										stringvalidator.LengthBetween(1, 255),
										stringvalidator.RegexMatches(regexp.MustCompile("^.*$"), ""),
									),
									fwvalidators.NotNullList(),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
									listplanmodifier.UseStateForUnknown(),
									listplanmodifier.RequiresReplaceIfConfigured(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: Interval
							"interval": schema.Int64Attribute{ /*START ATTRIBUTE*/
								Description: "How often (in seconds) the health is checked.",
								Optional:    true,
								Computed:    true,
								Validators: []validator.Int64{ /*START VALIDATORS*/
									int64validator.Between(60, 300),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
									int64planmodifier.UseStateForUnknown(),
									int64planmodifier.RequiresReplaceIfConfigured(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: Retries
							"retries": schema.Int64Attribute{ /*START ATTRIBUTE*/
								Description: "How many times the process manager will retry the command after a timeout. (The first run of the command does not count as a retry.)",
								Optional:    true,
								Computed:    true,
								Validators: []validator.Int64{ /*START VALIDATORS*/
									int64validator.Between(5, 10),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
									int64planmodifier.UseStateForUnknown(),
									int64planmodifier.RequiresReplaceIfConfigured(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: StartPeriod
							"start_period": schema.Int64Attribute{ /*START ATTRIBUTE*/
								Description: "The optional grace period (in seconds) to give a container time to boostrap before teh health check is declared failed.",
								Optional:    true,
								Computed:    true,
								Validators: []validator.Int64{ /*START VALIDATORS*/
									int64validator.Between(0, 300),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
									int64planmodifier.UseStateForUnknown(),
									int64planmodifier.RequiresReplaceIfConfigured(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: Timeout
							"timeout": schema.Int64Attribute{ /*START ATTRIBUTE*/
								Description: "How many seconds the process manager allows the command to run before canceling it.",
								Optional:    true,
								Computed:    true,
								Validators: []validator.Int64{ /*START VALIDATORS*/
									int64validator.Between(30, 60),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
									int64planmodifier.UseStateForUnknown(),
									int64planmodifier.RequiresReplaceIfConfigured(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
						Description: "Specifies how the health of the containers will be checked.",
						Optional:    true,
						Computed:    true,
						PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
							objectplanmodifier.UseStateForUnknown(),
							objectplanmodifier.RequiresReplaceIfConfigured(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: ImageUri
					"image_uri": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "Specifies the image URI of this container.",
						Required:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.LengthBetween(1, 255),
							stringvalidator.RegexMatches(regexp.MustCompile("^[a-zA-Z0-9-_\\.@\\/:]+$"), ""),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.RequiresReplace(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: MemoryLimits
					"memory_limits": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: HardLimit
							"hard_limit": schema.Int64Attribute{ /*START ATTRIBUTE*/
								Description: "The hard limit of memory to reserve for the container.",
								Optional:    true,
								Computed:    true,
								Validators: []validator.Int64{ /*START VALIDATORS*/
									int64validator.Between(4, 1024000),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
									int64planmodifier.UseStateForUnknown(),
									int64planmodifier.RequiresReplaceIfConfigured(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: SoftLimit
							"soft_limit": schema.Int64Attribute{ /*START ATTRIBUTE*/
								Description: "The amount of memory that is reserved for the container.",
								Optional:    true,
								Computed:    true,
								Validators: []validator.Int64{ /*START VALIDATORS*/
									int64validator.Between(4, 1024000),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
									int64planmodifier.UseStateForUnknown(),
									int64planmodifier.RequiresReplaceIfConfigured(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
						Description: "Specifies how much memory is available to the container. You must specify at least this parameter or the TotalMemoryLimit parameter of the ContainerGroupDefinition.",
						Optional:    true,
						Computed:    true,
						PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
							objectplanmodifier.UseStateForUnknown(),
							objectplanmodifier.RequiresReplaceIfConfigured(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: PortConfiguration
					"port_configuration": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: ContainerPortRanges
							"container_port_ranges": schema.SetNestedAttribute{ /*START ATTRIBUTE*/
								NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
									Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
										// Property: FromPort
										"from_port": schema.Int64Attribute{ /*START ATTRIBUTE*/
											Description: "A starting value for the range of allowed port numbers.",
											Optional:    true,
											Computed:    true,
											Validators: []validator.Int64{ /*START VALIDATORS*/
												int64validator.Between(1, 60000),
												fwvalidators.NotNullInt64(),
											}, /*END VALIDATORS*/
											PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
												int64planmodifier.UseStateForUnknown(),
												int64planmodifier.RequiresReplaceIfConfigured(),
											}, /*END PLAN MODIFIERS*/
										}, /*END ATTRIBUTE*/
										// Property: Protocol
										"protocol": schema.StringAttribute{ /*START ATTRIBUTE*/
											Description: "Defines the protocol of these ports.",
											Optional:    true,
											Computed:    true,
											Validators: []validator.String{ /*START VALIDATORS*/
												stringvalidator.OneOf(
													"TCP",
													"UDP",
												),
												fwvalidators.NotNullString(),
											}, /*END VALIDATORS*/
											PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
												stringplanmodifier.UseStateForUnknown(),
												stringplanmodifier.RequiresReplaceIfConfigured(),
											}, /*END PLAN MODIFIERS*/
										}, /*END ATTRIBUTE*/
										// Property: ToPort
										"to_port": schema.Int64Attribute{ /*START ATTRIBUTE*/
											Description: "An ending value for the range of allowed port numbers. Port numbers are end-inclusive. This value must be equal to or greater than FromPort.",
											Optional:    true,
											Computed:    true,
											Validators: []validator.Int64{ /*START VALIDATORS*/
												int64validator.Between(1, 60000),
												fwvalidators.NotNullInt64(),
											}, /*END VALIDATORS*/
											PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
												int64planmodifier.UseStateForUnknown(),
												int64planmodifier.RequiresReplaceIfConfigured(),
											}, /*END PLAN MODIFIERS*/
										}, /*END ATTRIBUTE*/
									}, /*END SCHEMA*/
								}, /*END NESTED OBJECT*/
								Description: "Specifies one or more ranges of ports on a container.",
								Optional:    true,
								Computed:    true,
								Validators: []validator.Set{ /*START VALIDATORS*/
									setvalidator.SizeBetween(1, 100),
									fwvalidators.NotNullSet(),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.Set{ /*START PLAN MODIFIERS*/
									setplanmodifier.UseStateForUnknown(),
									setplanmodifier.RequiresReplaceIfConfigured(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
						Description: "Defines the ports on the container.",
						Optional:    true,
						Computed:    true,
						PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
							objectplanmodifier.UseStateForUnknown(),
							objectplanmodifier.RequiresReplaceIfConfigured(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: ResolvedImageDigest
					"resolved_image_digest": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The digest of the container image.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.RegexMatches(regexp.MustCompile("^sha256:[a-fA-F0-9]{64}$"), ""),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
							stringplanmodifier.RequiresReplaceIfConfigured(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: WorkingDirectory
					"working_directory": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The working directory to run commands inside the container in.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.LengthBetween(1, 255),
							stringvalidator.RegexMatches(regexp.MustCompile("^.*$"), ""),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
							stringplanmodifier.RequiresReplaceIfConfigured(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Description: "A collection of container definitions that define the containers in this group.",
			Required:    true,
			Validators: []validator.Set{ /*START VALIDATORS*/
				setvalidator.SizeBetween(1, 10),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.Set{ /*START PLAN MODIFIERS*/
				setplanmodifier.RequiresReplace(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: ContainerGroupDefinitionArn
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The Amazon Resource Name (ARN) that is assigned to a Amazon GameLift container group resource and uniquely identifies it across all AWS Regions.",
		//	  "maxLength": 512,
		//	  "minLength": 1,
		//	  "pattern": "^arn:.*:containergroupdefinition/containergroupdefinition-[a-zA-Z0-9-]+$|^arn:.*:containergroupdefinition/[a-zA-Z0-9-\\:]+$",
		//	  "type": "string"
		//	}
		"container_group_definition_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The Amazon Resource Name (ARN) that is assigned to a Amazon GameLift container group resource and uniquely identifies it across all AWS Regions.",
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: CreationTime
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A time stamp indicating when this data object was created. Format is a number expressed in Unix time as milliseconds (for example \"1469498468.057\").",
		//	  "type": "string"
		//	}
		"creation_time": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "A time stamp indicating when this data object was created. Format is a number expressed in Unix time as milliseconds (for example \"1469498468.057\").",
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Name
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A descriptive label for the container group definition.",
		//	  "maxLength": 128,
		//	  "minLength": 1,
		//	  "pattern": "^[a-zA-Z0-9-]+$",
		//	  "type": "string"
		//	}
		"name": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "A descriptive label for the container group definition.",
			Required:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.LengthBetween(1, 128),
				stringvalidator.RegexMatches(regexp.MustCompile("^[a-zA-Z0-9-]+$"), ""),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.RequiresReplace(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: OperatingSystem
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The operating system of the container group",
		//	  "enum": [
		//	    "AMAZON_LINUX_2023"
		//	  ],
		//	  "type": "string"
		//	}
		"operating_system": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The operating system of the container group",
			Required:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.OneOf(
					"AMAZON_LINUX_2023",
				),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.RequiresReplace(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: SchedulingStrategy
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "Specifies whether the container group includes replica or daemon containers.",
		//	  "enum": [
		//	    "REPLICA",
		//	    "DAEMON"
		//	  ],
		//	  "type": "string"
		//	}
		"scheduling_strategy": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "Specifies whether the container group includes replica or daemon containers.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.OneOf(
					"REPLICA",
					"DAEMON",
				),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
				stringplanmodifier.RequiresReplaceIfConfigured(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Tags
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "An array of key-value pairs to apply to this resource.",
		//	  "insertionOrder": false,
		//	  "items": {
		//	    "additionalProperties": false,
		//	    "description": "A key-value pair to associate with a resource.",
		//	    "properties": {
		//	      "Key": {
		//	        "description": "The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length.",
		//	        "maxLength": 128,
		//	        "minLength": 1,
		//	        "pattern": "^.*$",
		//	        "type": "string"
		//	      },
		//	      "Value": {
		//	        "description": "The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length.",
		//	        "maxLength": 256,
		//	        "minLength": 0,
		//	        "pattern": "^.*$",
		//	        "type": "string"
		//	      }
		//	    },
		//	    "required": [
		//	      "Key",
		//	      "Value"
		//	    ],
		//	    "type": "object"
		//	  },
		//	  "maxItems": 200,
		//	  "minItems": 0,
		//	  "type": "array",
		//	  "uniqueItems": true
		//	}
		"tags": schema.SetNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: Key
					"key": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.LengthBetween(1, 128),
							stringvalidator.RegexMatches(regexp.MustCompile("^.*$"), ""),
							fwvalidators.NotNullString(),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: Value
					"value": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.LengthBetween(0, 256),
							stringvalidator.RegexMatches(regexp.MustCompile("^.*$"), ""),
							fwvalidators.NotNullString(),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Description: "An array of key-value pairs to apply to this resource.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.Set{ /*START VALIDATORS*/
				setvalidator.SizeBetween(0, 200),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.Set{ /*START PLAN MODIFIERS*/
				setplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: TotalCpuLimit
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The maximum number of CPU units reserved for this container group. The value is expressed as an integer amount of CPU units. (1 vCPU is equal to 1024 CPU units.)",
		//	  "maximum": 10240,
		//	  "minimum": 128,
		//	  "type": "integer"
		//	}
		"total_cpu_limit": schema.Int64Attribute{ /*START ATTRIBUTE*/
			Description: "The maximum number of CPU units reserved for this container group. The value is expressed as an integer amount of CPU units. (1 vCPU is equal to 1024 CPU units.)",
			Required:    true,
			Validators: []validator.Int64{ /*START VALIDATORS*/
				int64validator.Between(128, 10240),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
				int64planmodifier.RequiresReplace(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: TotalMemoryLimit
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The maximum amount of memory (in MiB) to allocate for this container group.",
		//	  "maximum": 1024000,
		//	  "minimum": 4,
		//	  "type": "integer"
		//	}
		"total_memory_limit": schema.Int64Attribute{ /*START ATTRIBUTE*/
			Description: "The maximum amount of memory (in MiB) to allocate for this container group.",
			Required:    true,
			Validators: []validator.Int64{ /*START VALIDATORS*/
				int64validator.Between(4, 1024000),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
				int64planmodifier.RequiresReplace(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
	} /*END SCHEMA*/

	// Corresponds to CloudFormation primaryIdentifier.
	attributes["id"] = schema.StringAttribute{
		Description: "Uniquely identifies the resource.",
		Computed:    true,
		PlanModifiers: []planmodifier.String{
			stringplanmodifier.UseStateForUnknown(),
		},
	}

	schema := schema.Schema{
		Description: "The AWS::GameLift::ContainerGroupDefinition resource creates an Amazon GameLift container group definition.",
		Version:     1,
		Attributes:  attributes,
	}

	var opts generic.ResourceOptions

	opts = opts.WithCloudFormationTypeName("AWS::GameLift::ContainerGroupDefinition").WithTerraformTypeName("awscc_gamelift_container_group_definition")
	opts = opts.WithTerraformSchema(schema)
	opts = opts.WithAttributeNameMap(map[string]string{
		"command":                        "Command",
		"condition":                      "Condition",
		"container_definitions":          "ContainerDefinitions",
		"container_group_definition_arn": "ContainerGroupDefinitionArn",
		"container_name":                 "ContainerName",
		"container_port_ranges":          "ContainerPortRanges",
		"cpu":                            "Cpu",
		"creation_time":                  "CreationTime",
		"depends_on":                     "DependsOn",
		"entry_point":                    "EntryPoint",
		"environment":                    "Environment",
		"essential":                      "Essential",
		"from_port":                      "FromPort",
		"hard_limit":                     "HardLimit",
		"health_check":                   "HealthCheck",
		"image_uri":                      "ImageUri",
		"interval":                       "Interval",
		"key":                            "Key",
		"memory_limits":                  "MemoryLimits",
		"name":                           "Name",
		"operating_system":               "OperatingSystem",
		"port_configuration":             "PortConfiguration",
		"protocol":                       "Protocol",
		"resolved_image_digest":          "ResolvedImageDigest",
		"retries":                        "Retries",
		"scheduling_strategy":            "SchedulingStrategy",
		"soft_limit":                     "SoftLimit",
		"start_period":                   "StartPeriod",
		"tags":                           "Tags",
		"timeout":                        "Timeout",
		"to_port":                        "ToPort",
		"total_cpu_limit":                "TotalCpuLimit",
		"total_memory_limit":             "TotalMemoryLimit",
		"value":                          "Value",
		"working_directory":              "WorkingDirectory",
	})

	opts = opts.WithCreateTimeoutInMinutes(0).WithDeleteTimeoutInMinutes(0)

	opts = opts.WithUpdateTimeoutInMinutes(0)

	v, err := generic.NewResource(ctx, opts...)

	if err != nil {
		return nil, err
	}

	return v, nil
}
