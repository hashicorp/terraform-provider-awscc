// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// Code generated by generators/resource/main.go; DO NOT EDIT.

package gamelift

import (
	"context"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/float64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-provider-awscc/internal/generic"
	"github.com/hashicorp/terraform-provider-awscc/internal/registry"
	"regexp"
)

func init() {
	registry.AddResourceFactory("awscc_gamelift_fleet", fleetResource)
}

// fleetResource returns the Terraform awscc_gamelift_fleet resource.
// This Terraform resource corresponds to the CloudFormation AWS::GameLift::Fleet resource.
func fleetResource(ctx context.Context) (resource.Resource, error) {
	attributes := map[string]schema.Attribute{ /*START SCHEMA*/
		// Property: AnywhereConfiguration
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "Configuration for Anywhere fleet.",
		//	  "properties": {
		//	    "Cost": {
		//	      "description": "Cost of compute can be specified on Anywhere Fleets to prioritize placement across Queue destinations based on Cost.",
		//	      "maxLength": 11,
		//	      "minLength": 1,
		//	      "pattern": "^\\d{1,5}(?:\\.\\d{1,5})?$",
		//	      "type": "string"
		//	    }
		//	  },
		//	  "required": [
		//	    "Cost"
		//	  ]
		//	}
		"anywhere_configuration": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: Cost
				"cost": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "Cost of compute can be specified on Anywhere Fleets to prioritize placement across Queue destinations based on Cost.",
					Required:    true,
					Validators: []validator.String{ /*START VALIDATORS*/
						stringvalidator.LengthBetween(1, 11),
						stringvalidator.RegexMatches(regexp.MustCompile("^\\d{1,5}(?:\\.\\d{1,5})?$"), ""),
					}, /*END VALIDATORS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "Configuration for Anywhere fleet.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: ApplyCapacity
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "Determines whether to apply fleet or location capacities on fleet creation.",
		//	  "enum": [
		//	    "ON_UPDATE",
		//	    "ON_CREATE_AND_UPDATE"
		//	  ],
		//	  "type": "string"
		//	}
		"apply_capacity": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "Determines whether to apply fleet or location capacities on fleet creation.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.OneOf(
					"ON_UPDATE",
					"ON_CREATE_AND_UPDATE",
				),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
				stringplanmodifier.RequiresReplace(),
			}, /*END PLAN MODIFIERS*/
			// ApplyCapacity is a write-only property.
		}, /*END ATTRIBUTE*/
		// Property: BuildId
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A unique identifier for a build to be deployed on the new fleet. If you are deploying the fleet with a custom game build, you must specify this property. The build must have been successfully uploaded to Amazon GameLift and be in a READY status. This fleet setting cannot be changed once the fleet is created.",
		//	  "pattern": "^build-\\S+|^arn:.*:build/build-\\S+",
		//	  "type": "string"
		//	}
		"build_id": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "A unique identifier for a build to be deployed on the new fleet. If you are deploying the fleet with a custom game build, you must specify this property. The build must have been successfully uploaded to Amazon GameLift and be in a READY status. This fleet setting cannot be changed once the fleet is created.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.RegexMatches(regexp.MustCompile("^build-\\S+|^arn:.*:build/build-\\S+"), ""),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
				stringplanmodifier.RequiresReplace(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: CertificateConfiguration
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "Indicates whether to generate a TLS/SSL certificate for the new fleet. TLS certificates are used for encrypting traffic between game clients and game servers running on GameLift. If this parameter is not set, certificate generation is disabled. This fleet setting cannot be changed once the fleet is created.",
		//	  "properties": {
		//	    "CertificateType": {
		//	      "enum": [
		//	        "DISABLED",
		//	        "GENERATED"
		//	      ],
		//	      "type": "string"
		//	    }
		//	  },
		//	  "required": [
		//	    "CertificateType"
		//	  ],
		//	  "type": "object"
		//	}
		"certificate_configuration": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: CertificateType
				"certificate_type": schema.StringAttribute{ /*START ATTRIBUTE*/
					Required: true,
					Validators: []validator.String{ /*START VALIDATORS*/
						stringvalidator.OneOf(
							"DISABLED",
							"GENERATED",
						),
					}, /*END VALIDATORS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "Indicates whether to generate a TLS/SSL certificate for the new fleet. TLS certificates are used for encrypting traffic between game clients and game servers running on GameLift. If this parameter is not set, certificate generation is disabled. This fleet setting cannot be changed once the fleet is created.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
				objectplanmodifier.RequiresReplace(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: ComputeType
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "ComputeType to differentiate EC2 hardware managed by GameLift and Anywhere hardware managed by the customer.",
		//	  "enum": [
		//	    "EC2",
		//	    "ANYWHERE"
		//	  ],
		//	  "type": "string"
		//	}
		"compute_type": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "ComputeType to differentiate EC2 hardware managed by GameLift and Anywhere hardware managed by the customer.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.OneOf(
					"EC2",
					"ANYWHERE",
				),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
				stringplanmodifier.RequiresReplace(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Description
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A human-readable description of a fleet.",
		//	  "maxLength": 1024,
		//	  "minLength": 1,
		//	  "type": "string"
		//	}
		"description": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "A human-readable description of a fleet.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.LengthBetween(1, 1024),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: DesiredEC2Instances
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "[DEPRECATED] The number of EC2 instances that you want this fleet to host. When creating a new fleet, GameLift automatically sets this value to \"1\" and initiates a single instance. Once the fleet is active, update this value to trigger GameLift to add or remove instances from the fleet.",
		//	  "minimum": 0,
		//	  "type": "integer"
		//	}
		"desired_ec2_instances": schema.Int64Attribute{ /*START ATTRIBUTE*/
			Description: "[DEPRECATED] The number of EC2 instances that you want this fleet to host. When creating a new fleet, GameLift automatically sets this value to \"1\" and initiates a single instance. Once the fleet is active, update this value to trigger GameLift to add or remove instances from the fleet.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.Int64{ /*START VALIDATORS*/
				int64validator.AtLeast(0),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
				int64planmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: EC2InboundPermissions
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A range of IP addresses and port settings that allow inbound traffic to connect to server processes on an Amazon GameLift server.",
		//	  "insertionOrder": false,
		//	  "items": {
		//	    "additionalProperties": false,
		//	    "description": "A range of IP addresses and port settings that allow inbound traffic to connect to server processes on an Amazon GameLift hosting resource. New game sessions that are started on the fleet are assigned an IP address/port number combination, which must fall into the fleet's allowed ranges. For fleets created with a custom game server, the ranges reflect the server's game session assignments. For Realtime Servers fleets, Amazon GameLift automatically opens two port ranges, one for TCP messaging and one for UDP, for use by the Realtime servers.",
		//	    "properties": {
		//	      "FromPort": {
		//	        "description": "A starting value for a range of allowed port numbers.",
		//	        "maximum": 60000,
		//	        "minimum": 1,
		//	        "type": "integer"
		//	      },
		//	      "IpRange": {
		//	        "description": "A range of allowed IP addresses. This value must be expressed in CIDR notation. Example: \"000.000.000.000/[subnet mask]\" or optionally the shortened version \"0.0.0.0/[subnet mask]\".",
		//	        "pattern": "(^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(/([0-9]|[1-2][0-9]|3[0-2]))$)",
		//	        "type": "string"
		//	      },
		//	      "Protocol": {
		//	        "description": "The network communication protocol used by the fleet.",
		//	        "enum": [
		//	          "TCP",
		//	          "UDP"
		//	        ],
		//	        "type": "string"
		//	      },
		//	      "ToPort": {
		//	        "description": "An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than FromPort.",
		//	        "maximum": 60000,
		//	        "minimum": 1,
		//	        "type": "integer"
		//	      }
		//	    },
		//	    "required": [
		//	      "FromPort",
		//	      "IpRange",
		//	      "Protocol",
		//	      "ToPort"
		//	    ],
		//	    "type": "object"
		//	  },
		//	  "maxItems": 50,
		//	  "type": "array"
		//	}
		"ec2_inbound_permissions": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: FromPort
					"from_port": schema.Int64Attribute{ /*START ATTRIBUTE*/
						Description: "A starting value for a range of allowed port numbers.",
						Required:    true,
						Validators: []validator.Int64{ /*START VALIDATORS*/
							int64validator.Between(1, 60000),
						}, /*END VALIDATORS*/
					}, /*END ATTRIBUTE*/
					// Property: IpRange
					"ip_range": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "A range of allowed IP addresses. This value must be expressed in CIDR notation. Example: \"000.000.000.000/[subnet mask]\" or optionally the shortened version \"0.0.0.0/[subnet mask]\".",
						Required:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.RegexMatches(regexp.MustCompile("(^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(/([0-9]|[1-2][0-9]|3[0-2]))$)"), ""),
						}, /*END VALIDATORS*/
					}, /*END ATTRIBUTE*/
					// Property: Protocol
					"protocol": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The network communication protocol used by the fleet.",
						Required:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.OneOf(
								"TCP",
								"UDP",
							),
						}, /*END VALIDATORS*/
					}, /*END ATTRIBUTE*/
					// Property: ToPort
					"to_port": schema.Int64Attribute{ /*START ATTRIBUTE*/
						Description: "An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than FromPort.",
						Required:    true,
						Validators: []validator.Int64{ /*START VALIDATORS*/
							int64validator.Between(1, 60000),
						}, /*END VALIDATORS*/
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Description: "A range of IP addresses and port settings that allow inbound traffic to connect to server processes on an Amazon GameLift server.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.List{ /*START VALIDATORS*/
				listvalidator.SizeAtMost(50),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
				generic.Multiset(),
				listplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: EC2InstanceType
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The name of an EC2 instance type that is supported in Amazon GameLift. A fleet instance type determines the computing resources of each instance in the fleet, including CPU, memory, storage, and networking capacity. Amazon GameLift supports the following EC2 instance types. See Amazon EC2 Instance Types for detailed descriptions.",
		//	  "pattern": "^.*..*$",
		//	  "type": "string"
		//	}
		"ec2_instance_type": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The name of an EC2 instance type that is supported in Amazon GameLift. A fleet instance type determines the computing resources of each instance in the fleet, including CPU, memory, storage, and networking capacity. Amazon GameLift supports the following EC2 instance types. See Amazon EC2 Instance Types for detailed descriptions.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.RegexMatches(regexp.MustCompile("^.*..*$"), ""),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
				stringplanmodifier.RequiresReplace(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: FleetId
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "Unique fleet ID",
		//	  "pattern": "^fleet-\\S+",
		//	  "type": "string"
		//	}
		"fleet_id": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "Unique fleet ID",
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: FleetType
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "Indicates whether to use On-Demand instances or Spot instances for this fleet. If empty, the default is ON_DEMAND. Both categories of instances use identical hardware and configurations based on the instance type selected for this fleet.",
		//	  "enum": [
		//	    "ON_DEMAND",
		//	    "SPOT"
		//	  ],
		//	  "type": "string"
		//	}
		"fleet_type": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "Indicates whether to use On-Demand instances or Spot instances for this fleet. If empty, the default is ON_DEMAND. Both categories of instances use identical hardware and configurations based on the instance type selected for this fleet.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.OneOf(
					"ON_DEMAND",
					"SPOT",
				),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
				stringplanmodifier.RequiresReplace(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: InstanceRoleARN
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A unique identifier for an AWS IAM role that manages access to your AWS services. With an instance role ARN set, any application that runs on an instance in this fleet can assume the role, including install scripts, server processes, and daemons (background processes). Create a role or look up a role's ARN from the IAM dashboard in the AWS Management Console.",
		//	  "minLength": 1,
		//	  "pattern": "^arn:aws(-.*)?:[a-z-]+:(([a-z]+-)+[0-9])?:([0-9]{12})?:[^.]+$",
		//	  "type": "string"
		//	}
		"instance_role_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "A unique identifier for an AWS IAM role that manages access to your AWS services. With an instance role ARN set, any application that runs on an instance in this fleet can assume the role, including install scripts, server processes, and daemons (background processes). Create a role or look up a role's ARN from the IAM dashboard in the AWS Management Console.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.LengthAtLeast(1),
				stringvalidator.RegexMatches(regexp.MustCompile("^arn:aws(-.*)?:[a-z-]+:(([a-z]+-)+[0-9])?:([0-9]{12})?:[^.]+$"), ""),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
				stringplanmodifier.RequiresReplace(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: InstanceRoleCredentialsProvider
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "Credentials provider implementation that loads credentials from the Amazon EC2 Instance Metadata Service.",
		//	  "enum": [
		//	    "SHARED_CREDENTIAL_FILE"
		//	  ],
		//	  "type": "string"
		//	}
		"instance_role_credentials_provider": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "Credentials provider implementation that loads credentials from the Amazon EC2 Instance Metadata Service.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.OneOf(
					"SHARED_CREDENTIAL_FILE",
				),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
				stringplanmodifier.RequiresReplace(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Locations
		// CloudFormation resource type schema:
		//
		//	{
		//	  "insertionOrder": false,
		//	  "items": {
		//	    "additionalProperties": false,
		//	    "description": "A remote location where a multi-location fleet can deploy EC2 instances for game hosting.",
		//	    "properties": {
		//	      "Location": {
		//	        "maxLength": 64,
		//	        "minLength": 1,
		//	        "pattern": "^[A-Za-z0-9\\-]+",
		//	        "type": "string"
		//	      },
		//	      "LocationCapacity": {
		//	        "additionalProperties": false,
		//	        "description": "Current resource capacity settings in a specified fleet or location. The location value might refer to a fleet's remote location or its home Region.",
		//	        "properties": {
		//	          "DesiredEC2Instances": {
		//	            "description": "The number of EC2 instances you want to maintain in the specified fleet location. This value must fall between the minimum and maximum size limits.",
		//	            "minimum": 0,
		//	            "type": "integer"
		//	          },
		//	          "MaxSize": {
		//	            "description": "The maximum value that is allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to \"1\". Once the fleet is active, you can change this value.",
		//	            "minimum": 0,
		//	            "type": "integer"
		//	          },
		//	          "MinSize": {
		//	            "description": "The minimum value allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to \"0\". After the fleet is active, you can change this value.",
		//	            "minimum": 0,
		//	            "type": "integer"
		//	          }
		//	        },
		//	        "required": [
		//	          "DesiredEC2Instances",
		//	          "MinSize",
		//	          "MaxSize"
		//	        ],
		//	        "type": "object"
		//	      }
		//	    },
		//	    "required": [
		//	      "Location"
		//	    ],
		//	    "type": "object"
		//	  },
		//	  "maxItems": 100,
		//	  "minItems": 1,
		//	  "type": "array"
		//	}
		"locations": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: Location
					"location": schema.StringAttribute{ /*START ATTRIBUTE*/
						Required: true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.LengthBetween(1, 64),
							stringvalidator.RegexMatches(regexp.MustCompile("^[A-Za-z0-9\\-]+"), ""),
						}, /*END VALIDATORS*/
					}, /*END ATTRIBUTE*/
					// Property: LocationCapacity
					"location_capacity": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: DesiredEC2Instances
							"desired_ec2_instances": schema.Int64Attribute{ /*START ATTRIBUTE*/
								Description: "The number of EC2 instances you want to maintain in the specified fleet location. This value must fall between the minimum and maximum size limits.",
								Required:    true,
								Validators: []validator.Int64{ /*START VALIDATORS*/
									int64validator.AtLeast(0),
								}, /*END VALIDATORS*/
							}, /*END ATTRIBUTE*/
							// Property: MaxSize
							"max_size": schema.Int64Attribute{ /*START ATTRIBUTE*/
								Description: "The maximum value that is allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to \"1\". Once the fleet is active, you can change this value.",
								Required:    true,
								Validators: []validator.Int64{ /*START VALIDATORS*/
									int64validator.AtLeast(0),
								}, /*END VALIDATORS*/
							}, /*END ATTRIBUTE*/
							// Property: MinSize
							"min_size": schema.Int64Attribute{ /*START ATTRIBUTE*/
								Description: "The minimum value allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to \"0\". After the fleet is active, you can change this value.",
								Required:    true,
								Validators: []validator.Int64{ /*START VALIDATORS*/
									int64validator.AtLeast(0),
								}, /*END VALIDATORS*/
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
						Description: "Current resource capacity settings in a specified fleet or location. The location value might refer to a fleet's remote location or its home Region.",
						Optional:    true,
						Computed:    true,
						PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
							objectplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Optional: true,
			Computed: true,
			Validators: []validator.List{ /*START VALIDATORS*/
				listvalidator.SizeBetween(1, 100),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
				generic.Multiset(),
				listplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: LogPaths
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "This parameter is no longer used. When hosting a custom game build, specify where Amazon GameLift should store log files using the Amazon GameLift server API call ProcessReady()",
		//	  "insertionOrder": false,
		//	  "items": {
		//	    "type": "string"
		//	  },
		//	  "type": "array"
		//	}
		"log_paths": schema.ListAttribute{ /*START ATTRIBUTE*/
			ElementType: types.StringType,
			Description: "This parameter is no longer used. When hosting a custom game build, specify where Amazon GameLift should store log files using the Amazon GameLift server API call ProcessReady()",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
				generic.Multiset(),
				listplanmodifier.UseStateForUnknown(),
				listplanmodifier.RequiresReplace(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: MaxSize
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "[DEPRECATED] The maximum value that is allowed for the fleet's instance count. When creating a new fleet, GameLift automatically sets this value to \"1\". Once the fleet is active, you can change this value.",
		//	  "minimum": 0,
		//	  "type": "integer"
		//	}
		"max_size": schema.Int64Attribute{ /*START ATTRIBUTE*/
			Description: "[DEPRECATED] The maximum value that is allowed for the fleet's instance count. When creating a new fleet, GameLift automatically sets this value to \"1\". Once the fleet is active, you can change this value.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.Int64{ /*START VALIDATORS*/
				int64validator.AtLeast(0),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
				int64planmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: MetricGroups
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The name of an Amazon CloudWatch metric group. A metric group aggregates the metrics for all fleets in the group. Specify a string containing the metric group name. You can use an existing name or use a new name to create a new metric group. Currently, this parameter can have only one string.",
		//	  "insertionOrder": false,
		//	  "items": {
		//	    "type": "string"
		//	  },
		//	  "maxItems": 1,
		//	  "type": "array"
		//	}
		"metric_groups": schema.ListAttribute{ /*START ATTRIBUTE*/
			ElementType: types.StringType,
			Description: "The name of an Amazon CloudWatch metric group. A metric group aggregates the metrics for all fleets in the group. Specify a string containing the metric group name. You can use an existing name or use a new name to create a new metric group. Currently, this parameter can have only one string.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.List{ /*START VALIDATORS*/
				listvalidator.SizeAtMost(1),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
				generic.Multiset(),
				listplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: MinSize
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "[DEPRECATED] The minimum value allowed for the fleet's instance count. When creating a new fleet, GameLift automatically sets this value to \"0\". After the fleet is active, you can change this value.",
		//	  "minimum": 0,
		//	  "type": "integer"
		//	}
		"min_size": schema.Int64Attribute{ /*START ATTRIBUTE*/
			Description: "[DEPRECATED] The minimum value allowed for the fleet's instance count. When creating a new fleet, GameLift automatically sets this value to \"0\". After the fleet is active, you can change this value.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.Int64{ /*START VALIDATORS*/
				int64validator.AtLeast(0),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
				int64planmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Name
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A descriptive label that is associated with a fleet. Fleet names do not need to be unique.",
		//	  "maxLength": 1024,
		//	  "minLength": 1,
		//	  "type": "string"
		//	}
		"name": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "A descriptive label that is associated with a fleet. Fleet names do not need to be unique.",
			Required:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.LengthBetween(1, 1024),
			}, /*END VALIDATORS*/
		}, /*END ATTRIBUTE*/
		// Property: NewGameSessionProtectionPolicy
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A game session protection policy to apply to all game sessions hosted on instances in this fleet. When protected, active game sessions cannot be terminated during a scale-down event. If this parameter is not set, instances in this fleet default to no protection. You can change a fleet's protection policy to affect future game sessions on the fleet. You can also set protection for individual game sessions.",
		//	  "enum": [
		//	    "FullProtection",
		//	    "NoProtection"
		//	  ],
		//	  "type": "string"
		//	}
		"new_game_session_protection_policy": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "A game session protection policy to apply to all game sessions hosted on instances in this fleet. When protected, active game sessions cannot be terminated during a scale-down event. If this parameter is not set, instances in this fleet default to no protection. You can change a fleet's protection policy to affect future game sessions on the fleet. You can also set protection for individual game sessions.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.OneOf(
					"FullProtection",
					"NoProtection",
				),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: PeerVpcAwsAccountId
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A unique identifier for the AWS account with the VPC that you want to peer your Amazon GameLift fleet with. You can find your account ID in the AWS Management Console under account settings.",
		//	  "maxLength": 1024,
		//	  "minLength": 1,
		//	  "pattern": "^[0-9]{12}$",
		//	  "type": "string"
		//	}
		"peer_vpc_aws_account_id": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "A unique identifier for the AWS account with the VPC that you want to peer your Amazon GameLift fleet with. You can find your account ID in the AWS Management Console under account settings.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.LengthBetween(1, 1024),
				stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]{12}$"), ""),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
				stringplanmodifier.RequiresReplace(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: PeerVpcId
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A unique identifier for a VPC with resources to be accessed by your Amazon GameLift fleet. The VPC must be in the same Region as your fleet. To look up a VPC ID, use the VPC Dashboard in the AWS Management Console.",
		//	  "maxLength": 1024,
		//	  "minLength": 1,
		//	  "pattern": "^vpc-\\S+",
		//	  "type": "string"
		//	}
		"peer_vpc_id": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "A unique identifier for a VPC with resources to be accessed by your Amazon GameLift fleet. The VPC must be in the same Region as your fleet. To look up a VPC ID, use the VPC Dashboard in the AWS Management Console.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.LengthBetween(1, 1024),
				stringvalidator.RegexMatches(regexp.MustCompile("^vpc-\\S+"), ""),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
				stringplanmodifier.RequiresReplace(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: ResourceCreationLimitPolicy
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "A policy that limits the number of game sessions an individual player can create over a span of time for this fleet.",
		//	  "properties": {
		//	    "NewGameSessionsPerCreator": {
		//	      "description": "The maximum number of game sessions that an individual can create during the policy period.",
		//	      "minimum": 0,
		//	      "type": "integer"
		//	    },
		//	    "PolicyPeriodInMinutes": {
		//	      "description": "The time span used in evaluating the resource creation limit policy.",
		//	      "minimum": 0,
		//	      "type": "integer"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"resource_creation_limit_policy": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: NewGameSessionsPerCreator
				"new_game_sessions_per_creator": schema.Int64Attribute{ /*START ATTRIBUTE*/
					Description: "The maximum number of game sessions that an individual can create during the policy period.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.Int64{ /*START VALIDATORS*/
						int64validator.AtLeast(0),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
						int64planmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: PolicyPeriodInMinutes
				"policy_period_in_minutes": schema.Int64Attribute{ /*START ATTRIBUTE*/
					Description: "The time span used in evaluating the resource creation limit policy.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.Int64{ /*START VALIDATORS*/
						int64validator.AtLeast(0),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
						int64planmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "A policy that limits the number of game sessions an individual player can create over a span of time for this fleet.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: RuntimeConfiguration
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "Instructions for launching server processes on each instance in the fleet. Server processes run either a custom game build executable or a Realtime script. The runtime configuration defines the server executables or launch script file, launch parameters, and the number of processes to run concurrently on each instance. When creating a fleet, the runtime configuration must have at least one server process configuration; otherwise the request fails with an invalid request exception.\n\nThis parameter is required unless the parameters ServerLaunchPath and ServerLaunchParameters are defined. Runtime configuration has replaced these parameters, but fleets that use them will continue to work.",
		//	  "properties": {
		//	    "GameSessionActivationTimeoutSeconds": {
		//	      "description": "The maximum amount of time (in seconds) that a game session can remain in status ACTIVATING. If the game session is not active before the timeout, activation is terminated and the game session status is changed to TERMINATED.",
		//	      "maximum": 600,
		//	      "minimum": 1,
		//	      "type": "integer"
		//	    },
		//	    "MaxConcurrentGameSessionActivations": {
		//	      "description": "The maximum number of game sessions with status ACTIVATING to allow on an instance simultaneously. This setting limits the amount of instance resources that can be used for new game activations at any one time.",
		//	      "maximum": 2147483647,
		//	      "minimum": 1,
		//	      "type": "integer"
		//	    },
		//	    "ServerProcesses": {
		//	      "description": "A collection of server process configurations that describe which server processes to run on each instance in a fleet.",
		//	      "insertionOrder": false,
		//	      "items": {
		//	        "additionalProperties": false,
		//	        "description": "A set of instructions for launching server processes on each instance in a fleet. Each instruction set identifies the location of the server executable, optional launch parameters, and the number of server processes with this configuration to maintain concurrently on the instance. Server process configurations make up a fleet's RuntimeConfiguration.",
		//	        "properties": {
		//	          "ConcurrentExecutions": {
		//	            "description": "The number of server processes that use this configuration to run concurrently on an instance.",
		//	            "minimum": 1,
		//	            "type": "integer"
		//	          },
		//	          "LaunchPath": {
		//	            "description": "The location of the server executable in a custom game build or the name of the Realtime script file that contains the Init() function. Game builds and Realtime scripts are installed on instances at the root:\n\nWindows (for custom game builds only): C:\\game. Example: \"C:\\game\\MyGame\\server.exe\"\n\nLinux: /local/game. Examples: \"/local/game/MyGame/server.exe\" or \"/local/game/MyRealtimeScript.js\"",
		//	            "maxLength": 1024,
		//	            "minLength": 1,
		//	            "pattern": "^([Cc]:\\\\game\\S+|/local/game/\\S+)",
		//	            "type": "string"
		//	          },
		//	          "Parameters": {
		//	            "description": "An optional list of parameters to pass to the server executable or Realtime script on launch.",
		//	            "maxLength": 1024,
		//	            "minLength": 1,
		//	            "type": "string"
		//	          }
		//	        },
		//	        "required": [
		//	          "ConcurrentExecutions",
		//	          "LaunchPath"
		//	        ],
		//	        "type": "object"
		//	      },
		//	      "maxItems": 50,
		//	      "type": "array"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"runtime_configuration": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: GameSessionActivationTimeoutSeconds
				"game_session_activation_timeout_seconds": schema.Int64Attribute{ /*START ATTRIBUTE*/
					Description: "The maximum amount of time (in seconds) that a game session can remain in status ACTIVATING. If the game session is not active before the timeout, activation is terminated and the game session status is changed to TERMINATED.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.Int64{ /*START VALIDATORS*/
						int64validator.Between(1, 600),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
						int64planmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: MaxConcurrentGameSessionActivations
				"max_concurrent_game_session_activations": schema.Int64Attribute{ /*START ATTRIBUTE*/
					Description: "The maximum number of game sessions with status ACTIVATING to allow on an instance simultaneously. This setting limits the amount of instance resources that can be used for new game activations at any one time.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.Int64{ /*START VALIDATORS*/
						int64validator.Between(1, 2147483647),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
						int64planmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: ServerProcesses
				"server_processes": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
					NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: ConcurrentExecutions
							"concurrent_executions": schema.Int64Attribute{ /*START ATTRIBUTE*/
								Description: "The number of server processes that use this configuration to run concurrently on an instance.",
								Required:    true,
								Validators: []validator.Int64{ /*START VALIDATORS*/
									int64validator.AtLeast(1),
								}, /*END VALIDATORS*/
							}, /*END ATTRIBUTE*/
							// Property: LaunchPath
							"launch_path": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "The location of the server executable in a custom game build or the name of the Realtime script file that contains the Init() function. Game builds and Realtime scripts are installed on instances at the root:\n\nWindows (for custom game builds only): C:\\game. Example: \"C:\\game\\MyGame\\server.exe\"\n\nLinux: /local/game. Examples: \"/local/game/MyGame/server.exe\" or \"/local/game/MyRealtimeScript.js\"",
								Required:    true,
								Validators: []validator.String{ /*START VALIDATORS*/
									stringvalidator.LengthBetween(1, 1024),
									stringvalidator.RegexMatches(regexp.MustCompile("^([Cc]:\\\\game\\S+|/local/game/\\S+)"), ""),
								}, /*END VALIDATORS*/
							}, /*END ATTRIBUTE*/
							// Property: Parameters
							"parameters": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "An optional list of parameters to pass to the server executable or Realtime script on launch.",
								Optional:    true,
								Computed:    true,
								Validators: []validator.String{ /*START VALIDATORS*/
									stringvalidator.LengthBetween(1, 1024),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
									stringplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
					}, /*END NESTED OBJECT*/
					Description: "A collection of server process configurations that describe which server processes to run on each instance in a fleet.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.List{ /*START VALIDATORS*/
						listvalidator.SizeAtMost(50),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
						generic.Multiset(),
						listplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "Instructions for launching server processes on each instance in the fleet. Server processes run either a custom game build executable or a Realtime script. The runtime configuration defines the server executables or launch script file, launch parameters, and the number of processes to run concurrently on each instance. When creating a fleet, the runtime configuration must have at least one server process configuration; otherwise the request fails with an invalid request exception.\n\nThis parameter is required unless the parameters ServerLaunchPath and ServerLaunchParameters are defined. Runtime configuration has replaced these parameters, but fleets that use them will continue to work.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: ScalingPolicies
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A list of rules that control how a fleet is scaled.",
		//	  "insertionOrder": false,
		//	  "items": {
		//	    "additionalProperties": false,
		//	    "description": "Rule that controls how a fleet is scaled. Scaling policies are uniquely identified by the combination of name and fleet ID.",
		//	    "properties": {
		//	      "ComparisonOperator": {
		//	        "description": "Comparison operator to use when measuring a metric against the threshold value.",
		//	        "enum": [
		//	          "GreaterThanOrEqualToThreshold",
		//	          "GreaterThanThreshold",
		//	          "LessThanThreshold",
		//	          "LessThanOrEqualToThreshold"
		//	        ],
		//	        "type": "string"
		//	      },
		//	      "EvaluationPeriods": {
		//	        "description": "Length of time (in minutes) the metric must be at or beyond the threshold before a scaling event is triggered.",
		//	        "minimum": 1,
		//	        "type": "integer"
		//	      },
		//	      "Location": {
		//	        "maxLength": 64,
		//	        "minLength": 1,
		//	        "pattern": "^[A-Za-z0-9\\-]+",
		//	        "type": "string"
		//	      },
		//	      "MetricName": {
		//	        "description": "Name of the Amazon GameLift-defined metric that is used to trigger a scaling adjustment.",
		//	        "enum": [
		//	          "ActivatingGameSessions",
		//	          "ActiveGameSessions",
		//	          "ActiveInstances",
		//	          "AvailableGameSessions",
		//	          "AvailablePlayerSessions",
		//	          "CurrentPlayerSessions",
		//	          "IdleInstances",
		//	          "PercentAvailableGameSessions",
		//	          "PercentIdleInstances",
		//	          "QueueDepth",
		//	          "WaitTime",
		//	          "ConcurrentActivatableGameSessions"
		//	        ],
		//	        "type": "string"
		//	      },
		//	      "Name": {
		//	        "description": "A descriptive label that is associated with a fleet's scaling policy. Policy names do not need to be unique.",
		//	        "maxLength": 1024,
		//	        "minLength": 1,
		//	        "type": "string"
		//	      },
		//	      "PolicyType": {
		//	        "description": "The type of scaling policy to create. For a target-based policy, set the parameter MetricName to 'PercentAvailableGameSessions' and specify a TargetConfiguration. For a rule-based policy set the following parameters: MetricName, ComparisonOperator, Threshold, EvaluationPeriods, ScalingAdjustmentType, and ScalingAdjustment.",
		//	        "enum": [
		//	          "RuleBased",
		//	          "TargetBased"
		//	        ],
		//	        "type": "string"
		//	      },
		//	      "ScalingAdjustment": {
		//	        "description": "Amount of adjustment to make, based on the scaling adjustment type.",
		//	        "type": "integer"
		//	      },
		//	      "ScalingAdjustmentType": {
		//	        "description": "The type of adjustment to make to a fleet's instance count.",
		//	        "enum": [
		//	          "ChangeInCapacity",
		//	          "ExactCapacity",
		//	          "PercentChangeInCapacity"
		//	        ],
		//	        "type": "string"
		//	      },
		//	      "Status": {
		//	        "description": "Current status of the scaling policy. The scaling policy can be in force only when in an ACTIVE status. Scaling policies can be suspended for individual fleets. If the policy is suspended for a fleet, the policy status does not change.",
		//	        "enum": [
		//	          "ACTIVE",
		//	          "UPDATE_REQUESTED",
		//	          "UPDATING",
		//	          "DELETE_REQUESTED",
		//	          "DELETING",
		//	          "DELETED",
		//	          "ERROR"
		//	        ],
		//	        "type": "string"
		//	      },
		//	      "TargetConfiguration": {
		//	        "additionalProperties": false,
		//	        "description": "An object that contains settings for a target-based scaling policy.",
		//	        "properties": {
		//	          "TargetValue": {
		//	            "description": "Desired value to use with a target-based scaling policy. The value must be relevant for whatever metric the scaling policy is using. For example, in a policy using the metric PercentAvailableGameSessions, the target value should be the preferred size of the fleet's buffer (the percent of capacity that should be idle and ready for new game sessions).",
		//	            "type": "number"
		//	          }
		//	        },
		//	        "required": [
		//	          "TargetValue"
		//	        ],
		//	        "type": "object"
		//	      },
		//	      "Threshold": {
		//	        "description": "Metric value used to trigger a scaling event.",
		//	        "type": "number"
		//	      },
		//	      "UpdateStatus": {
		//	        "description": "The current status of the fleet's scaling policies in a requested fleet location. The status PENDING_UPDATE indicates that an update was requested for the fleet but has not yet been completed for the location.",
		//	        "enum": [
		//	          "PENDING_UPDATE"
		//	        ],
		//	        "type": "string"
		//	      }
		//	    },
		//	    "required": [
		//	      "MetricName",
		//	      "Name"
		//	    ],
		//	    "type": "object"
		//	  },
		//	  "maxItems": 50,
		//	  "type": "array"
		//	}
		"scaling_policies": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: ComparisonOperator
					"comparison_operator": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "Comparison operator to use when measuring a metric against the threshold value.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.OneOf(
								"GreaterThanOrEqualToThreshold",
								"GreaterThanThreshold",
								"LessThanThreshold",
								"LessThanOrEqualToThreshold",
							),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: EvaluationPeriods
					"evaluation_periods": schema.Int64Attribute{ /*START ATTRIBUTE*/
						Description: "Length of time (in minutes) the metric must be at or beyond the threshold before a scaling event is triggered.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.Int64{ /*START VALIDATORS*/
							int64validator.AtLeast(1),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
							int64planmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: Location
					"location": schema.StringAttribute{ /*START ATTRIBUTE*/
						Optional: true,
						Computed: true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.LengthBetween(1, 64),
							stringvalidator.RegexMatches(regexp.MustCompile("^[A-Za-z0-9\\-]+"), ""),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: MetricName
					"metric_name": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "Name of the Amazon GameLift-defined metric that is used to trigger a scaling adjustment.",
						Required:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.OneOf(
								"ActivatingGameSessions",
								"ActiveGameSessions",
								"ActiveInstances",
								"AvailableGameSessions",
								"AvailablePlayerSessions",
								"CurrentPlayerSessions",
								"IdleInstances",
								"PercentAvailableGameSessions",
								"PercentIdleInstances",
								"QueueDepth",
								"WaitTime",
								"ConcurrentActivatableGameSessions",
							),
						}, /*END VALIDATORS*/
					}, /*END ATTRIBUTE*/
					// Property: Name
					"name": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "A descriptive label that is associated with a fleet's scaling policy. Policy names do not need to be unique.",
						Required:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.LengthBetween(1, 1024),
						}, /*END VALIDATORS*/
					}, /*END ATTRIBUTE*/
					// Property: PolicyType
					"policy_type": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The type of scaling policy to create. For a target-based policy, set the parameter MetricName to 'PercentAvailableGameSessions' and specify a TargetConfiguration. For a rule-based policy set the following parameters: MetricName, ComparisonOperator, Threshold, EvaluationPeriods, ScalingAdjustmentType, and ScalingAdjustment.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.OneOf(
								"RuleBased",
								"TargetBased",
							),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: ScalingAdjustment
					"scaling_adjustment": schema.Int64Attribute{ /*START ATTRIBUTE*/
						Description: "Amount of adjustment to make, based on the scaling adjustment type.",
						Optional:    true,
						Computed:    true,
						PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
							int64planmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: ScalingAdjustmentType
					"scaling_adjustment_type": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The type of adjustment to make to a fleet's instance count.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.OneOf(
								"ChangeInCapacity",
								"ExactCapacity",
								"PercentChangeInCapacity",
							),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: Status
					"status": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "Current status of the scaling policy. The scaling policy can be in force only when in an ACTIVE status. Scaling policies can be suspended for individual fleets. If the policy is suspended for a fleet, the policy status does not change.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.OneOf(
								"ACTIVE",
								"UPDATE_REQUESTED",
								"UPDATING",
								"DELETE_REQUESTED",
								"DELETING",
								"DELETED",
								"ERROR",
							),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: TargetConfiguration
					"target_configuration": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: TargetValue
							"target_value": schema.Float64Attribute{ /*START ATTRIBUTE*/
								Description: "Desired value to use with a target-based scaling policy. The value must be relevant for whatever metric the scaling policy is using. For example, in a policy using the metric PercentAvailableGameSessions, the target value should be the preferred size of the fleet's buffer (the percent of capacity that should be idle and ready for new game sessions).",
								Required:    true,
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
						Description: "An object that contains settings for a target-based scaling policy.",
						Optional:    true,
						Computed:    true,
						PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
							objectplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: Threshold
					"threshold": schema.Float64Attribute{ /*START ATTRIBUTE*/
						Description: "Metric value used to trigger a scaling event.",
						Optional:    true,
						Computed:    true,
						PlanModifiers: []planmodifier.Float64{ /*START PLAN MODIFIERS*/
							float64planmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: UpdateStatus
					"update_status": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The current status of the fleet's scaling policies in a requested fleet location. The status PENDING_UPDATE indicates that an update was requested for the fleet but has not yet been completed for the location.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.OneOf(
								"PENDING_UPDATE",
							),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Description: "A list of rules that control how a fleet is scaled.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.List{ /*START VALIDATORS*/
				listvalidator.SizeAtMost(50),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
				generic.Multiset(),
				listplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: ScriptId
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A unique identifier for a Realtime script to be deployed on a new Realtime Servers fleet. The script must have been successfully uploaded to Amazon GameLift. This fleet setting cannot be changed once the fleet is created.\n\nNote: It is not currently possible to use the !Ref command to reference a script created with a CloudFormation template for the fleet property ScriptId. Instead, use Fn::GetAtt Script.Arn or Fn::GetAtt Script.Id to retrieve either of these properties as input for ScriptId. Alternatively, enter a ScriptId string manually.",
		//	  "pattern": "^script-\\S+|^arn:.*:script/script-\\S+",
		//	  "type": "string"
		//	}
		"script_id": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "A unique identifier for a Realtime script to be deployed on a new Realtime Servers fleet. The script must have been successfully uploaded to Amazon GameLift. This fleet setting cannot be changed once the fleet is created.\n\nNote: It is not currently possible to use the !Ref command to reference a script created with a CloudFormation template for the fleet property ScriptId. Instead, use Fn::GetAtt Script.Arn or Fn::GetAtt Script.Id to retrieve either of these properties as input for ScriptId. Alternatively, enter a ScriptId string manually.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.RegexMatches(regexp.MustCompile("^script-\\S+|^arn:.*:script/script-\\S+"), ""),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
				stringplanmodifier.RequiresReplace(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: ServerLaunchParameters
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "This parameter is no longer used but is retained for backward compatibility. Instead, specify server launch parameters in the RuntimeConfiguration parameter. A request must specify either a runtime configuration or values for both ServerLaunchParameters and ServerLaunchPath.",
		//	  "maxLength": 1024,
		//	  "minLength": 1,
		//	  "type": "string"
		//	}
		"server_launch_parameters": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "This parameter is no longer used but is retained for backward compatibility. Instead, specify server launch parameters in the RuntimeConfiguration parameter. A request must specify either a runtime configuration or values for both ServerLaunchParameters and ServerLaunchPath.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.LengthBetween(1, 1024),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
				stringplanmodifier.RequiresReplace(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: ServerLaunchPath
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "This parameter is no longer used. Instead, specify a server launch path using the RuntimeConfiguration parameter. Requests that specify a server launch path and launch parameters instead of a runtime configuration will continue to work.",
		//	  "maxLength": 1024,
		//	  "minLength": 1,
		//	  "type": "string"
		//	}
		"server_launch_path": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "This parameter is no longer used. Instead, specify a server launch path using the RuntimeConfiguration parameter. Requests that specify a server launch path and launch parameters instead of a runtime configuration will continue to work.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.LengthBetween(1, 1024),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
				stringplanmodifier.RequiresReplace(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
	} /*END SCHEMA*/

	attributes["id"] = schema.StringAttribute{
		Description: "Uniquely identifies the resource.",
		Computed:    true,
		PlanModifiers: []planmodifier.String{
			stringplanmodifier.UseStateForUnknown(),
		},
	}

	schema := schema.Schema{
		Description: "The AWS::GameLift::Fleet resource creates an Amazon GameLift (GameLift) fleet to host game servers. A fleet is a set of EC2 or Anywhere instances, each of which can host multiple game sessions.",
		Version:     1,
		Attributes:  attributes,
	}

	var opts generic.ResourceOptions

	opts = opts.WithCloudFormationTypeName("AWS::GameLift::Fleet").WithTerraformTypeName("awscc_gamelift_fleet")
	opts = opts.WithTerraformSchema(schema)
	opts = opts.WithSyntheticIDAttribute(true)
	opts = opts.WithAttributeNameMap(map[string]string{
		"anywhere_configuration":    "AnywhereConfiguration",
		"apply_capacity":            "ApplyCapacity",
		"build_id":                  "BuildId",
		"certificate_configuration": "CertificateConfiguration",
		"certificate_type":          "CertificateType",
		"comparison_operator":       "ComparisonOperator",
		"compute_type":              "ComputeType",
		"concurrent_executions":     "ConcurrentExecutions",
		"cost":                      "Cost",
		"description":               "Description",
		"desired_ec2_instances":     "DesiredEC2Instances",
		"ec2_inbound_permissions":   "EC2InboundPermissions",
		"ec2_instance_type":         "EC2InstanceType",
		"evaluation_periods":        "EvaluationPeriods",
		"fleet_id":                  "FleetId",
		"fleet_type":                "FleetType",
		"from_port":                 "FromPort",
		"game_session_activation_timeout_seconds": "GameSessionActivationTimeoutSeconds",
		"instance_role_arn":                       "InstanceRoleARN",
		"instance_role_credentials_provider":      "InstanceRoleCredentialsProvider",
		"ip_range":                                "IpRange",
		"launch_path":                             "LaunchPath",
		"location":                                "Location",
		"location_capacity":                       "LocationCapacity",
		"locations":                               "Locations",
		"log_paths":                               "LogPaths",
		"max_concurrent_game_session_activations": "MaxConcurrentGameSessionActivations",
		"max_size":                           "MaxSize",
		"metric_groups":                      "MetricGroups",
		"metric_name":                        "MetricName",
		"min_size":                           "MinSize",
		"name":                               "Name",
		"new_game_session_protection_policy": "NewGameSessionProtectionPolicy",
		"new_game_sessions_per_creator":      "NewGameSessionsPerCreator",
		"parameters":                         "Parameters",
		"peer_vpc_aws_account_id":            "PeerVpcAwsAccountId",
		"peer_vpc_id":                        "PeerVpcId",
		"policy_period_in_minutes":           "PolicyPeriodInMinutes",
		"policy_type":                        "PolicyType",
		"protocol":                           "Protocol",
		"resource_creation_limit_policy":     "ResourceCreationLimitPolicy",
		"runtime_configuration":              "RuntimeConfiguration",
		"scaling_adjustment":                 "ScalingAdjustment",
		"scaling_adjustment_type":            "ScalingAdjustmentType",
		"scaling_policies":                   "ScalingPolicies",
		"script_id":                          "ScriptId",
		"server_launch_parameters":           "ServerLaunchParameters",
		"server_launch_path":                 "ServerLaunchPath",
		"server_processes":                   "ServerProcesses",
		"status":                             "Status",
		"target_configuration":               "TargetConfiguration",
		"target_value":                       "TargetValue",
		"threshold":                          "Threshold",
		"to_port":                            "ToPort",
		"update_status":                      "UpdateStatus",
	})

	opts = opts.WithWriteOnlyPropertyPaths([]string{
		"/properties/ApplyCapacity",
	})
	opts = opts.WithCreateTimeoutInMinutes(0).WithDeleteTimeoutInMinutes(0)

	opts = opts.WithUpdateTimeoutInMinutes(0)

	v, err := generic.NewResource(ctx, opts...)

	if err != nil {
		return nil, err
	}

	return v, nil
}
