// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// Code generated by generators/resource/main.go; DO NOT EDIT.

package gamelift

import (
	"context"
	"regexp"

	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/setvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/float64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/setplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-provider-awscc/internal/generic"
	"github.com/hashicorp/terraform-provider-awscc/internal/registry"
	fwvalidators "github.com/hashicorp/terraform-provider-awscc/internal/validators"
)

func init() {
	registry.AddResourceFactory("awscc_gamelift_container_fleet", containerFleetResource)
}

// containerFleetResource returns the Terraform awscc_gamelift_container_fleet resource.
// This Terraform resource corresponds to the CloudFormation AWS::GameLift::ContainerFleet resource.
func containerFleetResource(ctx context.Context) (resource.Resource, error) {
	attributes := map[string]schema.Attribute{ /*START SCHEMA*/
		// Property: BillingType
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "Indicates whether to use On-Demand instances or Spot instances for this fleet. If empty, the default is ON_DEMAND. Both categories of instances use identical hardware and configurations based on the instance type selected for this fleet.",
		//	  "enum": [
		//	    "ON_DEMAND",
		//	    "SPOT"
		//	  ],
		//	  "type": "string"
		//	}
		"billing_type": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "Indicates whether to use On-Demand instances or Spot instances for this fleet. If empty, the default is ON_DEMAND. Both categories of instances use identical hardware and configurations based on the instance type selected for this fleet.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.OneOf(
					"ON_DEMAND",
					"SPOT",
				),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
				stringplanmodifier.RequiresReplaceIfConfigured(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: CreationTime
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A time stamp indicating when this data object was created. Format is a number expressed in Unix time as milliseconds (for example \"1469498468.057\").",
		//	  "type": "string"
		//	}
		"creation_time": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "A time stamp indicating when this data object was created. Format is a number expressed in Unix time as milliseconds (for example \"1469498468.057\").",
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: DeploymentConfiguration
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "Provides details about how to drain old tasks and replace them with new updated tasks.",
		//	  "properties": {
		//	    "ImpairmentStrategy": {
		//	      "description": "The strategy to apply in case of impairment; defaults to MAINTAIN.",
		//	      "enum": [
		//	        "MAINTAIN",
		//	        "ROLLBACK"
		//	      ],
		//	      "type": "string"
		//	    },
		//	    "MinimumHealthyPercentage": {
		//	      "description": "The minimum percentage of healthy required; defaults to 75.",
		//	      "maximum": 75,
		//	      "minimum": 30,
		//	      "type": "integer"
		//	    },
		//	    "ProtectionStrategy": {
		//	      "description": "The protection strategy for deployment on the container fleet; defaults to WITH_PROTECTION.",
		//	      "enum": [
		//	        "WITH_PROTECTION",
		//	        "IGNORE_PROTECTION"
		//	      ],
		//	      "type": "string"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"deployment_configuration": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: ImpairmentStrategy
				"impairment_strategy": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "The strategy to apply in case of impairment; defaults to MAINTAIN.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.String{ /*START VALIDATORS*/
						stringvalidator.OneOf(
							"MAINTAIN",
							"ROLLBACK",
						),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: MinimumHealthyPercentage
				"minimum_healthy_percentage": schema.Int64Attribute{ /*START ATTRIBUTE*/
					Description: "The minimum percentage of healthy required; defaults to 75.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.Int64{ /*START VALIDATORS*/
						int64validator.Between(30, 75),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
						int64planmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: ProtectionStrategy
				"protection_strategy": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "The protection strategy for deployment on the container fleet; defaults to WITH_PROTECTION.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.String{ /*START VALIDATORS*/
						stringvalidator.OneOf(
							"WITH_PROTECTION",
							"IGNORE_PROTECTION",
						),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "Provides details about how to drain old tasks and replace them with new updated tasks.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
			// DeploymentConfiguration is a write-only property.
		}, /*END ATTRIBUTE*/
		// Property: DeploymentDetails
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "Provides information about the last deployment ID and its status.",
		//	  "properties": {
		//	    "LatestDeploymentId": {
		//	      "description": "The ID of the last deployment on the container fleet. This field will be empty if the container fleet does not have a ContainerGroupDefinition attached.",
		//	      "maxLength": 1024,
		//	      "pattern": "^[a-zA-Z0-9\\-]+$|^$",
		//	      "type": "string"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"deployment_details": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: LatestDeploymentId
				"latest_deployment_id": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "The ID of the last deployment on the container fleet. This field will be empty if the container fleet does not have a ContainerGroupDefinition attached.",
					Computed:    true,
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "Provides information about the last deployment ID and its status.",
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Description
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A human-readable description of a fleet.",
		//	  "maxLength": 1024,
		//	  "minLength": 1,
		//	  "type": "string"
		//	}
		"description": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "A human-readable description of a fleet.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.LengthBetween(1, 1024),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: FleetArn
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The Amazon Resource Name (ARN) that is assigned to a Amazon GameLift container fleet resource and uniquely identifies it across all AWS Regions.",
		//	  "maxLength": 512,
		//	  "minLength": 1,
		//	  "pattern": "^arn:.*:[a-z]*fleet\\/[a-z]*fleet-[a-zA-Z0-9\\-]+$",
		//	  "type": "string"
		//	}
		"fleet_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The Amazon Resource Name (ARN) that is assigned to a Amazon GameLift container fleet resource and uniquely identifies it across all AWS Regions.",
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: FleetId
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "Unique fleet ID",
		//	  "maxLength": 128,
		//	  "minLength": 1,
		//	  "pattern": "^[a-z]*fleet-[a-zA-Z0-9\\-]+",
		//	  "type": "string"
		//	}
		"fleet_id": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "Unique fleet ID",
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: FleetRoleArn
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A unique identifier for an AWS IAM role that manages access to your AWS services. Create a role or look up a role's ARN from the IAM dashboard in the AWS Management Console.",
		//	  "maxLength": 256,
		//	  "minLength": 1,
		//	  "pattern": "^arn:aws(-.*)?:[a-z-]+:(([a-z]+-)+[0-9])?:([0-9]{12})?:[^.]+$",
		//	  "type": "string"
		//	}
		"fleet_role_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "A unique identifier for an AWS IAM role that manages access to your AWS services. Create a role or look up a role's ARN from the IAM dashboard in the AWS Management Console.",
			Required:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.LengthBetween(1, 256),
				stringvalidator.RegexMatches(regexp.MustCompile("^arn:aws(-.*)?:[a-z-]+:(([a-z]+-)+[0-9])?:([0-9]{12})?:[^.]+$"), ""),
			}, /*END VALIDATORS*/
		}, /*END ATTRIBUTE*/
		// Property: GameServerContainerGroupDefinitionArn
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The Amazon Resource Name (ARN) of the game server container group definition. This field will be empty if GameServerContainerGroupDefinitionName is not specified.",
		//	  "maxLength": 512,
		//	  "pattern": "^arn:.*:containergroupdefinition\\/[a-zA-Z0-9\\-]+(:[0-9]+)?$|^$",
		//	  "type": "string"
		//	}
		"game_server_container_group_definition_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The Amazon Resource Name (ARN) of the game server container group definition. This field will be empty if GameServerContainerGroupDefinitionName is not specified.",
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: GameServerContainerGroupDefinitionName
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The name of the container group definition that will be created per game server. You must specify GAME_SERVER container group. You have the option to also specify one PER_INSTANCE container group.",
		//	  "maxLength": 512,
		//	  "minLength": 1,
		//	  "pattern": "^[a-zA-Z0-9\\-]+$|^arn:.*:containergroupdefinition\\/[a-zA-Z0-9\\-]+(:[0-9]+)?$",
		//	  "type": "string"
		//	}
		"game_server_container_group_definition_name": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The name of the container group definition that will be created per game server. You must specify GAME_SERVER container group. You have the option to also specify one PER_INSTANCE container group.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.LengthBetween(1, 512),
				stringvalidator.RegexMatches(regexp.MustCompile("^[a-zA-Z0-9\\-]+$|^arn:.*:containergroupdefinition\\/[a-zA-Z0-9\\-]+(:[0-9]+)?$"), ""),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
			// GameServerContainerGroupDefinitionName is a write-only property.
		}, /*END ATTRIBUTE*/
		// Property: GameServerContainerGroupsPerInstance
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The number of desired game server container groups per instance, a number between 1-5000.",
		//	  "maximum": 5000,
		//	  "minimum": 1,
		//	  "type": "integer"
		//	}
		"game_server_container_groups_per_instance": schema.Int64Attribute{ /*START ATTRIBUTE*/
			Description: "The number of desired game server container groups per instance, a number between 1-5000.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.Int64{ /*START VALIDATORS*/
				int64validator.Between(1, 5000),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
				int64planmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: GameSessionCreationLimitPolicy
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "A policy that limits the number of game sessions an individual player can create over a span of time for this fleet.",
		//	  "properties": {
		//	    "NewGameSessionsPerCreator": {
		//	      "description": "The maximum number of game sessions that an individual can create during the policy period.",
		//	      "minimum": 0,
		//	      "type": "integer"
		//	    },
		//	    "PolicyPeriodInMinutes": {
		//	      "description": "The time span used in evaluating the resource creation limit policy.",
		//	      "minimum": 0,
		//	      "type": "integer"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"game_session_creation_limit_policy": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: NewGameSessionsPerCreator
				"new_game_sessions_per_creator": schema.Int64Attribute{ /*START ATTRIBUTE*/
					Description: "The maximum number of game sessions that an individual can create during the policy period.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.Int64{ /*START VALIDATORS*/
						int64validator.AtLeast(0),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
						int64planmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: PolicyPeriodInMinutes
				"policy_period_in_minutes": schema.Int64Attribute{ /*START ATTRIBUTE*/
					Description: "The time span used in evaluating the resource creation limit policy.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.Int64{ /*START VALIDATORS*/
						int64validator.AtLeast(0),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
						int64planmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "A policy that limits the number of game sessions an individual player can create over a span of time for this fleet.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: InstanceConnectionPortRange
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "Defines the range of ports on the instance that allow inbound traffic to connect with containers in a fleet.",
		//	  "properties": {
		//	    "FromPort": {
		//	      "description": "A starting value for a range of allowed port numbers.",
		//	      "maximum": 60000,
		//	      "minimum": 1,
		//	      "type": "integer"
		//	    },
		//	    "ToPort": {
		//	      "description": "An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than FromPort.",
		//	      "maximum": 60000,
		//	      "minimum": 1,
		//	      "type": "integer"
		//	    }
		//	  },
		//	  "required": [
		//	    "FromPort",
		//	    "ToPort"
		//	  ],
		//	  "type": "object"
		//	}
		"instance_connection_port_range": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: FromPort
				"from_port": schema.Int64Attribute{ /*START ATTRIBUTE*/
					Description: "A starting value for a range of allowed port numbers.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.Int64{ /*START VALIDATORS*/
						int64validator.Between(1, 60000),
						fwvalidators.NotNullInt64(),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
						int64planmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: ToPort
				"to_port": schema.Int64Attribute{ /*START ATTRIBUTE*/
					Description: "An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than FromPort.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.Int64{ /*START VALIDATORS*/
						int64validator.Between(1, 60000),
						fwvalidators.NotNullInt64(),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
						int64planmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "Defines the range of ports on the instance that allow inbound traffic to connect with containers in a fleet.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: InstanceInboundPermissions
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A range of IP addresses and port settings that allow inbound traffic to connect to server processes on an Amazon GameLift server.",
		//	  "insertionOrder": false,
		//	  "items": {
		//	    "additionalProperties": false,
		//	    "description": "A range of IP addresses and port settings that allow inbound traffic to connect to server processes on an Amazon GameLift hosting resource. New game sessions that are started on the fleet are assigned an IP address/port number combination, which must fall into the fleet's allowed ranges. For fleets created with a custom game server, the ranges reflect the server's game session assignments. For Realtime Servers fleets, Amazon GameLift automatically opens two port ranges, one for TCP messaging and one for UDP, for use by the Realtime servers.",
		//	    "properties": {
		//	      "FromPort": {
		//	        "description": "A starting value for a range of allowed port numbers.",
		//	        "maximum": 60000,
		//	        "minimum": 1,
		//	        "type": "integer"
		//	      },
		//	      "IpRange": {
		//	        "description": "A range of allowed IP addresses. This value must be expressed in CIDR notation. Example: \"000.000.000.000/[subnet mask]\" or optionally the shortened version \"0.0.0.0/[subnet mask]\".",
		//	        "pattern": "(^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(/([0-9]|[1-2][0-9]|3[0-2]))$)",
		//	        "type": "string"
		//	      },
		//	      "Protocol": {
		//	        "description": "The network communication protocol used by the fleet.",
		//	        "enum": [
		//	          "TCP",
		//	          "UDP"
		//	        ],
		//	        "type": "string"
		//	      },
		//	      "ToPort": {
		//	        "description": "An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than FromPort.",
		//	        "maximum": 60000,
		//	        "minimum": 1,
		//	        "type": "integer"
		//	      }
		//	    },
		//	    "required": [
		//	      "FromPort",
		//	      "IpRange",
		//	      "Protocol",
		//	      "ToPort"
		//	    ],
		//	    "type": "object"
		//	  },
		//	  "maxItems": 50,
		//	  "type": "array"
		//	}
		"instance_inbound_permissions": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: FromPort
					"from_port": schema.Int64Attribute{ /*START ATTRIBUTE*/
						Description: "A starting value for a range of allowed port numbers.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.Int64{ /*START VALIDATORS*/
							int64validator.Between(1, 60000),
							fwvalidators.NotNullInt64(),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
							int64planmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: IpRange
					"ip_range": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "A range of allowed IP addresses. This value must be expressed in CIDR notation. Example: \"000.000.000.000/[subnet mask]\" or optionally the shortened version \"0.0.0.0/[subnet mask]\".",
						Optional:    true,
						Computed:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.RegexMatches(regexp.MustCompile("(^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(/([0-9]|[1-2][0-9]|3[0-2]))$)"), ""),
							fwvalidators.NotNullString(),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: Protocol
					"protocol": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The network communication protocol used by the fleet.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.OneOf(
								"TCP",
								"UDP",
							),
							fwvalidators.NotNullString(),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: ToPort
					"to_port": schema.Int64Attribute{ /*START ATTRIBUTE*/
						Description: "An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than FromPort.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.Int64{ /*START VALIDATORS*/
							int64validator.Between(1, 60000),
							fwvalidators.NotNullInt64(),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
							int64planmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Description: "A range of IP addresses and port settings that allow inbound traffic to connect to server processes on an Amazon GameLift server.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.List{ /*START VALIDATORS*/
				listvalidator.SizeAtMost(50),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
				generic.Multiset(),
				listplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: InstanceType
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The name of an EC2 instance type that is supported in Amazon GameLift. A fleet instance type determines the computing resources of each instance in the fleet, including CPU, memory, storage, and networking capacity. Amazon GameLift supports the following EC2 instance types. See Amazon EC2 Instance Types for detailed descriptions.",
		//	  "maxLength": 1024,
		//	  "minLength": 1,
		//	  "type": "string"
		//	}
		"instance_type": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The name of an EC2 instance type that is supported in Amazon GameLift. A fleet instance type determines the computing resources of each instance in the fleet, including CPU, memory, storage, and networking capacity. Amazon GameLift supports the following EC2 instance types. See Amazon EC2 Instance Types for detailed descriptions.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.LengthBetween(1, 1024),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
				stringplanmodifier.RequiresReplaceIfConfigured(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Locations
		// CloudFormation resource type schema:
		//
		//	{
		//	  "insertionOrder": false,
		//	  "items": {
		//	    "additionalProperties": false,
		//	    "description": "A remote location where a multi-location fleet can deploy EC2 instances for game hosting.",
		//	    "properties": {
		//	      "Location": {
		//	        "maxLength": 64,
		//	        "minLength": 1,
		//	        "pattern": "^[A-Za-z0-9\\-]+",
		//	        "type": "string"
		//	      },
		//	      "LocationCapacity": {
		//	        "additionalProperties": false,
		//	        "description": "Current resource capacity settings in a specified fleet or location. The location value might refer to a fleet's remote location or its home Region.",
		//	        "properties": {
		//	          "DesiredEC2Instances": {
		//	            "description": "The number of EC2 instances you want to maintain in the specified fleet location. This value must fall between the minimum and maximum size limits.",
		//	            "minimum": 0,
		//	            "type": "integer"
		//	          },
		//	          "MaxSize": {
		//	            "description": "The maximum value that is allowed for the fleet's instance count for a location.",
		//	            "minimum": 0,
		//	            "type": "integer"
		//	          },
		//	          "MinSize": {
		//	            "description": "The minimum value allowed for the fleet's instance count for a location.",
		//	            "minimum": 0,
		//	            "type": "integer"
		//	          }
		//	        },
		//	        "required": [
		//	          "DesiredEC2Instances",
		//	          "MinSize",
		//	          "MaxSize"
		//	        ],
		//	        "type": "object"
		//	      },
		//	      "StoppedActions": {
		//	        "description": "A list of fleet actions that have been suspended in the fleet location.",
		//	        "insertionOrder": false,
		//	        "items": {
		//	          "enum": [
		//	            "AUTO_SCALING"
		//	          ],
		//	          "type": "string"
		//	        },
		//	        "maxItems": 1,
		//	        "type": "array"
		//	      }
		//	    },
		//	    "required": [
		//	      "Location"
		//	    ],
		//	    "type": "object"
		//	  },
		//	  "maxItems": 100,
		//	  "type": "array"
		//	}
		"locations": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: Location
					"location": schema.StringAttribute{ /*START ATTRIBUTE*/
						Optional: true,
						Computed: true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.LengthBetween(1, 64),
							stringvalidator.RegexMatches(regexp.MustCompile("^[A-Za-z0-9\\-]+"), ""),
							fwvalidators.NotNullString(),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: LocationCapacity
					"location_capacity": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: DesiredEC2Instances
							"desired_ec2_instances": schema.Int64Attribute{ /*START ATTRIBUTE*/
								Description: "The number of EC2 instances you want to maintain in the specified fleet location. This value must fall between the minimum and maximum size limits.",
								Optional:    true,
								Computed:    true,
								Validators: []validator.Int64{ /*START VALIDATORS*/
									int64validator.AtLeast(0),
									fwvalidators.NotNullInt64(),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
									int64planmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: MaxSize
							"max_size": schema.Int64Attribute{ /*START ATTRIBUTE*/
								Description: "The maximum value that is allowed for the fleet's instance count for a location.",
								Optional:    true,
								Computed:    true,
								Validators: []validator.Int64{ /*START VALIDATORS*/
									int64validator.AtLeast(0),
									fwvalidators.NotNullInt64(),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
									int64planmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: MinSize
							"min_size": schema.Int64Attribute{ /*START ATTRIBUTE*/
								Description: "The minimum value allowed for the fleet's instance count for a location.",
								Optional:    true,
								Computed:    true,
								Validators: []validator.Int64{ /*START VALIDATORS*/
									int64validator.AtLeast(0),
									fwvalidators.NotNullInt64(),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
									int64planmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
						Description: "Current resource capacity settings in a specified fleet or location. The location value might refer to a fleet's remote location or its home Region.",
						Optional:    true,
						Computed:    true,
						PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
							objectplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: StoppedActions
					"stopped_actions": schema.ListAttribute{ /*START ATTRIBUTE*/
						ElementType: types.StringType,
						Description: "A list of fleet actions that have been suspended in the fleet location.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.List{ /*START VALIDATORS*/
							listvalidator.SizeAtMost(1),
							listvalidator.ValueStringsAre(
								stringvalidator.OneOf(
									"AUTO_SCALING",
								),
							),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
							generic.Multiset(),
							listplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Optional: true,
			Computed: true,
			Validators: []validator.List{ /*START VALIDATORS*/
				listvalidator.SizeAtMost(100),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
				generic.Multiset(),
				listplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: LogConfiguration
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "A policy the location and provider of logs from the fleet.",
		//	  "properties": {
		//	    "LogDestination": {
		//	      "description": "Configures the service that provides logs.",
		//	      "enum": [
		//	        "NONE",
		//	        "CLOUDWATCH",
		//	        "S3"
		//	      ],
		//	      "type": "string"
		//	    },
		//	    "S3BucketName": {
		//	      "description": "The name of the S3 bucket to pull logs from if S3 is the LogDestination",
		//	      "maxLength": 1024,
		//	      "minLength": 1,
		//	      "type": "string"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"log_configuration": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: LogDestination
				"log_destination": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "Configures the service that provides logs.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.String{ /*START VALIDATORS*/
						stringvalidator.OneOf(
							"NONE",
							"CLOUDWATCH",
							"S3",
						),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: S3BucketName
				"s3_bucket_name": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "The name of the S3 bucket to pull logs from if S3 is the LogDestination",
					Optional:    true,
					Computed:    true,
					Validators: []validator.String{ /*START VALIDATORS*/
						stringvalidator.LengthBetween(1, 1024),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "A policy the location and provider of logs from the fleet.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: MaximumGameServerContainerGroupsPerInstance
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The maximum number of game server container groups per instance, a number between 1-5000.",
		//	  "maximum": 5000,
		//	  "minimum": 1,
		//	  "type": "integer"
		//	}
		"maximum_game_server_container_groups_per_instance": schema.Int64Attribute{ /*START ATTRIBUTE*/
			Description: "The maximum number of game server container groups per instance, a number between 1-5000.",
			Computed:    true,
			PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
				int64planmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: MetricGroups
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The name of an Amazon CloudWatch metric group. A metric group aggregates the metrics for all fleets in the group. Specify a string containing the metric group name. You can use an existing name or use a new name to create a new metric group. Currently, this parameter can have only one string.",
		//	  "insertionOrder": false,
		//	  "items": {
		//	    "type": "string"
		//	  },
		//	  "maxItems": 1,
		//	  "type": "array"
		//	}
		"metric_groups": schema.ListAttribute{ /*START ATTRIBUTE*/
			ElementType: types.StringType,
			Description: "The name of an Amazon CloudWatch metric group. A metric group aggregates the metrics for all fleets in the group. Specify a string containing the metric group name. You can use an existing name or use a new name to create a new metric group. Currently, this parameter can have only one string.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.List{ /*START VALIDATORS*/
				listvalidator.SizeAtMost(1),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
				generic.Multiset(),
				listplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: NewGameSessionProtectionPolicy
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A game session protection policy to apply to all game sessions hosted on instances in this fleet. When protected, active game sessions cannot be terminated during a scale-down event. If this parameter is not set, instances in this fleet default to no protection. You can change a fleet's protection policy to affect future game sessions on the fleet. You can also set protection for individual game sessions.",
		//	  "enum": [
		//	    "FullProtection",
		//	    "NoProtection"
		//	  ],
		//	  "type": "string"
		//	}
		"new_game_session_protection_policy": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "A game session protection policy to apply to all game sessions hosted on instances in this fleet. When protected, active game sessions cannot be terminated during a scale-down event. If this parameter is not set, instances in this fleet default to no protection. You can change a fleet's protection policy to affect future game sessions on the fleet. You can also set protection for individual game sessions.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.OneOf(
					"FullProtection",
					"NoProtection",
				),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: PerInstanceContainerGroupDefinitionArn
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The Amazon Resource Name (ARN) of the per instance container group definition. This field will be empty if PerInstanceContainerGroupDefinitionName is not specified.",
		//	  "maxLength": 512,
		//	  "pattern": "^arn:.*:containergroupdefinition\\/[a-zA-Z0-9\\-]+(:[0-9]+)?$|^$",
		//	  "type": "string"
		//	}
		"per_instance_container_group_definition_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The Amazon Resource Name (ARN) of the per instance container group definition. This field will be empty if PerInstanceContainerGroupDefinitionName is not specified.",
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: PerInstanceContainerGroupDefinitionName
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The name of the container group definition that will be created per instance. This field is optional if you specify GameServerContainerGroupDefinitionName.",
		//	  "maxLength": 512,
		//	  "minLength": 1,
		//	  "pattern": "^[a-zA-Z0-9\\-]+$|^arn:.*:containergroupdefinition\\/[a-zA-Z0-9\\-]+(:[0-9]+)?$",
		//	  "type": "string"
		//	}
		"per_instance_container_group_definition_name": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The name of the container group definition that will be created per instance. This field is optional if you specify GameServerContainerGroupDefinitionName.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.LengthBetween(1, 512),
				stringvalidator.RegexMatches(regexp.MustCompile("^[a-zA-Z0-9\\-]+$|^arn:.*:containergroupdefinition\\/[a-zA-Z0-9\\-]+(:[0-9]+)?$"), ""),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
			// PerInstanceContainerGroupDefinitionName is a write-only property.
		}, /*END ATTRIBUTE*/
		// Property: ScalingPolicies
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A list of rules that control how a fleet is scaled.",
		//	  "insertionOrder": false,
		//	  "items": {
		//	    "additionalProperties": false,
		//	    "description": "Rule that controls how a fleet is scaled. Scaling policies are uniquely identified by the combination of name and fleet ID.",
		//	    "properties": {
		//	      "ComparisonOperator": {
		//	        "description": "Comparison operator to use when measuring a metric against the threshold value.",
		//	        "enum": [
		//	          "GreaterThanOrEqualToThreshold",
		//	          "GreaterThanThreshold",
		//	          "LessThanThreshold",
		//	          "LessThanOrEqualToThreshold"
		//	        ],
		//	        "type": "string"
		//	      },
		//	      "EvaluationPeriods": {
		//	        "description": "Length of time (in minutes) the metric must be at or beyond the threshold before a scaling event is triggered.",
		//	        "minimum": 1,
		//	        "type": "integer"
		//	      },
		//	      "MetricName": {
		//	        "description": "Name of the Amazon GameLift-defined metric that is used to trigger a scaling adjustment.",
		//	        "enum": [
		//	          "ActivatingGameSessions",
		//	          "ActiveGameSessions",
		//	          "ActiveInstances",
		//	          "AvailableGameSessions",
		//	          "AvailablePlayerSessions",
		//	          "CurrentPlayerSessions",
		//	          "IdleInstances",
		//	          "PercentAvailableGameSessions",
		//	          "PercentIdleInstances",
		//	          "QueueDepth",
		//	          "WaitTime",
		//	          "ConcurrentActivatableGameSessions"
		//	        ],
		//	        "type": "string"
		//	      },
		//	      "Name": {
		//	        "description": "A descriptive label that is associated with a fleet's scaling policy. Policy names do not need to be unique.",
		//	        "maxLength": 1024,
		//	        "minLength": 1,
		//	        "type": "string"
		//	      },
		//	      "PolicyType": {
		//	        "description": "The type of scaling policy to create. For a target-based policy, set the parameter MetricName to 'PercentAvailableGameSessions' and specify a TargetConfiguration. For a rule-based policy set the following parameters: MetricName, ComparisonOperator, Threshold, EvaluationPeriods, ScalingAdjustmentType, and ScalingAdjustment.",
		//	        "enum": [
		//	          "RuleBased",
		//	          "TargetBased"
		//	        ],
		//	        "type": "string"
		//	      },
		//	      "ScalingAdjustment": {
		//	        "description": "Amount of adjustment to make, based on the scaling adjustment type.",
		//	        "type": "integer"
		//	      },
		//	      "ScalingAdjustmentType": {
		//	        "description": "The type of adjustment to make to a fleet's instance count.",
		//	        "enum": [
		//	          "ChangeInCapacity",
		//	          "ExactCapacity",
		//	          "PercentChangeInCapacity"
		//	        ],
		//	        "type": "string"
		//	      },
		//	      "TargetConfiguration": {
		//	        "additionalProperties": false,
		//	        "description": "An object that contains settings for a target-based scaling policy.",
		//	        "properties": {
		//	          "TargetValue": {
		//	            "description": "Desired value to use with a target-based scaling policy. The value must be relevant for whatever metric the scaling policy is using. For example, in a policy using the metric PercentAvailableGameSessions, the target value should be the preferred size of the fleet's buffer (the percent of capacity that should be idle and ready for new game sessions).",
		//	            "type": "number"
		//	          }
		//	        },
		//	        "required": [
		//	          "TargetValue"
		//	        ],
		//	        "type": "object"
		//	      },
		//	      "Threshold": {
		//	        "description": "Metric value used to trigger a scaling event.",
		//	        "type": "number"
		//	      }
		//	    },
		//	    "required": [
		//	      "MetricName",
		//	      "Name"
		//	    ],
		//	    "type": "object"
		//	  },
		//	  "maxItems": 50,
		//	  "type": "array"
		//	}
		"scaling_policies": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: ComparisonOperator
					"comparison_operator": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "Comparison operator to use when measuring a metric against the threshold value.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.OneOf(
								"GreaterThanOrEqualToThreshold",
								"GreaterThanThreshold",
								"LessThanThreshold",
								"LessThanOrEqualToThreshold",
							),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: EvaluationPeriods
					"evaluation_periods": schema.Int64Attribute{ /*START ATTRIBUTE*/
						Description: "Length of time (in minutes) the metric must be at or beyond the threshold before a scaling event is triggered.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.Int64{ /*START VALIDATORS*/
							int64validator.AtLeast(1),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
							int64planmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: MetricName
					"metric_name": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "Name of the Amazon GameLift-defined metric that is used to trigger a scaling adjustment.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.OneOf(
								"ActivatingGameSessions",
								"ActiveGameSessions",
								"ActiveInstances",
								"AvailableGameSessions",
								"AvailablePlayerSessions",
								"CurrentPlayerSessions",
								"IdleInstances",
								"PercentAvailableGameSessions",
								"PercentIdleInstances",
								"QueueDepth",
								"WaitTime",
								"ConcurrentActivatableGameSessions",
							),
							fwvalidators.NotNullString(),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: Name
					"name": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "A descriptive label that is associated with a fleet's scaling policy. Policy names do not need to be unique.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.LengthBetween(1, 1024),
							fwvalidators.NotNullString(),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: PolicyType
					"policy_type": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The type of scaling policy to create. For a target-based policy, set the parameter MetricName to 'PercentAvailableGameSessions' and specify a TargetConfiguration. For a rule-based policy set the following parameters: MetricName, ComparisonOperator, Threshold, EvaluationPeriods, ScalingAdjustmentType, and ScalingAdjustment.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.OneOf(
								"RuleBased",
								"TargetBased",
							),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: ScalingAdjustment
					"scaling_adjustment": schema.Int64Attribute{ /*START ATTRIBUTE*/
						Description: "Amount of adjustment to make, based on the scaling adjustment type.",
						Optional:    true,
						Computed:    true,
						PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
							int64planmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: ScalingAdjustmentType
					"scaling_adjustment_type": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The type of adjustment to make to a fleet's instance count.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.OneOf(
								"ChangeInCapacity",
								"ExactCapacity",
								"PercentChangeInCapacity",
							),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: TargetConfiguration
					"target_configuration": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: TargetValue
							"target_value": schema.Float64Attribute{ /*START ATTRIBUTE*/
								Description: "Desired value to use with a target-based scaling policy. The value must be relevant for whatever metric the scaling policy is using. For example, in a policy using the metric PercentAvailableGameSessions, the target value should be the preferred size of the fleet's buffer (the percent of capacity that should be idle and ready for new game sessions).",
								Optional:    true,
								Computed:    true,
								Validators: []validator.Float64{ /*START VALIDATORS*/
									fwvalidators.NotNullFloat64(),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.Float64{ /*START PLAN MODIFIERS*/
									float64planmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
						Description: "An object that contains settings for a target-based scaling policy.",
						Optional:    true,
						Computed:    true,
						PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
							objectplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: Threshold
					"threshold": schema.Float64Attribute{ /*START ATTRIBUTE*/
						Description: "Metric value used to trigger a scaling event.",
						Optional:    true,
						Computed:    true,
						PlanModifiers: []planmodifier.Float64{ /*START PLAN MODIFIERS*/
							float64planmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Description: "A list of rules that control how a fleet is scaled.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.List{ /*START VALIDATORS*/
				listvalidator.SizeAtMost(50),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
				generic.Multiset(),
				listplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Status
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The current status of the container fleet.",
		//	  "enum": [
		//	    "PENDING",
		//	    "CREATING",
		//	    "CREATED",
		//	    "ACTIVATING",
		//	    "ACTIVE",
		//	    "UPDATING",
		//	    "DELETING"
		//	  ],
		//	  "type": "string"
		//	}
		"status": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The current status of the container fleet.",
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Tags
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "An array of key-value pairs to apply to this resource.",
		//	  "insertionOrder": false,
		//	  "items": {
		//	    "additionalProperties": false,
		//	    "description": "A key-value pair to associate with a resource.",
		//	    "properties": {
		//	      "Key": {
		//	        "description": "The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length.",
		//	        "maxLength": 128,
		//	        "minLength": 1,
		//	        "type": "string"
		//	      },
		//	      "Value": {
		//	        "description": "The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length.",
		//	        "maxLength": 256,
		//	        "minLength": 0,
		//	        "type": "string"
		//	      }
		//	    },
		//	    "required": [
		//	      "Key",
		//	      "Value"
		//	    ],
		//	    "type": "object"
		//	  },
		//	  "maxItems": 200,
		//	  "type": "array",
		//	  "uniqueItems": true
		//	}
		"tags": schema.SetNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: Key
					"key": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.LengthBetween(1, 128),
							fwvalidators.NotNullString(),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: Value
					"value": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.LengthBetween(0, 256),
							fwvalidators.NotNullString(),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Description: "An array of key-value pairs to apply to this resource.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.Set{ /*START VALIDATORS*/
				setvalidator.SizeAtMost(200),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.Set{ /*START PLAN MODIFIERS*/
				setplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
	} /*END SCHEMA*/

	// Corresponds to CloudFormation primaryIdentifier.
	attributes["id"] = schema.StringAttribute{
		Description: "Uniquely identifies the resource.",
		Computed:    true,
		PlanModifiers: []planmodifier.String{
			stringplanmodifier.UseStateForUnknown(),
		},
	}

	schema := schema.Schema{
		Description: "The AWS::GameLift::ContainerFleet resource creates an Amazon GameLift (GameLift) container fleet to host game servers.",
		Version:     1,
		Attributes:  attributes,
	}

	var opts generic.ResourceOptions

	opts = opts.WithCloudFormationTypeName("AWS::GameLift::ContainerFleet").WithTerraformTypeName("awscc_gamelift_container_fleet")
	opts = opts.WithTerraformSchema(schema)
	opts = opts.WithAttributeNameMap(map[string]string{
		"billing_type":             "BillingType",
		"comparison_operator":      "ComparisonOperator",
		"creation_time":            "CreationTime",
		"deployment_configuration": "DeploymentConfiguration",
		"deployment_details":       "DeploymentDetails",
		"description":              "Description",
		"desired_ec2_instances":    "DesiredEC2Instances",
		"evaluation_periods":       "EvaluationPeriods",
		"fleet_arn":                "FleetArn",
		"fleet_id":                 "FleetId",
		"fleet_role_arn":           "FleetRoleArn",
		"from_port":                "FromPort",
		"game_server_container_group_definition_arn":  "GameServerContainerGroupDefinitionArn",
		"game_server_container_group_definition_name": "GameServerContainerGroupDefinitionName",
		"game_server_container_groups_per_instance":   "GameServerContainerGroupsPerInstance",
		"game_session_creation_limit_policy":          "GameSessionCreationLimitPolicy",
		"impairment_strategy":                         "ImpairmentStrategy",
		"instance_connection_port_range":              "InstanceConnectionPortRange",
		"instance_inbound_permissions":                "InstanceInboundPermissions",
		"instance_type":                               "InstanceType",
		"ip_range":                                    "IpRange",
		"key":                                         "Key",
		"latest_deployment_id":                        "LatestDeploymentId",
		"location":                                    "Location",
		"location_capacity":                           "LocationCapacity",
		"locations":                                   "Locations",
		"log_configuration":                           "LogConfiguration",
		"log_destination":                             "LogDestination",
		"max_size":                                    "MaxSize",
		"maximum_game_server_container_groups_per_instance": "MaximumGameServerContainerGroupsPerInstance",
		"metric_groups":                      "MetricGroups",
		"metric_name":                        "MetricName",
		"min_size":                           "MinSize",
		"minimum_healthy_percentage":         "MinimumHealthyPercentage",
		"name":                               "Name",
		"new_game_session_protection_policy": "NewGameSessionProtectionPolicy",
		"new_game_sessions_per_creator":      "NewGameSessionsPerCreator",
		"per_instance_container_group_definition_arn":  "PerInstanceContainerGroupDefinitionArn",
		"per_instance_container_group_definition_name": "PerInstanceContainerGroupDefinitionName",
		"policy_period_in_minutes":                     "PolicyPeriodInMinutes",
		"policy_type":                                  "PolicyType",
		"protection_strategy":                          "ProtectionStrategy",
		"protocol":                                     "Protocol",
		"s3_bucket_name":                               "S3BucketName",
		"scaling_adjustment":                           "ScalingAdjustment",
		"scaling_adjustment_type":                      "ScalingAdjustmentType",
		"scaling_policies":                             "ScalingPolicies",
		"status":                                       "Status",
		"stopped_actions":                              "StoppedActions",
		"tags":                                         "Tags",
		"target_configuration":                         "TargetConfiguration",
		"target_value":                                 "TargetValue",
		"threshold":                                    "Threshold",
		"to_port":                                      "ToPort",
		"value":                                        "Value",
	})

	opts = opts.WithWriteOnlyPropertyPaths([]string{
		"/properties/DeploymentConfiguration",
		"/properties/GameServerContainerGroupDefinitionName",
		"/properties/PerInstanceContainerGroupDefinitionName",
	})
	opts = opts.WithCreateTimeoutInMinutes(0).WithDeleteTimeoutInMinutes(0)

	opts = opts.WithUpdateTimeoutInMinutes(0)

	v, err := generic.NewResource(ctx, opts...)

	if err != nil {
		return nil, err
	}

	return v, nil
}
