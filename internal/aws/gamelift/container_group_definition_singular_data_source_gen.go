// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// Code generated by generators/singular-data-source/main.go; DO NOT EDIT.

package gamelift

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-provider-awscc/internal/generic"
	"github.com/hashicorp/terraform-provider-awscc/internal/registry"
)

func init() {
	registry.AddDataSourceFactory("awscc_gamelift_container_group_definition", containerGroupDefinitionDataSource)
}

// containerGroupDefinitionDataSource returns the Terraform awscc_gamelift_container_group_definition data source.
// This Terraform data source corresponds to the CloudFormation AWS::GameLift::ContainerGroupDefinition resource.
func containerGroupDefinitionDataSource(ctx context.Context) (datasource.DataSource, error) {
	attributes := map[string]schema.Attribute{ /*START SCHEMA*/
		// Property: ContainerGroupDefinitionArn
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The Amazon Resource Name (ARN) that is assigned to a Amazon GameLift container group resource and uniquely identifies it across all AWS Regions.",
		//	  "maxLength": 512,
		//	  "minLength": 1,
		//	  "pattern": "^arn:.*:containergroupdefinition\\/[a-zA-Z0-9\\-]+(:[0-9]+)?$",
		//	  "type": "string"
		//	}
		"container_group_definition_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The Amazon Resource Name (ARN) that is assigned to a Amazon GameLift container group resource and uniquely identifies it across all AWS Regions.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: ContainerGroupType
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The scope of the container group",
		//	  "enum": [
		//	    "GAME_SERVER",
		//	    "PER_INSTANCE"
		//	  ],
		//	  "type": "string"
		//	}
		"container_group_type": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The scope of the container group",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: CreationTime
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A time stamp indicating when this data object was created. Format is a number expressed in Unix time as milliseconds (for example \"1469498468.057\").",
		//	  "type": "string"
		//	}
		"creation_time": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "A time stamp indicating when this data object was created. Format is a number expressed in Unix time as milliseconds (for example \"1469498468.057\").",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: GameServerContainerDefinition
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "Specifies the information required to run game servers with this container group",
		//	  "properties": {
		//	    "ContainerName": {
		//	      "description": "A descriptive label for the container definition. Container definition names must be unique with a container group definition.",
		//	      "maxLength": 128,
		//	      "minLength": 1,
		//	      "pattern": "^[a-zA-Z0-9-]+$",
		//	      "type": "string"
		//	    },
		//	    "DependsOn": {
		//	      "description": "A list of container dependencies that determines when this container starts up and shuts down. For container groups with multiple containers, dependencies let you define a startup/shutdown sequence across the containers.",
		//	      "insertionOrder": true,
		//	      "items": {
		//	        "additionalProperties": false,
		//	        "description": "A dependency that impacts a container's startup and shutdown.",
		//	        "properties": {
		//	          "Condition": {
		//	            "description": "The type of dependency.",
		//	            "enum": [
		//	              "START",
		//	              "COMPLETE",
		//	              "SUCCESS",
		//	              "HEALTHY"
		//	            ],
		//	            "type": "string"
		//	          },
		//	          "ContainerName": {
		//	            "description": "A descriptive label for the container definition. The container being defined depends on this container's condition.",
		//	            "maxLength": 128,
		//	            "minLength": 1,
		//	            "pattern": "^[a-zA-Z0-9-]+$",
		//	            "type": "string"
		//	          }
		//	        },
		//	        "required": [
		//	          "ContainerName",
		//	          "Condition"
		//	        ],
		//	        "type": "object"
		//	      },
		//	      "maxItems": 10,
		//	      "minItems": 1,
		//	      "type": "array",
		//	      "uniqueItems": true
		//	    },
		//	    "EnvironmentOverride": {
		//	      "description": "The environment variables to pass to a container.",
		//	      "insertionOrder": false,
		//	      "items": {
		//	        "additionalProperties": false,
		//	        "description": "An environment variable to set inside a container, in the form of a key-value pair.",
		//	        "properties": {
		//	          "Name": {
		//	            "description": "The environment variable name.",
		//	            "maxLength": 255,
		//	            "minLength": 1,
		//	            "pattern": "^.*$",
		//	            "type": "string"
		//	          },
		//	          "Value": {
		//	            "description": "The environment variable value.",
		//	            "maxLength": 255,
		//	            "minLength": 1,
		//	            "pattern": "^.*$",
		//	            "type": "string"
		//	          }
		//	        },
		//	        "required": [
		//	          "Name",
		//	          "Value"
		//	        ],
		//	        "type": "object"
		//	      },
		//	      "maxItems": 20,
		//	      "minItems": 1,
		//	      "type": "array",
		//	      "uniqueItems": true
		//	    },
		//	    "ImageUri": {
		//	      "description": "Specifies the image URI of this container.",
		//	      "maxLength": 255,
		//	      "minLength": 1,
		//	      "pattern": "^[a-zA-Z0-9-_\\.@\\/:]+$",
		//	      "type": "string"
		//	    },
		//	    "MountPoints": {
		//	      "description": "A list of mount point configurations to be used in a container.",
		//	      "insertionOrder": false,
		//	      "items": {
		//	        "additionalProperties": false,
		//	        "description": "Defines the mount point configuration within a container.",
		//	        "properties": {
		//	          "AccessLevel": {
		//	            "description": "The access permissions for the mounted path.",
		//	            "enum": [
		//	              "READ_ONLY",
		//	              "READ_AND_WRITE"
		//	            ],
		//	            "type": "string"
		//	          },
		//	          "ContainerPath": {
		//	            "description": "The path inside the container where the mount is accessible.",
		//	            "maxLength": 1024,
		//	            "minLength": 1,
		//	            "pattern": "^(\\/+[^\\/]+\\/*)+$",
		//	            "type": "string"
		//	          },
		//	          "InstancePath": {
		//	            "description": "The path on the host that will be mounted in the container.",
		//	            "maxLength": 1024,
		//	            "minLength": 1,
		//	            "pattern": "^\\/[\\s\\S]*$",
		//	            "type": "string"
		//	          }
		//	        },
		//	        "required": [
		//	          "InstancePath"
		//	        ],
		//	        "type": "object"
		//	      },
		//	      "maxItems": 10,
		//	      "minItems": 1,
		//	      "type": "array",
		//	      "uniqueItems": true
		//	    },
		//	    "PortConfiguration": {
		//	      "additionalProperties": false,
		//	      "description": "Defines the ports on the container.",
		//	      "properties": {
		//	        "ContainerPortRanges": {
		//	          "description": "Specifies one or more ranges of ports on a container.",
		//	          "insertionOrder": false,
		//	          "items": {
		//	            "additionalProperties": false,
		//	            "description": "A set of one or more port numbers that can be opened on the container.",
		//	            "properties": {
		//	              "FromPort": {
		//	                "description": "A starting value for the range of allowed port numbers.",
		//	                "maximum": 60000,
		//	                "minimum": 1,
		//	                "type": "integer"
		//	              },
		//	              "Protocol": {
		//	                "description": "Defines the protocol of these ports.",
		//	                "enum": [
		//	                  "TCP",
		//	                  "UDP"
		//	                ],
		//	                "type": "string"
		//	              },
		//	              "ToPort": {
		//	                "description": "An ending value for the range of allowed port numbers. Port numbers are end-inclusive. This value must be equal to or greater than FromPort.",
		//	                "maximum": 60000,
		//	                "minimum": 1,
		//	                "type": "integer"
		//	              }
		//	            },
		//	            "required": [
		//	              "FromPort",
		//	              "Protocol",
		//	              "ToPort"
		//	            ],
		//	            "type": "object"
		//	          },
		//	          "maxItems": 100,
		//	          "minItems": 1,
		//	          "type": "array",
		//	          "uniqueItems": true
		//	        }
		//	      },
		//	      "required": [
		//	        "ContainerPortRanges"
		//	      ],
		//	      "type": "object"
		//	    },
		//	    "ResolvedImageDigest": {
		//	      "description": "The digest of the container image.",
		//	      "pattern": "^sha256:[a-fA-F0-9]{64}$",
		//	      "type": "string"
		//	    },
		//	    "ServerSdkVersion": {
		//	      "description": "The version of the server SDK used in this container group",
		//	      "maxLength": 128,
		//	      "pattern": "^\\d+\\.\\d+\\.\\d+$",
		//	      "type": "string"
		//	    }
		//	  },
		//	  "required": [
		//	    "ContainerName",
		//	    "ImageUri",
		//	    "ServerSdkVersion"
		//	  ],
		//	  "type": "object"
		//	}
		"game_server_container_definition": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: ContainerName
				"container_name": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "A descriptive label for the container definition. Container definition names must be unique with a container group definition.",
					Computed:    true,
				}, /*END ATTRIBUTE*/
				// Property: DependsOn
				"depends_on": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
					NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: Condition
							"condition": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "The type of dependency.",
								Computed:    true,
							}, /*END ATTRIBUTE*/
							// Property: ContainerName
							"container_name": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "A descriptive label for the container definition. The container being defined depends on this container's condition.",
								Computed:    true,
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
					}, /*END NESTED OBJECT*/
					Description: "A list of container dependencies that determines when this container starts up and shuts down. For container groups with multiple containers, dependencies let you define a startup/shutdown sequence across the containers.",
					Computed:    true,
				}, /*END ATTRIBUTE*/
				// Property: EnvironmentOverride
				"environment_override": schema.SetNestedAttribute{ /*START ATTRIBUTE*/
					NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: Name
							"name": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "The environment variable name.",
								Computed:    true,
							}, /*END ATTRIBUTE*/
							// Property: Value
							"value": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "The environment variable value.",
								Computed:    true,
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
					}, /*END NESTED OBJECT*/
					Description: "The environment variables to pass to a container.",
					Computed:    true,
				}, /*END ATTRIBUTE*/
				// Property: ImageUri
				"image_uri": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "Specifies the image URI of this container.",
					Computed:    true,
				}, /*END ATTRIBUTE*/
				// Property: MountPoints
				"mount_points": schema.SetNestedAttribute{ /*START ATTRIBUTE*/
					NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: AccessLevel
							"access_level": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "The access permissions for the mounted path.",
								Computed:    true,
							}, /*END ATTRIBUTE*/
							// Property: ContainerPath
							"container_path": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "The path inside the container where the mount is accessible.",
								Computed:    true,
							}, /*END ATTRIBUTE*/
							// Property: InstancePath
							"instance_path": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "The path on the host that will be mounted in the container.",
								Computed:    true,
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
					}, /*END NESTED OBJECT*/
					Description: "A list of mount point configurations to be used in a container.",
					Computed:    true,
				}, /*END ATTRIBUTE*/
				// Property: PortConfiguration
				"port_configuration": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
					Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
						// Property: ContainerPortRanges
						"container_port_ranges": schema.SetNestedAttribute{ /*START ATTRIBUTE*/
							NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
								Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
									// Property: FromPort
									"from_port": schema.Int64Attribute{ /*START ATTRIBUTE*/
										Description: "A starting value for the range of allowed port numbers.",
										Computed:    true,
									}, /*END ATTRIBUTE*/
									// Property: Protocol
									"protocol": schema.StringAttribute{ /*START ATTRIBUTE*/
										Description: "Defines the protocol of these ports.",
										Computed:    true,
									}, /*END ATTRIBUTE*/
									// Property: ToPort
									"to_port": schema.Int64Attribute{ /*START ATTRIBUTE*/
										Description: "An ending value for the range of allowed port numbers. Port numbers are end-inclusive. This value must be equal to or greater than FromPort.",
										Computed:    true,
									}, /*END ATTRIBUTE*/
								}, /*END SCHEMA*/
							}, /*END NESTED OBJECT*/
							Description: "Specifies one or more ranges of ports on a container.",
							Computed:    true,
						}, /*END ATTRIBUTE*/
					}, /*END SCHEMA*/
					Description: "Defines the ports on the container.",
					Computed:    true,
				}, /*END ATTRIBUTE*/
				// Property: ResolvedImageDigest
				"resolved_image_digest": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "The digest of the container image.",
					Computed:    true,
				}, /*END ATTRIBUTE*/
				// Property: ServerSdkVersion
				"server_sdk_version": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "The version of the server SDK used in this container group",
					Computed:    true,
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "Specifies the information required to run game servers with this container group",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: Name
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A descriptive label for the container group definition.",
		//	  "maxLength": 128,
		//	  "minLength": 1,
		//	  "pattern": "^[a-zA-Z0-9-]+$",
		//	  "type": "string"
		//	}
		"name": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "A descriptive label for the container group definition.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: OperatingSystem
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The operating system of the container group",
		//	  "enum": [
		//	    "AMAZON_LINUX_2023"
		//	  ],
		//	  "type": "string"
		//	}
		"operating_system": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The operating system of the container group",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: SourceVersionNumber
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A specific ContainerGroupDefinition version to be updated",
		//	  "minimum": 0,
		//	  "type": "integer"
		//	}
		"source_version_number": schema.Int64Attribute{ /*START ATTRIBUTE*/
			Description: "A specific ContainerGroupDefinition version to be updated",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: Status
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A string indicating ContainerGroupDefinition status.",
		//	  "enum": [
		//	    "READY",
		//	    "COPYING",
		//	    "FAILED"
		//	  ],
		//	  "type": "string"
		//	}
		"status": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "A string indicating ContainerGroupDefinition status.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: StatusReason
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A string indicating the reason for ContainerGroupDefinition status.",
		//	  "type": "string"
		//	}
		"status_reason": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "A string indicating the reason for ContainerGroupDefinition status.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: SupportContainerDefinitions
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A collection of support container definitions that define the containers in this group.",
		//	  "insertionOrder": false,
		//	  "items": {
		//	    "additionalProperties": false,
		//	    "description": "Supports the function of the main container group",
		//	    "properties": {
		//	      "ContainerName": {
		//	        "description": "A descriptive label for the container definition.",
		//	        "maxLength": 128,
		//	        "minLength": 1,
		//	        "pattern": "^[a-zA-Z0-9-]+$",
		//	        "type": "string"
		//	      },
		//	      "DependsOn": {
		//	        "description": "A list of container dependencies that determines when this container starts up and shuts down. For container groups with multiple containers, dependencies let you define a startup/shutdown sequence across the containers.",
		//	        "insertionOrder": true,
		//	        "items": {
		//	          "additionalProperties": false,
		//	          "description": "A dependency that impacts a container's startup and shutdown.",
		//	          "properties": {
		//	            "Condition": {
		//	              "description": "The type of dependency.",
		//	              "enum": [
		//	                "START",
		//	                "COMPLETE",
		//	                "SUCCESS",
		//	                "HEALTHY"
		//	              ],
		//	              "type": "string"
		//	            },
		//	            "ContainerName": {
		//	              "description": "A descriptive label for the container definition. The container being defined depends on this container's condition.",
		//	              "maxLength": 128,
		//	              "minLength": 1,
		//	              "pattern": "^[a-zA-Z0-9-]+$",
		//	              "type": "string"
		//	            }
		//	          },
		//	          "required": [
		//	            "ContainerName",
		//	            "Condition"
		//	          ],
		//	          "type": "object"
		//	        },
		//	        "maxItems": 10,
		//	        "minItems": 1,
		//	        "type": "array",
		//	        "uniqueItems": true
		//	      },
		//	      "EnvironmentOverride": {
		//	        "description": "The environment variables to pass to a container.",
		//	        "insertionOrder": false,
		//	        "items": {
		//	          "additionalProperties": false,
		//	          "description": "An environment variable to set inside a container, in the form of a key-value pair.",
		//	          "properties": {
		//	            "Name": {
		//	              "description": "The environment variable name.",
		//	              "maxLength": 255,
		//	              "minLength": 1,
		//	              "pattern": "^.*$",
		//	              "type": "string"
		//	            },
		//	            "Value": {
		//	              "description": "The environment variable value.",
		//	              "maxLength": 255,
		//	              "minLength": 1,
		//	              "pattern": "^.*$",
		//	              "type": "string"
		//	            }
		//	          },
		//	          "required": [
		//	            "Name",
		//	            "Value"
		//	          ],
		//	          "type": "object"
		//	        },
		//	        "maxItems": 20,
		//	        "minItems": 1,
		//	        "type": "array",
		//	        "uniqueItems": true
		//	      },
		//	      "Essential": {
		//	        "description": "Specifies if the container is essential. If an essential container fails a health check, then all containers in the container group will be restarted. You must specify exactly 1 essential container in a container group.",
		//	        "type": "boolean"
		//	      },
		//	      "HealthCheck": {
		//	        "additionalProperties": false,
		//	        "description": "Specifies how the health of the containers will be checked.",
		//	        "properties": {
		//	          "Command": {
		//	            "description": "A string array representing the command that the container runs to determine if it is healthy.",
		//	            "insertionOrder": true,
		//	            "items": {
		//	              "maxLength": 255,
		//	              "minLength": 1,
		//	              "pattern": "^.*$",
		//	              "type": "string"
		//	            },
		//	            "maxItems": 20,
		//	            "minItems": 1,
		//	            "type": "array",
		//	            "uniqueItems": false
		//	          },
		//	          "Interval": {
		//	            "description": "How often (in seconds) the health is checked.",
		//	            "maximum": 300,
		//	            "minimum": 60,
		//	            "type": "integer"
		//	          },
		//	          "Retries": {
		//	            "description": "How many times the process manager will retry the command after a timeout. (The first run of the command does not count as a retry.)",
		//	            "maximum": 10,
		//	            "minimum": 5,
		//	            "type": "integer"
		//	          },
		//	          "StartPeriod": {
		//	            "description": "The optional grace period (in seconds) to give a container time to boostrap before teh health check is declared failed.",
		//	            "maximum": 300,
		//	            "minimum": 0,
		//	            "type": "integer"
		//	          },
		//	          "Timeout": {
		//	            "description": "How many seconds the process manager allows the command to run before canceling it.",
		//	            "maximum": 60,
		//	            "minimum": 30,
		//	            "type": "integer"
		//	          }
		//	        },
		//	        "required": [
		//	          "Command"
		//	        ],
		//	        "type": "object"
		//	      },
		//	      "ImageUri": {
		//	        "description": "Specifies the image URI of this container.",
		//	        "maxLength": 255,
		//	        "minLength": 1,
		//	        "pattern": "^[a-zA-Z0-9-_\\.@\\/:]+$",
		//	        "type": "string"
		//	      },
		//	      "MemoryHardLimitMebibytes": {
		//	        "description": "The total memory limit of container groups following this definition in MiB",
		//	        "maximum": 1024000,
		//	        "minimum": 4,
		//	        "type": "integer"
		//	      },
		//	      "MountPoints": {
		//	        "description": "A list of mount point configurations to be used in a container.",
		//	        "insertionOrder": false,
		//	        "items": {
		//	          "additionalProperties": false,
		//	          "description": "Defines the mount point configuration within a container.",
		//	          "properties": {
		//	            "AccessLevel": {
		//	              "description": "The access permissions for the mounted path.",
		//	              "enum": [
		//	                "READ_ONLY",
		//	                "READ_AND_WRITE"
		//	              ],
		//	              "type": "string"
		//	            },
		//	            "ContainerPath": {
		//	              "description": "The path inside the container where the mount is accessible.",
		//	              "maxLength": 1024,
		//	              "minLength": 1,
		//	              "pattern": "^(\\/+[^\\/]+\\/*)+$",
		//	              "type": "string"
		//	            },
		//	            "InstancePath": {
		//	              "description": "The path on the host that will be mounted in the container.",
		//	              "maxLength": 1024,
		//	              "minLength": 1,
		//	              "pattern": "^\\/[\\s\\S]*$",
		//	              "type": "string"
		//	            }
		//	          },
		//	          "required": [
		//	            "InstancePath"
		//	          ],
		//	          "type": "object"
		//	        },
		//	        "maxItems": 10,
		//	        "minItems": 1,
		//	        "type": "array",
		//	        "uniqueItems": true
		//	      },
		//	      "PortConfiguration": {
		//	        "additionalProperties": false,
		//	        "description": "Defines the ports on the container.",
		//	        "properties": {
		//	          "ContainerPortRanges": {
		//	            "description": "Specifies one or more ranges of ports on a container.",
		//	            "insertionOrder": false,
		//	            "items": {
		//	              "additionalProperties": false,
		//	              "description": "A set of one or more port numbers that can be opened on the container.",
		//	              "properties": {
		//	                "FromPort": {
		//	                  "description": "A starting value for the range of allowed port numbers.",
		//	                  "maximum": 60000,
		//	                  "minimum": 1,
		//	                  "type": "integer"
		//	                },
		//	                "Protocol": {
		//	                  "description": "Defines the protocol of these ports.",
		//	                  "enum": [
		//	                    "TCP",
		//	                    "UDP"
		//	                  ],
		//	                  "type": "string"
		//	                },
		//	                "ToPort": {
		//	                  "description": "An ending value for the range of allowed port numbers. Port numbers are end-inclusive. This value must be equal to or greater than FromPort.",
		//	                  "maximum": 60000,
		//	                  "minimum": 1,
		//	                  "type": "integer"
		//	                }
		//	              },
		//	              "required": [
		//	                "FromPort",
		//	                "Protocol",
		//	                "ToPort"
		//	              ],
		//	              "type": "object"
		//	            },
		//	            "maxItems": 100,
		//	            "minItems": 1,
		//	            "type": "array",
		//	            "uniqueItems": true
		//	          }
		//	        },
		//	        "required": [
		//	          "ContainerPortRanges"
		//	        ],
		//	        "type": "object"
		//	      },
		//	      "ResolvedImageDigest": {
		//	        "description": "The digest of the container image.",
		//	        "pattern": "^sha256:[a-fA-F0-9]{64}$",
		//	        "type": "string"
		//	      },
		//	      "Vcpu": {
		//	        "description": "The number of virtual CPUs to give to the support group",
		//	        "maximum": 10,
		//	        "minimum": 0.125,
		//	        "type": "number"
		//	      }
		//	    },
		//	    "required": [
		//	      "ContainerName",
		//	      "ImageUri"
		//	    ],
		//	    "type": "object"
		//	  },
		//	  "maxItems": 10,
		//	  "minItems": 1,
		//	  "type": "array",
		//	  "uniqueItems": true
		//	}
		"support_container_definitions": schema.SetNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: ContainerName
					"container_name": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "A descriptive label for the container definition.",
						Computed:    true,
					}, /*END ATTRIBUTE*/
					// Property: DependsOn
					"depends_on": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
						NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: Condition
								"condition": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The type of dependency.",
									Computed:    true,
								}, /*END ATTRIBUTE*/
								// Property: ContainerName
								"container_name": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "A descriptive label for the container definition. The container being defined depends on this container's condition.",
									Computed:    true,
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
						}, /*END NESTED OBJECT*/
						Description: "A list of container dependencies that determines when this container starts up and shuts down. For container groups with multiple containers, dependencies let you define a startup/shutdown sequence across the containers.",
						Computed:    true,
					}, /*END ATTRIBUTE*/
					// Property: EnvironmentOverride
					"environment_override": schema.SetNestedAttribute{ /*START ATTRIBUTE*/
						NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: Name
								"name": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The environment variable name.",
									Computed:    true,
								}, /*END ATTRIBUTE*/
								// Property: Value
								"value": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The environment variable value.",
									Computed:    true,
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
						}, /*END NESTED OBJECT*/
						Description: "The environment variables to pass to a container.",
						Computed:    true,
					}, /*END ATTRIBUTE*/
					// Property: Essential
					"essential": schema.BoolAttribute{ /*START ATTRIBUTE*/
						Description: "Specifies if the container is essential. If an essential container fails a health check, then all containers in the container group will be restarted. You must specify exactly 1 essential container in a container group.",
						Computed:    true,
					}, /*END ATTRIBUTE*/
					// Property: HealthCheck
					"health_check": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: Command
							"command": schema.ListAttribute{ /*START ATTRIBUTE*/
								ElementType: types.StringType,
								Description: "A string array representing the command that the container runs to determine if it is healthy.",
								Computed:    true,
							}, /*END ATTRIBUTE*/
							// Property: Interval
							"interval": schema.Int64Attribute{ /*START ATTRIBUTE*/
								Description: "How often (in seconds) the health is checked.",
								Computed:    true,
							}, /*END ATTRIBUTE*/
							// Property: Retries
							"retries": schema.Int64Attribute{ /*START ATTRIBUTE*/
								Description: "How many times the process manager will retry the command after a timeout. (The first run of the command does not count as a retry.)",
								Computed:    true,
							}, /*END ATTRIBUTE*/
							// Property: StartPeriod
							"start_period": schema.Int64Attribute{ /*START ATTRIBUTE*/
								Description: "The optional grace period (in seconds) to give a container time to boostrap before teh health check is declared failed.",
								Computed:    true,
							}, /*END ATTRIBUTE*/
							// Property: Timeout
							"timeout": schema.Int64Attribute{ /*START ATTRIBUTE*/
								Description: "How many seconds the process manager allows the command to run before canceling it.",
								Computed:    true,
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
						Description: "Specifies how the health of the containers will be checked.",
						Computed:    true,
					}, /*END ATTRIBUTE*/
					// Property: ImageUri
					"image_uri": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "Specifies the image URI of this container.",
						Computed:    true,
					}, /*END ATTRIBUTE*/
					// Property: MemoryHardLimitMebibytes
					"memory_hard_limit_mebibytes": schema.Int64Attribute{ /*START ATTRIBUTE*/
						Description: "The total memory limit of container groups following this definition in MiB",
						Computed:    true,
					}, /*END ATTRIBUTE*/
					// Property: MountPoints
					"mount_points": schema.SetNestedAttribute{ /*START ATTRIBUTE*/
						NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: AccessLevel
								"access_level": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The access permissions for the mounted path.",
									Computed:    true,
								}, /*END ATTRIBUTE*/
								// Property: ContainerPath
								"container_path": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The path inside the container where the mount is accessible.",
									Computed:    true,
								}, /*END ATTRIBUTE*/
								// Property: InstancePath
								"instance_path": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The path on the host that will be mounted in the container.",
									Computed:    true,
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
						}, /*END NESTED OBJECT*/
						Description: "A list of mount point configurations to be used in a container.",
						Computed:    true,
					}, /*END ATTRIBUTE*/
					// Property: PortConfiguration
					"port_configuration": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: ContainerPortRanges
							"container_port_ranges": schema.SetNestedAttribute{ /*START ATTRIBUTE*/
								NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
									Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
										// Property: FromPort
										"from_port": schema.Int64Attribute{ /*START ATTRIBUTE*/
											Description: "A starting value for the range of allowed port numbers.",
											Computed:    true,
										}, /*END ATTRIBUTE*/
										// Property: Protocol
										"protocol": schema.StringAttribute{ /*START ATTRIBUTE*/
											Description: "Defines the protocol of these ports.",
											Computed:    true,
										}, /*END ATTRIBUTE*/
										// Property: ToPort
										"to_port": schema.Int64Attribute{ /*START ATTRIBUTE*/
											Description: "An ending value for the range of allowed port numbers. Port numbers are end-inclusive. This value must be equal to or greater than FromPort.",
											Computed:    true,
										}, /*END ATTRIBUTE*/
									}, /*END SCHEMA*/
								}, /*END NESTED OBJECT*/
								Description: "Specifies one or more ranges of ports on a container.",
								Computed:    true,
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
						Description: "Defines the ports on the container.",
						Computed:    true,
					}, /*END ATTRIBUTE*/
					// Property: ResolvedImageDigest
					"resolved_image_digest": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The digest of the container image.",
						Computed:    true,
					}, /*END ATTRIBUTE*/
					// Property: Vcpu
					"vcpu": schema.Float64Attribute{ /*START ATTRIBUTE*/
						Description: "The number of virtual CPUs to give to the support group",
						Computed:    true,
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Description: "A collection of support container definitions that define the containers in this group.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: Tags
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "An array of key-value pairs to apply to this resource.",
		//	  "insertionOrder": false,
		//	  "items": {
		//	    "additionalProperties": false,
		//	    "description": "A key-value pair to associate with a resource.",
		//	    "properties": {
		//	      "Key": {
		//	        "description": "The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length.",
		//	        "maxLength": 128,
		//	        "minLength": 1,
		//	        "pattern": "^.*$",
		//	        "type": "string"
		//	      },
		//	      "Value": {
		//	        "description": "The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length.",
		//	        "maxLength": 256,
		//	        "minLength": 0,
		//	        "pattern": "^.*$",
		//	        "type": "string"
		//	      }
		//	    },
		//	    "required": [
		//	      "Key",
		//	      "Value"
		//	    ],
		//	    "type": "object"
		//	  },
		//	  "maxItems": 200,
		//	  "minItems": 0,
		//	  "type": "array",
		//	  "uniqueItems": true
		//	}
		"tags": schema.SetNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: Key
					"key": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length.",
						Computed:    true,
					}, /*END ATTRIBUTE*/
					// Property: Value
					"value": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length.",
						Computed:    true,
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Description: "An array of key-value pairs to apply to this resource.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: TotalMemoryLimitMebibytes
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The total memory limit of container groups following this definition in MiB",
		//	  "maximum": 1024000,
		//	  "minimum": 4,
		//	  "type": "integer"
		//	}
		"total_memory_limit_mebibytes": schema.Int64Attribute{ /*START ATTRIBUTE*/
			Description: "The total memory limit of container groups following this definition in MiB",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: TotalVcpuLimit
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The total amount of virtual CPUs on the container group definition",
		//	  "maximum": 10,
		//	  "minimum": 0.125,
		//	  "type": "number"
		//	}
		"total_vcpu_limit": schema.Float64Attribute{ /*START ATTRIBUTE*/
			Description: "The total amount of virtual CPUs on the container group definition",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: VersionDescription
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The description of this version",
		//	  "maxLength": 1024,
		//	  "minLength": 1,
		//	  "type": "string"
		//	}
		"version_description": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The description of this version",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: VersionNumber
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The version of this ContainerGroupDefinition",
		//	  "minimum": 0,
		//	  "type": "integer"
		//	}
		"version_number": schema.Int64Attribute{ /*START ATTRIBUTE*/
			Description: "The version of this ContainerGroupDefinition",
			Computed:    true,
		}, /*END ATTRIBUTE*/
	} /*END SCHEMA*/

	attributes["id"] = schema.StringAttribute{
		Description: "Uniquely identifies the resource.",
		Required:    true,
	}

	schema := schema.Schema{
		Description: "Data Source schema for AWS::GameLift::ContainerGroupDefinition",
		Attributes:  attributes,
	}

	var opts generic.DataSourceOptions

	opts = opts.WithCloudFormationTypeName("AWS::GameLift::ContainerGroupDefinition").WithTerraformTypeName("awscc_gamelift_container_group_definition")
	opts = opts.WithTerraformSchema(schema)
	opts = opts.WithAttributeNameMap(map[string]string{
		"access_level":                     "AccessLevel",
		"command":                          "Command",
		"condition":                        "Condition",
		"container_group_definition_arn":   "ContainerGroupDefinitionArn",
		"container_group_type":             "ContainerGroupType",
		"container_name":                   "ContainerName",
		"container_path":                   "ContainerPath",
		"container_port_ranges":            "ContainerPortRanges",
		"creation_time":                    "CreationTime",
		"depends_on":                       "DependsOn",
		"environment_override":             "EnvironmentOverride",
		"essential":                        "Essential",
		"from_port":                        "FromPort",
		"game_server_container_definition": "GameServerContainerDefinition",
		"health_check":                     "HealthCheck",
		"image_uri":                        "ImageUri",
		"instance_path":                    "InstancePath",
		"interval":                         "Interval",
		"key":                              "Key",
		"memory_hard_limit_mebibytes":      "MemoryHardLimitMebibytes",
		"mount_points":                     "MountPoints",
		"name":                             "Name",
		"operating_system":                 "OperatingSystem",
		"port_configuration":               "PortConfiguration",
		"protocol":                         "Protocol",
		"resolved_image_digest":            "ResolvedImageDigest",
		"retries":                          "Retries",
		"server_sdk_version":               "ServerSdkVersion",
		"source_version_number":            "SourceVersionNumber",
		"start_period":                     "StartPeriod",
		"status":                           "Status",
		"status_reason":                    "StatusReason",
		"support_container_definitions":    "SupportContainerDefinitions",
		"tags":                             "Tags",
		"timeout":                          "Timeout",
		"to_port":                          "ToPort",
		"total_memory_limit_mebibytes":     "TotalMemoryLimitMebibytes",
		"total_vcpu_limit":                 "TotalVcpuLimit",
		"value":                            "Value",
		"vcpu":                             "Vcpu",
		"version_description":              "VersionDescription",
		"version_number":                   "VersionNumber",
	})

	v, err := generic.NewSingularDataSource(ctx, opts...)

	if err != nil {
		return nil, err
	}

	return v, nil
}
