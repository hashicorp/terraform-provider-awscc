// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// Code generated by generators/resource/main.go; DO NOT EDIT.

package mediatailor

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/setplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-provider-awscc/internal/generic"
	"github.com/hashicorp/terraform-provider-awscc/internal/identity"
	"github.com/hashicorp/terraform-provider-awscc/internal/registry"
	fwvalidators "github.com/hashicorp/terraform-provider-awscc/internal/validators"
)

func init() {
	registry.AddResourceFactory("awscc_mediatailor_source_location", sourceLocationResource)
	registry.AddListResourceFactory("awscc_mediatailor_source_location", generic.NewListResource(sourceLocationResource))
}

// sourceLocationResource returns the Terraform awscc_mediatailor_source_location resource.
// This Terraform resource corresponds to the CloudFormation AWS::MediaTailor::SourceLocation resource.
func sourceLocationResource(ctx context.Context) (resource.Resource, error) {
	attributes := map[string]schema.Attribute{ /*START SCHEMA*/
		// Property: AccessConfiguration
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "\u003cp\u003eAccess configuration parameters.\u003c/p\u003e",
		//	  "properties": {
		//	    "AccessType": {
		//	      "enum": [
		//	        "S3_SIGV4",
		//	        "SECRETS_MANAGER_ACCESS_TOKEN",
		//	        "AUTODETECT_SIGV4"
		//	      ],
		//	      "type": "string"
		//	    },
		//	    "SecretsManagerAccessTokenConfiguration": {
		//	      "additionalProperties": false,
		//	      "description": "\u003cp\u003eAWS Secrets Manager access token configuration parameters. For information about Secrets Manager access token authentication, see \u003ca href=\"https://docs.aws.amazon.com/mediatailor/latest/ug/channel-assembly-access-configuration-access-token.html\"\u003eWorking with AWS Secrets Manager access token authentication\u003c/a\u003e.\u003c/p\u003e",
		//	      "properties": {
		//	        "HeaderName": {
		//	          "description": "\u003cp\u003eThe name of the HTTP header used to supply the access token in requests to the source location.\u003c/p\u003e",
		//	          "type": "string"
		//	        },
		//	        "SecretArn": {
		//	          "description": "\u003cp\u003eThe Amazon Resource Name (ARN) of the AWS Secrets Manager secret that contains the access token.\u003c/p\u003e",
		//	          "type": "string"
		//	        },
		//	        "SecretStringKey": {
		//	          "description": "\u003cp\u003eThe AWS Secrets Manager \u003ca href=\"https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_CreateSecret.html#SecretsManager-CreateSecret-request-SecretString.html\"\u003eSecretString\u003c/a\u003e key associated with the access token. MediaTailor uses the key to look up SecretString key and value pair containing the access token.\u003c/p\u003e",
		//	          "type": "string"
		//	        }
		//	      },
		//	      "type": "object"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"access_configuration": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: AccessType
				"access_type": schema.StringAttribute{ /*START ATTRIBUTE*/
					Optional: true,
					Computed: true,
					Validators: []validator.String{ /*START VALIDATORS*/
						stringvalidator.OneOf(
							"S3_SIGV4",
							"SECRETS_MANAGER_ACCESS_TOKEN",
							"AUTODETECT_SIGV4",
						),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: SecretsManagerAccessTokenConfiguration
				"secrets_manager_access_token_configuration": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
					Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
						// Property: HeaderName
						"header_name": schema.StringAttribute{ /*START ATTRIBUTE*/
							Description: "<p>The name of the HTTP header used to supply the access token in requests to the source location.</p>",
							Optional:    true,
							Computed:    true,
							PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
								stringplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
						// Property: SecretArn
						"secret_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
							Description: "<p>The Amazon Resource Name (ARN) of the AWS Secrets Manager secret that contains the access token.</p>",
							Optional:    true,
							Computed:    true,
							PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
								stringplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
						// Property: SecretStringKey
						"secret_string_key": schema.StringAttribute{ /*START ATTRIBUTE*/
							Description: "<p>The AWS Secrets Manager <a href=\"https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_CreateSecret.html#SecretsManager-CreateSecret-request-SecretString.html\">SecretString</a> key associated with the access token. MediaTailor uses the key to look up SecretString key and value pair containing the access token.</p>",
							Optional:    true,
							Computed:    true,
							PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
								stringplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
					}, /*END SCHEMA*/
					Description: "<p>AWS Secrets Manager access token configuration parameters. For information about Secrets Manager access token authentication, see <a href=\"https://docs.aws.amazon.com/mediatailor/latest/ug/channel-assembly-access-configuration-access-token.html\">Working with AWS Secrets Manager access token authentication</a>.</p>",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
						objectplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "<p>Access configuration parameters.</p>",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Arn
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "\u003cp\u003eThe ARN of the source location.\u003c/p\u003e",
		//	  "type": "string"
		//	}
		"arn": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "<p>The ARN of the source location.</p>",
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: DefaultSegmentDeliveryConfiguration
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "\u003cp\u003eThe optional configuration for a server that serves segments. Use this if you want the segment delivery server to be different from the source location server. For example, you can configure your source location server to be an origination server, such as MediaPackage, and the segment delivery server to be a content delivery network (CDN), such as CloudFront. If you don't specify a segment delivery server, then the source location server is used.\u003c/p\u003e",
		//	  "properties": {
		//	    "BaseUrl": {
		//	      "description": "\u003cp\u003eThe hostname of the server that will be used to serve segments. This string must include the protocol, such as \u003cb\u003ehttps://\u003c/b\u003e.\u003c/p\u003e",
		//	      "type": "string"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"default_segment_delivery_configuration": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: BaseUrl
				"base_url": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "<p>The hostname of the server that will be used to serve segments. This string must include the protocol, such as <b>https://</b>.</p>",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "<p>The optional configuration for a server that serves segments. Use this if you want the segment delivery server to be different from the source location server. For example, you can configure your source location server to be an origination server, such as MediaPackage, and the segment delivery server to be a content delivery network (CDN), such as CloudFront. If you don't specify a segment delivery server, then the source location server is used.</p>",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: HttpConfiguration
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "\u003cp\u003eThe HTTP configuration for the source location.\u003c/p\u003e",
		//	  "properties": {
		//	    "BaseUrl": {
		//	      "description": "\u003cp\u003eThe base URL for the source location host server. This string must include the protocol, such as \u003cb\u003ehttps://\u003c/b\u003e.\u003c/p\u003e",
		//	      "type": "string"
		//	    }
		//	  },
		//	  "required": [
		//	    "BaseUrl"
		//	  ],
		//	  "type": "object"
		//	}
		"http_configuration": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: BaseUrl
				"base_url": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "<p>The base URL for the source location host server. This string must include the protocol, such as <b>https://</b>.</p>",
					Required:    true,
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "<p>The HTTP configuration for the source location.</p>",
			Required:    true,
		}, /*END ATTRIBUTE*/
		// Property: SegmentDeliveryConfigurations
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "\u003cp\u003eA list of the segment delivery configurations associated with this resource.\u003c/p\u003e",
		//	  "insertionOrder": false,
		//	  "items": {
		//	    "additionalProperties": false,
		//	    "description": "\u003cp\u003eThe segment delivery configuration settings.\u003c/p\u003e",
		//	    "properties": {
		//	      "BaseUrl": {
		//	        "description": "\u003cp\u003eThe base URL of the host or path of the segment delivery server that you're using to serve segments. This is typically a content delivery network (CDN). The URL can be absolute or relative. To use an absolute URL include the protocol, such as \u003ccode\u003ehttps://example.com/some/path\u003c/code\u003e. To use a relative URL specify the relative path, such as \u003ccode\u003e/some/path*\u003c/code\u003e.\u003c/p\u003e",
		//	        "type": "string"
		//	      },
		//	      "Name": {
		//	        "description": "\u003cp\u003eA unique identifier used to distinguish between multiple segment delivery configurations in a source location.\u003c/p\u003e",
		//	        "type": "string"
		//	      }
		//	    },
		//	    "type": "object"
		//	  },
		//	  "type": "array"
		//	}
		"segment_delivery_configurations": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: BaseUrl
					"base_url": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "<p>The base URL of the host or path of the segment delivery server that you're using to serve segments. This is typically a content delivery network (CDN). The URL can be absolute or relative. To use an absolute URL include the protocol, such as <code>https://example.com/some/path</code>. To use a relative URL specify the relative path, such as <code>/some/path*</code>.</p>",
						Optional:    true,
						Computed:    true,
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: Name
					"name": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "<p>A unique identifier used to distinguish between multiple segment delivery configurations in a source location.</p>",
						Optional:    true,
						Computed:    true,
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Description: "<p>A list of the segment delivery configurations associated with this resource.</p>",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
				generic.Multiset(),
				listplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: SourceLocationName
		// CloudFormation resource type schema:
		//
		//	{
		//	  "type": "string"
		//	}
		"source_location_name": schema.StringAttribute{ /*START ATTRIBUTE*/
			Required: true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.RequiresReplace(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Tags
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The tags to assign to the source location.",
		//	  "insertionOrder": false,
		//	  "items": {
		//	    "additionalProperties": false,
		//	    "properties": {
		//	      "Key": {
		//	        "type": "string"
		//	      },
		//	      "Value": {
		//	        "type": "string"
		//	      }
		//	    },
		//	    "required": [
		//	      "Value",
		//	      "Key"
		//	    ],
		//	    "type": "object"
		//	  },
		//	  "type": "array",
		//	  "uniqueItems": true
		//	}
		"tags": schema.SetNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: Key
					"key": schema.StringAttribute{ /*START ATTRIBUTE*/
						Optional: true,
						Computed: true,
						Validators: []validator.String{ /*START VALIDATORS*/
							fwvalidators.NotNullString(),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: Value
					"value": schema.StringAttribute{ /*START ATTRIBUTE*/
						Optional: true,
						Computed: true,
						Validators: []validator.String{ /*START VALIDATORS*/
							fwvalidators.NotNullString(),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Description: "The tags to assign to the source location.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Set{ /*START PLAN MODIFIERS*/
				setplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
	} /*END SCHEMA*/

	// Corresponds to CloudFormation primaryIdentifier.
	attributes["id"] = schema.StringAttribute{
		Description: "Uniquely identifies the resource.",
		Computed:    true,
		PlanModifiers: []planmodifier.String{
			stringplanmodifier.UseStateForUnknown(),
		},
	}

	schema := schema.Schema{
		Description: "Definition of AWS::MediaTailor::SourceLocation Resource Type",
		Version:     1,
		Attributes:  attributes,
	}

	var opts generic.ResourceOptions

	opts = opts.WithCloudFormationTypeName("AWS::MediaTailor::SourceLocation").WithTerraformTypeName("awscc_mediatailor_source_location")
	opts = opts.WithTerraformSchema(schema)
	opts = opts.WithPrimaryIdentifier(
		identity.Identifier{
			Name:              "source_location_name",
			RequiredForImport: true,
		})

	opts = opts.WithAttributeNameMap(map[string]string{
		"access_configuration":                   "AccessConfiguration",
		"access_type":                            "AccessType",
		"arn":                                    "Arn",
		"base_url":                               "BaseUrl",
		"default_segment_delivery_configuration": "DefaultSegmentDeliveryConfiguration",
		"header_name":                            "HeaderName",
		"http_configuration":                     "HttpConfiguration",
		"key":                                    "Key",
		"name":                                   "Name",
		"secret_arn":                             "SecretArn",
		"secret_string_key":                      "SecretStringKey",
		"secrets_manager_access_token_configuration": "SecretsManagerAccessTokenConfiguration",
		"segment_delivery_configurations":            "SegmentDeliveryConfigurations",
		"source_location_name":                       "SourceLocationName",
		"tags":                                       "Tags",
		"value":                                      "Value",
	})

	opts = opts.WithCreateTimeoutInMinutes(0).WithDeleteTimeoutInMinutes(0)

	opts = opts.WithUpdateTimeoutInMinutes(0)

	v, err := generic.NewResource(ctx, opts...)

	if err != nil {
		return nil, err
	}

	return v, nil
}
