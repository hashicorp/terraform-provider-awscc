// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// Code generated by generators/resource/main.go; DO NOT EDIT.

package codepipeline

import (
	"context"
	"regexp"

	"github.com/hashicorp/terraform-plugin-framework-jsontypes/jsontypes"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-provider-awscc/internal/generic"
	"github.com/hashicorp/terraform-provider-awscc/internal/registry"
	fwvalidators "github.com/hashicorp/terraform-provider-awscc/internal/validators"
)

func init() {
	registry.AddResourceFactory("awscc_codepipeline_pipeline", pipelineResource)
}

// pipelineResource returns the Terraform awscc_codepipeline_pipeline resource.
// This Terraform resource corresponds to the CloudFormation AWS::CodePipeline::Pipeline resource.
func pipelineResource(ctx context.Context) (resource.Resource, error) {
	attributes := map[string]schema.Attribute{ /*START SCHEMA*/
		// Property: ArtifactStore
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "The S3 bucket where artifacts for the pipeline are stored.",
		//	  "properties": {
		//	    "EncryptionKey": {
		//	      "additionalProperties": false,
		//	      "description": "Represents information about the key used to encrypt data in the artifact store, such as an AWS Key Management Service (AWS KMS) key",
		//	      "properties": {
		//	        "Id": {
		//	          "description": "The ID used to identify the key. For an AWS KMS key, you can use the key ID, the key ARN, or the alias ARN.",
		//	          "type": "string"
		//	        },
		//	        "Type": {
		//	          "description": "The type of encryption key, such as an AWS KMS key. When creating or updating a pipeline, the value must be set to 'KMS'.",
		//	          "type": "string"
		//	        }
		//	      },
		//	      "required": [
		//	        "Type",
		//	        "Id"
		//	      ],
		//	      "type": "object"
		//	    },
		//	    "Location": {
		//	      "description": "The S3 bucket used for storing the artifacts for a pipeline. You can specify the name of an S3 bucket but not a folder in the bucket. A folder to contain the pipeline artifacts is created for you based on the name of the pipeline. You can use any S3 bucket in the same AWS Region as the pipeline to store your pipeline artifacts.",
		//	      "type": "string"
		//	    },
		//	    "Type": {
		//	      "description": "The type of the artifact store, such as S3.",
		//	      "enum": [
		//	        "S3"
		//	      ],
		//	      "type": "string"
		//	    }
		//	  },
		//	  "required": [
		//	    "Type",
		//	    "Location"
		//	  ],
		//	  "type": "object"
		//	}
		"artifact_store": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: EncryptionKey
				"encryption_key": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
					Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
						// Property: Id
						"id": schema.StringAttribute{ /*START ATTRIBUTE*/
							Description: "The ID used to identify the key. For an AWS KMS key, you can use the key ID, the key ARN, or the alias ARN.",
							Optional:    true,
							Computed:    true,
							Validators: []validator.String{ /*START VALIDATORS*/
								fwvalidators.NotNullString(),
							}, /*END VALIDATORS*/
							PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
								stringplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
						// Property: Type
						"type": schema.StringAttribute{ /*START ATTRIBUTE*/
							Description: "The type of encryption key, such as an AWS KMS key. When creating or updating a pipeline, the value must be set to 'KMS'.",
							Optional:    true,
							Computed:    true,
							Validators: []validator.String{ /*START VALIDATORS*/
								fwvalidators.NotNullString(),
							}, /*END VALIDATORS*/
							PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
								stringplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
					}, /*END SCHEMA*/
					Description: "Represents information about the key used to encrypt data in the artifact store, such as an AWS Key Management Service (AWS KMS) key",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
						objectplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: Location
				"location": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "The S3 bucket used for storing the artifacts for a pipeline. You can specify the name of an S3 bucket but not a folder in the bucket. A folder to contain the pipeline artifacts is created for you based on the name of the pipeline. You can use any S3 bucket in the same AWS Region as the pipeline to store your pipeline artifacts.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.String{ /*START VALIDATORS*/
						fwvalidators.NotNullString(),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: Type
				"type": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "The type of the artifact store, such as S3.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.String{ /*START VALIDATORS*/
						stringvalidator.OneOf(
							"S3",
						),
						fwvalidators.NotNullString(),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "The S3 bucket where artifacts for the pipeline are stored.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: ArtifactStores
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A mapping of artifactStore objects and their corresponding AWS Regions. There must be an artifact store for the pipeline Region and for each cross-region action in the pipeline.",
		//	  "items": {
		//	    "additionalProperties": false,
		//	    "description": "A mapping of artifactStore objects and their corresponding AWS Regions. There must be an artifact store for the pipeline Region and for each cross-region action in the pipeline.",
		//	    "properties": {
		//	      "ArtifactStore": {
		//	        "additionalProperties": false,
		//	        "description": "The S3 bucket where artifacts for the pipeline are stored.",
		//	        "properties": {
		//	          "EncryptionKey": {
		//	            "additionalProperties": false,
		//	            "description": "Represents information about the key used to encrypt data in the artifact store, such as an AWS Key Management Service (AWS KMS) key",
		//	            "properties": {
		//	              "Id": {
		//	                "description": "The ID used to identify the key. For an AWS KMS key, you can use the key ID, the key ARN, or the alias ARN.",
		//	                "type": "string"
		//	              },
		//	              "Type": {
		//	                "description": "The type of encryption key, such as an AWS KMS key. When creating or updating a pipeline, the value must be set to 'KMS'.",
		//	                "type": "string"
		//	              }
		//	            },
		//	            "required": [
		//	              "Type",
		//	              "Id"
		//	            ],
		//	            "type": "object"
		//	          },
		//	          "Location": {
		//	            "description": "The S3 bucket used for storing the artifacts for a pipeline. You can specify the name of an S3 bucket but not a folder in the bucket. A folder to contain the pipeline artifacts is created for you based on the name of the pipeline. You can use any S3 bucket in the same AWS Region as the pipeline to store your pipeline artifacts.",
		//	            "type": "string"
		//	          },
		//	          "Type": {
		//	            "description": "The type of the artifact store, such as S3.",
		//	            "enum": [
		//	              "S3"
		//	            ],
		//	            "type": "string"
		//	          }
		//	        },
		//	        "required": [
		//	          "Type",
		//	          "Location"
		//	        ],
		//	        "type": "object"
		//	      },
		//	      "Region": {
		//	        "description": "The action declaration's AWS Region, such as us-east-1.",
		//	        "type": "string"
		//	      }
		//	    },
		//	    "required": [
		//	      "ArtifactStore",
		//	      "Region"
		//	    ],
		//	    "type": "object"
		//	  },
		//	  "type": "array",
		//	  "uniqueItems": true
		//	}
		"artifact_stores": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: ArtifactStore
					"artifact_store": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: EncryptionKey
							"encryption_key": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
								Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
									// Property: Id
									"id": schema.StringAttribute{ /*START ATTRIBUTE*/
										Description: "The ID used to identify the key. For an AWS KMS key, you can use the key ID, the key ARN, or the alias ARN.",
										Optional:    true,
										Computed:    true,
										Validators: []validator.String{ /*START VALIDATORS*/
											fwvalidators.NotNullString(),
										}, /*END VALIDATORS*/
										PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
											stringplanmodifier.UseStateForUnknown(),
										}, /*END PLAN MODIFIERS*/
									}, /*END ATTRIBUTE*/
									// Property: Type
									"type": schema.StringAttribute{ /*START ATTRIBUTE*/
										Description: "The type of encryption key, such as an AWS KMS key. When creating or updating a pipeline, the value must be set to 'KMS'.",
										Optional:    true,
										Computed:    true,
										Validators: []validator.String{ /*START VALIDATORS*/
											fwvalidators.NotNullString(),
										}, /*END VALIDATORS*/
										PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
											stringplanmodifier.UseStateForUnknown(),
										}, /*END PLAN MODIFIERS*/
									}, /*END ATTRIBUTE*/
								}, /*END SCHEMA*/
								Description: "Represents information about the key used to encrypt data in the artifact store, such as an AWS Key Management Service (AWS KMS) key",
								Optional:    true,
								Computed:    true,
								PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
									objectplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: Location
							"location": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "The S3 bucket used for storing the artifacts for a pipeline. You can specify the name of an S3 bucket but not a folder in the bucket. A folder to contain the pipeline artifacts is created for you based on the name of the pipeline. You can use any S3 bucket in the same AWS Region as the pipeline to store your pipeline artifacts.",
								Optional:    true,
								Computed:    true,
								Validators: []validator.String{ /*START VALIDATORS*/
									fwvalidators.NotNullString(),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
									stringplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: Type
							"type": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "The type of the artifact store, such as S3.",
								Optional:    true,
								Computed:    true,
								Validators: []validator.String{ /*START VALIDATORS*/
									stringvalidator.OneOf(
										"S3",
									),
									fwvalidators.NotNullString(),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
									stringplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
						Description: "The S3 bucket where artifacts for the pipeline are stored.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.Object{ /*START VALIDATORS*/
							fwvalidators.NotNullObject(),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
							objectplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: Region
					"region": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The action declaration's AWS Region, such as us-east-1.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							fwvalidators.NotNullString(),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Description: "A mapping of artifactStore objects and their corresponding AWS Regions. There must be an artifact store for the pipeline Region and for each cross-region action in the pipeline.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.List{ /*START VALIDATORS*/
				listvalidator.UniqueValues(),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
				listplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: DisableInboundStageTransitions
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "Represents the input of a DisableStageTransition action.",
		//	  "items": {
		//	    "additionalProperties": false,
		//	    "description": "The name of the pipeline in which you want to disable the flow of artifacts from one stage to another.",
		//	    "properties": {
		//	      "Reason": {
		//	        "description": "The reason given to the user that a stage is disabled, such as waiting for manual approval or manual tests. This message is displayed in the pipeline console UI.",
		//	        "type": "string"
		//	      },
		//	      "StageName": {
		//	        "description": "The name of the stage where you want to disable the inbound or outbound transition of artifacts.",
		//	        "type": "string"
		//	      }
		//	    },
		//	    "required": [
		//	      "StageName",
		//	      "Reason"
		//	    ],
		//	    "type": "object"
		//	  },
		//	  "type": "array",
		//	  "uniqueItems": true
		//	}
		"disable_inbound_stage_transitions": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: Reason
					"reason": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The reason given to the user that a stage is disabled, such as waiting for manual approval or manual tests. This message is displayed in the pipeline console UI.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							fwvalidators.NotNullString(),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: StageName
					"stage_name": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The name of the stage where you want to disable the inbound or outbound transition of artifacts.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							fwvalidators.NotNullString(),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Description: "Represents the input of a DisableStageTransition action.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.List{ /*START VALIDATORS*/
				listvalidator.UniqueValues(),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
				listplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: ExecutionMode
		// CloudFormation resource type schema:
		//
		//	{
		//	  "default": "SUPERSEDED",
		//	  "description": "The method that the pipeline will use to handle multiple executions. The default mode is SUPERSEDED.",
		//	  "enum": [
		//	    "QUEUED",
		//	    "SUPERSEDED",
		//	    "PARALLEL"
		//	  ],
		//	  "type": "string"
		//	}
		"execution_mode": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The method that the pipeline will use to handle multiple executions. The default mode is SUPERSEDED.",
			Optional:    true,
			Computed:    true,
			Default:     stringdefault.StaticString("SUPERSEDED"),
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.OneOf(
					"QUEUED",
					"SUPERSEDED",
					"PARALLEL",
				),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Name
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The name of the pipeline.",
		//	  "type": "string"
		//	}
		"name": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The name of the pipeline.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
				stringplanmodifier.RequiresReplaceIfConfigured(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: PipelineType
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "CodePipeline provides the following pipeline types, which differ in characteristics and price, so that you can tailor your pipeline features and cost to the needs of your applications.",
		//	  "enum": [
		//	    "V1",
		//	    "V2"
		//	  ],
		//	  "type": "string"
		//	}
		"pipeline_type": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "CodePipeline provides the following pipeline types, which differ in characteristics and price, so that you can tailor your pipeline features and cost to the needs of your applications.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.OneOf(
					"V1",
					"V2",
				),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: RestartExecutionOnUpdate
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "Indicates whether to rerun the CodePipeline pipeline after you update it.",
		//	  "type": "boolean"
		//	}
		"restart_execution_on_update": schema.BoolAttribute{ /*START ATTRIBUTE*/
			Description: "Indicates whether to rerun the CodePipeline pipeline after you update it.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Bool{ /*START PLAN MODIFIERS*/
				boolplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
			// RestartExecutionOnUpdate is a write-only property.
		}, /*END ATTRIBUTE*/
		// Property: RoleArn
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The Amazon Resource Name (ARN) for CodePipeline to use to either perform actions with no actionRoleArn, or to use to assume roles for actions with an actionRoleArn",
		//	  "pattern": "arn:aws(-[\\w]+)*:iam::[0-9]{12}:role/.*",
		//	  "type": "string"
		//	}
		"role_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The Amazon Resource Name (ARN) for CodePipeline to use to either perform actions with no actionRoleArn, or to use to assume roles for actions with an actionRoleArn",
			Required:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.RegexMatches(regexp.MustCompile("arn:aws(-[\\w]+)*:iam::[0-9]{12}:role/.*"), ""),
			}, /*END VALIDATORS*/
		}, /*END ATTRIBUTE*/
		// Property: Stages
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "Represents information about a stage and its definition.",
		//	  "items": {
		//	    "additionalProperties": false,
		//	    "description": "Represents information about a stage and its definition.",
		//	    "properties": {
		//	      "Actions": {
		//	        "items": {
		//	          "additionalProperties": false,
		//	          "description": "Represents information about an action declaration.",
		//	          "properties": {
		//	            "ActionTypeId": {
		//	              "additionalProperties": false,
		//	              "description": "Represents information about an action type.",
		//	              "properties": {
		//	                "Category": {
		//	                  "description": "A category defines what kind of action can be taken in the stage, and constrains the provider type for the action. Valid categories are limited to one of the values below.",
		//	                  "enum": [
		//	                    "Source",
		//	                    "Build",
		//	                    "Test",
		//	                    "Deploy",
		//	                    "Invoke",
		//	                    "Approval",
		//	                    "Compute"
		//	                  ],
		//	                  "type": "string"
		//	                },
		//	                "Owner": {
		//	                  "description": "The creator of the action being called. There are three valid values for the Owner field in the action category section within your pipeline structure: AWS, ThirdParty, and Custom.",
		//	                  "type": "string"
		//	                },
		//	                "Provider": {
		//	                  "description": "The provider of the service being called by the action. Valid providers are determined by the action category. For example, an action in the Deploy category type might have a provider of CodeDeploy, which would be specified as CodeDeploy.",
		//	                  "type": "string"
		//	                },
		//	                "Version": {
		//	                  "description": "A string that describes the action version.",
		//	                  "type": "string"
		//	                }
		//	              },
		//	              "required": [
		//	                "Owner",
		//	                "Category",
		//	                "Version",
		//	                "Provider"
		//	              ],
		//	              "type": "object"
		//	            },
		//	            "Commands": {
		//	              "description": "The shell commands to run with your compute action in CodePipeline.",
		//	              "items": {
		//	                "type": "string"
		//	              },
		//	              "type": "array",
		//	              "uniqueItems": false
		//	            },
		//	            "Configuration": {
		//	              "description": "The action's configuration. These are key-value pairs that specify input values for an action.",
		//	              "type": "object"
		//	            },
		//	            "EnvironmentVariables": {
		//	              "description": "The list of environment variables that are input to a compute based action.",
		//	              "items": {
		//	                "additionalProperties": false,
		//	                "description": "Represents information about the environment variable of an action.",
		//	                "properties": {
		//	                  "Name": {
		//	                    "description": "The name of the environment variable.",
		//	                    "type": "string"
		//	                  },
		//	                  "Value": {
		//	                    "description": "The value of the environment variable.",
		//	                    "type": "string"
		//	                  }
		//	                },
		//	                "required": [
		//	                  "Name",
		//	                  "Value"
		//	                ],
		//	                "type": "object"
		//	              },
		//	              "type": "array",
		//	              "uniqueItems": true
		//	            },
		//	            "InputArtifacts": {
		//	              "items": {
		//	                "additionalProperties": false,
		//	                "description": "Represents information about an artifact to be worked on, such as a test or build artifact.",
		//	                "properties": {
		//	                  "Name": {
		//	                    "description": "The name of the artifact to be worked on (for example, \"My App\").",
		//	                    "type": "string"
		//	                  }
		//	                },
		//	                "required": [
		//	                  "Name"
		//	                ],
		//	                "type": "object"
		//	              },
		//	              "type": "array",
		//	              "uniqueItems": true
		//	            },
		//	            "Name": {
		//	              "description": "The action declaration's name.",
		//	              "type": "string"
		//	            },
		//	            "Namespace": {
		//	              "description": "The variable namespace associated with the action. All variables produced as output by this action fall under this namespace.",
		//	              "type": "string"
		//	            },
		//	            "OutputArtifacts": {
		//	              "items": {
		//	                "additionalProperties": false,
		//	                "description": "Represents information about the output of an action.",
		//	                "properties": {
		//	                  "Files": {
		//	                    "description": "The files that you want to associate with the output artifact that will be exported from the compute action.",
		//	                    "items": {
		//	                      "type": "string"
		//	                    },
		//	                    "type": "array",
		//	                    "uniqueItems": true
		//	                  },
		//	                  "Name": {
		//	                    "description": "The name of the output of an artifact, such as \"My App\".",
		//	                    "type": "string"
		//	                  }
		//	                },
		//	                "required": [
		//	                  "Name"
		//	                ],
		//	                "type": "object"
		//	              },
		//	              "type": "array",
		//	              "uniqueItems": true
		//	            },
		//	            "OutputVariables": {
		//	              "description": "The list of variables that are to be exported from the compute action.",
		//	              "items": {
		//	                "type": "string"
		//	              },
		//	              "type": "array",
		//	              "uniqueItems": true
		//	            },
		//	            "Region": {
		//	              "description": "The action declaration's AWS Region, such as us-east-1.",
		//	              "type": "string"
		//	            },
		//	            "RoleArn": {
		//	              "description": "The ARN of the IAM service role that performs the declared action. This is assumed through the roleArn for the pipeline.",
		//	              "pattern": "arn:aws(-[\\w]+)*:iam::[0-9]{12}:role/.*",
		//	              "type": "string"
		//	            },
		//	            "RunOrder": {
		//	              "description": "The order in which actions are run.",
		//	              "type": "integer"
		//	            },
		//	            "TimeoutInMinutes": {
		//	              "description": "A timeout duration in minutes that can be applied against the ActionType?s default timeout value specified in Quotas for AWS CodePipeline. This attribute is available only to the manual approval ActionType.",
		//	              "type": "integer"
		//	            }
		//	          },
		//	          "required": [
		//	            "ActionTypeId",
		//	            "Name"
		//	          ],
		//	          "type": "object"
		//	        },
		//	        "type": "array",
		//	        "uniqueItems": true
		//	      },
		//	      "BeforeEntry": {
		//	        "additionalProperties": false,
		//	        "description": "The method to use before stage runs.",
		//	        "properties": {
		//	          "Conditions": {
		//	            "items": {
		//	              "additionalProperties": false,
		//	              "description": "Represents information about condition.",
		//	              "properties": {
		//	                "Result": {
		//	                  "description": "The specified result for when the failure conditions are met, such as rolling back the stage",
		//	                  "type": "string"
		//	                },
		//	                "Rules": {
		//	                  "items": {
		//	                    "additionalProperties": false,
		//	                    "description": "Represents information about condition.",
		//	                    "properties": {
		//	                      "Commands": {
		//	                        "description": "The shell commands to run with your compute action in CodePipeline.",
		//	                        "items": {
		//	                          "type": "string"
		//	                        },
		//	                        "type": "array",
		//	                        "uniqueItems": false
		//	                      },
		//	                      "Configuration": {
		//	                        "description": "The rule's configuration. These are key-value pairs that specify input values for a rule.",
		//	                        "type": "object"
		//	                      },
		//	                      "InputArtifacts": {
		//	                        "items": {
		//	                          "additionalProperties": false,
		//	                          "description": "Represents information about an artifact to be worked on, such as a test or build artifact.",
		//	                          "properties": {
		//	                            "Name": {
		//	                              "description": "The name of the artifact to be worked on (for example, \"My App\").",
		//	                              "type": "string"
		//	                            }
		//	                          },
		//	                          "required": [
		//	                            "Name"
		//	                          ],
		//	                          "type": "object"
		//	                        },
		//	                        "type": "array",
		//	                        "uniqueItems": true
		//	                      },
		//	                      "Name": {
		//	                        "description": "The rule declaration's name.",
		//	                        "type": "string"
		//	                      },
		//	                      "Region": {
		//	                        "description": "The rule declaration's AWS Region, such as us-east-1.",
		//	                        "type": "string"
		//	                      },
		//	                      "RoleArn": {
		//	                        "description": "The ARN of the IAM service role that performs the declared rule. This is assumed through the roleArn for the pipeline.",
		//	                        "pattern": "arn:aws(-[\\w]+)*:iam::[0-9]{12}:role/.*",
		//	                        "type": "string"
		//	                      },
		//	                      "RuleTypeId": {
		//	                        "additionalProperties": false,
		//	                        "description": "Represents information about a rule type.",
		//	                        "properties": {
		//	                          "Category": {
		//	                            "description": "A category for the provider type for the rule.",
		//	                            "type": "string"
		//	                          },
		//	                          "Owner": {
		//	                            "description": "The creator of the rule being called. Only AWS is supported.",
		//	                            "type": "string"
		//	                          },
		//	                          "Provider": {
		//	                            "description": "The provider of the service being called by the rule.",
		//	                            "type": "string"
		//	                          },
		//	                          "Version": {
		//	                            "description": "A string that describes the rule version.",
		//	                            "type": "string"
		//	                          }
		//	                        },
		//	                        "type": "object"
		//	                      }
		//	                    },
		//	                    "type": "object"
		//	                  },
		//	                  "type": "array",
		//	                  "uniqueItems": true
		//	                }
		//	              },
		//	              "type": "object"
		//	            },
		//	            "type": "array",
		//	            "uniqueItems": true
		//	          }
		//	        },
		//	        "type": "object"
		//	      },
		//	      "Blockers": {
		//	        "items": {
		//	          "additionalProperties": false,
		//	          "description": "Reserved for future use.",
		//	          "properties": {
		//	            "Name": {
		//	              "description": "Reserved for future use.",
		//	              "type": "string"
		//	            },
		//	            "Type": {
		//	              "description": "Reserved for future use.",
		//	              "enum": [
		//	                "Schedule"
		//	              ],
		//	              "type": "string"
		//	            }
		//	          },
		//	          "required": [
		//	            "Type",
		//	            "Name"
		//	          ],
		//	          "type": "object"
		//	        },
		//	        "type": "array",
		//	        "uniqueItems": true
		//	      },
		//	      "Name": {
		//	        "description": "The name of the stage.",
		//	        "type": "string"
		//	      },
		//	      "OnFailure": {
		//	        "additionalProperties": false,
		//	        "description": "The method to use when a stage has not completed successfully",
		//	        "properties": {
		//	          "Conditions": {
		//	            "items": {
		//	              "additionalProperties": false,
		//	              "description": "Represents information about condition.",
		//	              "properties": {
		//	                "Result": {
		//	                  "description": "The specified result for when the failure conditions are met, such as rolling back the stage",
		//	                  "type": "string"
		//	                },
		//	                "Rules": {
		//	                  "items": {
		//	                    "additionalProperties": false,
		//	                    "description": "Represents information about condition.",
		//	                    "properties": {
		//	                      "Commands": {
		//	                        "description": "The shell commands to run with your compute action in CodePipeline.",
		//	                        "items": {
		//	                          "type": "string"
		//	                        },
		//	                        "type": "array",
		//	                        "uniqueItems": false
		//	                      },
		//	                      "Configuration": {
		//	                        "description": "The rule's configuration. These are key-value pairs that specify input values for a rule.",
		//	                        "type": "object"
		//	                      },
		//	                      "InputArtifacts": {
		//	                        "items": {
		//	                          "additionalProperties": false,
		//	                          "description": "Represents information about an artifact to be worked on, such as a test or build artifact.",
		//	                          "properties": {
		//	                            "Name": {
		//	                              "description": "The name of the artifact to be worked on (for example, \"My App\").",
		//	                              "type": "string"
		//	                            }
		//	                          },
		//	                          "required": [
		//	                            "Name"
		//	                          ],
		//	                          "type": "object"
		//	                        },
		//	                        "type": "array",
		//	                        "uniqueItems": true
		//	                      },
		//	                      "Name": {
		//	                        "description": "The rule declaration's name.",
		//	                        "type": "string"
		//	                      },
		//	                      "Region": {
		//	                        "description": "The rule declaration's AWS Region, such as us-east-1.",
		//	                        "type": "string"
		//	                      },
		//	                      "RoleArn": {
		//	                        "description": "The ARN of the IAM service role that performs the declared rule. This is assumed through the roleArn for the pipeline.",
		//	                        "pattern": "arn:aws(-[\\w]+)*:iam::[0-9]{12}:role/.*",
		//	                        "type": "string"
		//	                      },
		//	                      "RuleTypeId": {
		//	                        "additionalProperties": false,
		//	                        "description": "Represents information about a rule type.",
		//	                        "properties": {
		//	                          "Category": {
		//	                            "description": "A category for the provider type for the rule.",
		//	                            "type": "string"
		//	                          },
		//	                          "Owner": {
		//	                            "description": "The creator of the rule being called. Only AWS is supported.",
		//	                            "type": "string"
		//	                          },
		//	                          "Provider": {
		//	                            "description": "The provider of the service being called by the rule.",
		//	                            "type": "string"
		//	                          },
		//	                          "Version": {
		//	                            "description": "A string that describes the rule version.",
		//	                            "type": "string"
		//	                          }
		//	                        },
		//	                        "type": "object"
		//	                      }
		//	                    },
		//	                    "type": "object"
		//	                  },
		//	                  "type": "array",
		//	                  "uniqueItems": true
		//	                }
		//	              },
		//	              "type": "object"
		//	            },
		//	            "type": "array",
		//	            "uniqueItems": true
		//	          },
		//	          "Result": {
		//	            "description": "The specified result for when the failure conditions are met, such as rolling back the stage",
		//	            "enum": [
		//	              "ROLLBACK",
		//	              "RETRY"
		//	            ],
		//	            "type": "string"
		//	          },
		//	          "RetryConfiguration": {
		//	            "additionalProperties": false,
		//	            "description": "The configuration that specifies the retry configuration for a stage",
		//	            "properties": {
		//	              "RetryMode": {
		//	                "description": "The specified retry mode type for the given stage. FAILED_ACTIONS will retry only the failed actions. ALL_ACTIONS will retry both failed and successful",
		//	                "enum": [
		//	                  "ALL_ACTIONS",
		//	                  "FAILED_ACTIONS"
		//	                ],
		//	                "type": "string"
		//	              }
		//	            },
		//	            "type": "object"
		//	          }
		//	        },
		//	        "type": "object"
		//	      },
		//	      "OnSuccess": {
		//	        "additionalProperties": false,
		//	        "description": "The method to use when a stage has completed successfully",
		//	        "properties": {
		//	          "Conditions": {
		//	            "items": {
		//	              "additionalProperties": false,
		//	              "description": "Represents information about condition.",
		//	              "properties": {
		//	                "Result": {
		//	                  "description": "The specified result for when the failure conditions are met, such as rolling back the stage",
		//	                  "type": "string"
		//	                },
		//	                "Rules": {
		//	                  "items": {
		//	                    "additionalProperties": false,
		//	                    "description": "Represents information about condition.",
		//	                    "properties": {
		//	                      "Commands": {
		//	                        "description": "The shell commands to run with your compute action in CodePipeline.",
		//	                        "items": {
		//	                          "type": "string"
		//	                        },
		//	                        "type": "array",
		//	                        "uniqueItems": false
		//	                      },
		//	                      "Configuration": {
		//	                        "description": "The rule's configuration. These are key-value pairs that specify input values for a rule.",
		//	                        "type": "object"
		//	                      },
		//	                      "InputArtifacts": {
		//	                        "items": {
		//	                          "additionalProperties": false,
		//	                          "description": "Represents information about an artifact to be worked on, such as a test or build artifact.",
		//	                          "properties": {
		//	                            "Name": {
		//	                              "description": "The name of the artifact to be worked on (for example, \"My App\").",
		//	                              "type": "string"
		//	                            }
		//	                          },
		//	                          "required": [
		//	                            "Name"
		//	                          ],
		//	                          "type": "object"
		//	                        },
		//	                        "type": "array",
		//	                        "uniqueItems": true
		//	                      },
		//	                      "Name": {
		//	                        "description": "The rule declaration's name.",
		//	                        "type": "string"
		//	                      },
		//	                      "Region": {
		//	                        "description": "The rule declaration's AWS Region, such as us-east-1.",
		//	                        "type": "string"
		//	                      },
		//	                      "RoleArn": {
		//	                        "description": "The ARN of the IAM service role that performs the declared rule. This is assumed through the roleArn for the pipeline.",
		//	                        "pattern": "arn:aws(-[\\w]+)*:iam::[0-9]{12}:role/.*",
		//	                        "type": "string"
		//	                      },
		//	                      "RuleTypeId": {
		//	                        "additionalProperties": false,
		//	                        "description": "Represents information about a rule type.",
		//	                        "properties": {
		//	                          "Category": {
		//	                            "description": "A category for the provider type for the rule.",
		//	                            "type": "string"
		//	                          },
		//	                          "Owner": {
		//	                            "description": "The creator of the rule being called. Only AWS is supported.",
		//	                            "type": "string"
		//	                          },
		//	                          "Provider": {
		//	                            "description": "The provider of the service being called by the rule.",
		//	                            "type": "string"
		//	                          },
		//	                          "Version": {
		//	                            "description": "A string that describes the rule version.",
		//	                            "type": "string"
		//	                          }
		//	                        },
		//	                        "type": "object"
		//	                      }
		//	                    },
		//	                    "type": "object"
		//	                  },
		//	                  "type": "array",
		//	                  "uniqueItems": true
		//	                }
		//	              },
		//	              "type": "object"
		//	            },
		//	            "type": "array",
		//	            "uniqueItems": true
		//	          }
		//	        },
		//	        "type": "object"
		//	      }
		//	    },
		//	    "required": [
		//	      "Actions",
		//	      "Name"
		//	    ],
		//	    "type": "object"
		//	  },
		//	  "type": "array",
		//	  "uniqueItems": true
		//	}
		"stages": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: Actions
					"actions": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
						NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: ActionTypeId
								"action_type_id": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
									Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
										// Property: Category
										"category": schema.StringAttribute{ /*START ATTRIBUTE*/
											Description: "A category defines what kind of action can be taken in the stage, and constrains the provider type for the action. Valid categories are limited to one of the values below.",
											Required:    true,
											Validators: []validator.String{ /*START VALIDATORS*/
												stringvalidator.OneOf(
													"Source",
													"Build",
													"Test",
													"Deploy",
													"Invoke",
													"Approval",
													"Compute",
												),
											}, /*END VALIDATORS*/
										}, /*END ATTRIBUTE*/
										// Property: Owner
										"owner": schema.StringAttribute{ /*START ATTRIBUTE*/
											Description: "The creator of the action being called. There are three valid values for the Owner field in the action category section within your pipeline structure: AWS, ThirdParty, and Custom.",
											Required:    true,
										}, /*END ATTRIBUTE*/
										// Property: Provider
										"provider": schema.StringAttribute{ /*START ATTRIBUTE*/
											Description: "The provider of the service being called by the action. Valid providers are determined by the action category. For example, an action in the Deploy category type might have a provider of CodeDeploy, which would be specified as CodeDeploy.",
											Required:    true,
										}, /*END ATTRIBUTE*/
										// Property: Version
										"version": schema.StringAttribute{ /*START ATTRIBUTE*/
											Description: "A string that describes the action version.",
											Required:    true,
										}, /*END ATTRIBUTE*/
									}, /*END SCHEMA*/
									Description: "Represents information about an action type.",
									Required:    true,
								}, /*END ATTRIBUTE*/
								// Property: Commands
								"commands": schema.ListAttribute{ /*START ATTRIBUTE*/
									ElementType: types.StringType,
									Description: "The shell commands to run with your compute action in CodePipeline.",
									Optional:    true,
									Computed:    true,
									PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
										listplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: Configuration
								"configuration": schema.StringAttribute{ /*START ATTRIBUTE*/
									CustomType:  jsontypes.NormalizedType{},
									Description: "The action's configuration. These are key-value pairs that specify input values for an action.",
									Optional:    true,
									Computed:    true,
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: EnvironmentVariables
								"environment_variables": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
									NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
										Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
											// Property: Name
											"name": schema.StringAttribute{ /*START ATTRIBUTE*/
												Description: "The name of the environment variable.",
												Optional:    true,
												Computed:    true,
												Validators: []validator.String{ /*START VALIDATORS*/
													fwvalidators.NotNullString(),
												}, /*END VALIDATORS*/
												PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
													stringplanmodifier.UseStateForUnknown(),
												}, /*END PLAN MODIFIERS*/
											}, /*END ATTRIBUTE*/
											// Property: Value
											"value": schema.StringAttribute{ /*START ATTRIBUTE*/
												Description: "The value of the environment variable.",
												Optional:    true,
												Computed:    true,
												Validators: []validator.String{ /*START VALIDATORS*/
													fwvalidators.NotNullString(),
												}, /*END VALIDATORS*/
												PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
													stringplanmodifier.UseStateForUnknown(),
												}, /*END PLAN MODIFIERS*/
											}, /*END ATTRIBUTE*/
										}, /*END SCHEMA*/
									}, /*END NESTED OBJECT*/
									Description: "The list of environment variables that are input to a compute based action.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.List{ /*START VALIDATORS*/
										listvalidator.UniqueValues(),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
										listplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: InputArtifacts
								"input_artifacts": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
									NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
										Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
											// Property: Name
											"name": schema.StringAttribute{ /*START ATTRIBUTE*/
												Description: "The name of the artifact to be worked on (for example, \"My App\").",
												Optional:    true,
												Computed:    true,
												Validators: []validator.String{ /*START VALIDATORS*/
													fwvalidators.NotNullString(),
												}, /*END VALIDATORS*/
												PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
													stringplanmodifier.UseStateForUnknown(),
												}, /*END PLAN MODIFIERS*/
											}, /*END ATTRIBUTE*/
										}, /*END SCHEMA*/
									}, /*END NESTED OBJECT*/
									Optional: true,
									Computed: true,
									Validators: []validator.List{ /*START VALIDATORS*/
										listvalidator.UniqueValues(),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
										listplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: Name
								"name": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The action declaration's name.",
									Required:    true,
								}, /*END ATTRIBUTE*/
								// Property: Namespace
								"namespace": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The variable namespace associated with the action. All variables produced as output by this action fall under this namespace.",
									Optional:    true,
									Computed:    true,
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: OutputArtifacts
								"output_artifacts": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
									NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
										Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
											// Property: Files
											"files": schema.ListAttribute{ /*START ATTRIBUTE*/
												ElementType: types.StringType,
												Description: "The files that you want to associate with the output artifact that will be exported from the compute action.",
												Optional:    true,
												Computed:    true,
												Validators: []validator.List{ /*START VALIDATORS*/
													listvalidator.UniqueValues(),
												}, /*END VALIDATORS*/
												PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
													listplanmodifier.UseStateForUnknown(),
												}, /*END PLAN MODIFIERS*/
											}, /*END ATTRIBUTE*/
											// Property: Name
											"name": schema.StringAttribute{ /*START ATTRIBUTE*/
												Description: "The name of the output of an artifact, such as \"My App\".",
												Optional:    true,
												Computed:    true,
												Validators: []validator.String{ /*START VALIDATORS*/
													fwvalidators.NotNullString(),
												}, /*END VALIDATORS*/
												PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
													stringplanmodifier.UseStateForUnknown(),
												}, /*END PLAN MODIFIERS*/
											}, /*END ATTRIBUTE*/
										}, /*END SCHEMA*/
									}, /*END NESTED OBJECT*/
									Optional: true,
									Computed: true,
									Validators: []validator.List{ /*START VALIDATORS*/
										listvalidator.UniqueValues(),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
										listplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: OutputVariables
								"output_variables": schema.ListAttribute{ /*START ATTRIBUTE*/
									ElementType: types.StringType,
									Description: "The list of variables that are to be exported from the compute action.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.List{ /*START VALIDATORS*/
										listvalidator.UniqueValues(),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
										listplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: Region
								"region": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The action declaration's AWS Region, such as us-east-1.",
									Optional:    true,
									Computed:    true,
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: RoleArn
								"role_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "The ARN of the IAM service role that performs the declared action. This is assumed through the roleArn for the pipeline.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.RegexMatches(regexp.MustCompile("arn:aws(-[\\w]+)*:iam::[0-9]{12}:role/.*"), ""),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: RunOrder
								"run_order": schema.Int64Attribute{ /*START ATTRIBUTE*/
									Description: "The order in which actions are run.",
									Optional:    true,
									Computed:    true,
									PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
										int64planmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: TimeoutInMinutes
								"timeout_in_minutes": schema.Int64Attribute{ /*START ATTRIBUTE*/
									Description: "A timeout duration in minutes that can be applied against the ActionType?s default timeout value specified in Quotas for AWS CodePipeline. This attribute is available only to the manual approval ActionType.",
									Optional:    true,
									Computed:    true,
									PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
										int64planmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
						}, /*END NESTED OBJECT*/
						Required: true,
						Validators: []validator.List{ /*START VALIDATORS*/
							listvalidator.UniqueValues(),
						}, /*END VALIDATORS*/
					}, /*END ATTRIBUTE*/
					// Property: BeforeEntry
					"before_entry": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: Conditions
							"conditions": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
								NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
									Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
										// Property: Result
										"result": schema.StringAttribute{ /*START ATTRIBUTE*/
											Description: "The specified result for when the failure conditions are met, such as rolling back the stage",
											Optional:    true,
											Computed:    true,
											PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
												stringplanmodifier.UseStateForUnknown(),
											}, /*END PLAN MODIFIERS*/
										}, /*END ATTRIBUTE*/
										// Property: Rules
										"rules": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
											NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
												Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
													// Property: Commands
													"commands": schema.ListAttribute{ /*START ATTRIBUTE*/
														ElementType: types.StringType,
														Description: "The shell commands to run with your compute action in CodePipeline.",
														Optional:    true,
														Computed:    true,
														PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
															listplanmodifier.UseStateForUnknown(),
														}, /*END PLAN MODIFIERS*/
													}, /*END ATTRIBUTE*/
													// Property: Configuration
													"configuration": schema.StringAttribute{ /*START ATTRIBUTE*/
														CustomType:  jsontypes.NormalizedType{},
														Description: "The rule's configuration. These are key-value pairs that specify input values for a rule.",
														Optional:    true,
														Computed:    true,
														PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
															stringplanmodifier.UseStateForUnknown(),
														}, /*END PLAN MODIFIERS*/
													}, /*END ATTRIBUTE*/
													// Property: InputArtifacts
													"input_artifacts": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
														NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
															Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
																// Property: Name
																"name": schema.StringAttribute{ /*START ATTRIBUTE*/
																	Description: "The name of the artifact to be worked on (for example, \"My App\").",
																	Optional:    true,
																	Computed:    true,
																	Validators: []validator.String{ /*START VALIDATORS*/
																		fwvalidators.NotNullString(),
																	}, /*END VALIDATORS*/
																	PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
																		stringplanmodifier.UseStateForUnknown(),
																	}, /*END PLAN MODIFIERS*/
																}, /*END ATTRIBUTE*/
															}, /*END SCHEMA*/
														}, /*END NESTED OBJECT*/
														Optional: true,
														Computed: true,
														Validators: []validator.List{ /*START VALIDATORS*/
															listvalidator.UniqueValues(),
														}, /*END VALIDATORS*/
														PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
															listplanmodifier.UseStateForUnknown(),
														}, /*END PLAN MODIFIERS*/
													}, /*END ATTRIBUTE*/
													// Property: Name
													"name": schema.StringAttribute{ /*START ATTRIBUTE*/
														Description: "The rule declaration's name.",
														Optional:    true,
														Computed:    true,
														PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
															stringplanmodifier.UseStateForUnknown(),
														}, /*END PLAN MODIFIERS*/
													}, /*END ATTRIBUTE*/
													// Property: Region
													"region": schema.StringAttribute{ /*START ATTRIBUTE*/
														Description: "The rule declaration's AWS Region, such as us-east-1.",
														Optional:    true,
														Computed:    true,
														PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
															stringplanmodifier.UseStateForUnknown(),
														}, /*END PLAN MODIFIERS*/
													}, /*END ATTRIBUTE*/
													// Property: RoleArn
													"role_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
														Description: "The ARN of the IAM service role that performs the declared rule. This is assumed through the roleArn for the pipeline.",
														Optional:    true,
														Computed:    true,
														Validators: []validator.String{ /*START VALIDATORS*/
															stringvalidator.RegexMatches(regexp.MustCompile("arn:aws(-[\\w]+)*:iam::[0-9]{12}:role/.*"), ""),
														}, /*END VALIDATORS*/
														PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
															stringplanmodifier.UseStateForUnknown(),
														}, /*END PLAN MODIFIERS*/
													}, /*END ATTRIBUTE*/
													// Property: RuleTypeId
													"rule_type_id": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
														Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
															// Property: Category
															"category": schema.StringAttribute{ /*START ATTRIBUTE*/
																Description: "A category for the provider type for the rule.",
																Optional:    true,
																Computed:    true,
																PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
																	stringplanmodifier.UseStateForUnknown(),
																}, /*END PLAN MODIFIERS*/
															}, /*END ATTRIBUTE*/
															// Property: Owner
															"owner": schema.StringAttribute{ /*START ATTRIBUTE*/
																Description: "The creator of the rule being called. Only AWS is supported.",
																Optional:    true,
																Computed:    true,
																PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
																	stringplanmodifier.UseStateForUnknown(),
																}, /*END PLAN MODIFIERS*/
															}, /*END ATTRIBUTE*/
															// Property: Provider
															"provider": schema.StringAttribute{ /*START ATTRIBUTE*/
																Description: "The provider of the service being called by the rule.",
																Optional:    true,
																Computed:    true,
																PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
																	stringplanmodifier.UseStateForUnknown(),
																}, /*END PLAN MODIFIERS*/
															}, /*END ATTRIBUTE*/
															// Property: Version
															"version": schema.StringAttribute{ /*START ATTRIBUTE*/
																Description: "A string that describes the rule version.",
																Optional:    true,
																Computed:    true,
																PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
																	stringplanmodifier.UseStateForUnknown(),
																}, /*END PLAN MODIFIERS*/
															}, /*END ATTRIBUTE*/
														}, /*END SCHEMA*/
														Description: "Represents information about a rule type.",
														Optional:    true,
														Computed:    true,
														PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
															objectplanmodifier.UseStateForUnknown(),
														}, /*END PLAN MODIFIERS*/
													}, /*END ATTRIBUTE*/
												}, /*END SCHEMA*/
											}, /*END NESTED OBJECT*/
											Optional: true,
											Computed: true,
											Validators: []validator.List{ /*START VALIDATORS*/
												listvalidator.UniqueValues(),
											}, /*END VALIDATORS*/
											PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
												listplanmodifier.UseStateForUnknown(),
											}, /*END PLAN MODIFIERS*/
										}, /*END ATTRIBUTE*/
									}, /*END SCHEMA*/
								}, /*END NESTED OBJECT*/
								Optional: true,
								Computed: true,
								Validators: []validator.List{ /*START VALIDATORS*/
									listvalidator.UniqueValues(),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
									listplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
						Description: "The method to use before stage runs.",
						Optional:    true,
						Computed:    true,
						PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
							objectplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: Blockers
					"blockers": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
						NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: Name
								"name": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "Reserved for future use.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										fwvalidators.NotNullString(),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: Type
								"type": schema.StringAttribute{ /*START ATTRIBUTE*/
									Description: "Reserved for future use.",
									Optional:    true,
									Computed:    true,
									Validators: []validator.String{ /*START VALIDATORS*/
										stringvalidator.OneOf(
											"Schedule",
										),
										fwvalidators.NotNullString(),
									}, /*END VALIDATORS*/
									PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
										stringplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
						}, /*END NESTED OBJECT*/
						Optional: true,
						Computed: true,
						Validators: []validator.List{ /*START VALIDATORS*/
							listvalidator.UniqueValues(),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
							listplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: Name
					"name": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The name of the stage.",
						Required:    true,
					}, /*END ATTRIBUTE*/
					// Property: OnFailure
					"on_failure": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: Conditions
							"conditions": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
								NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
									Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
										// Property: Result
										"result": schema.StringAttribute{ /*START ATTRIBUTE*/
											Description: "The specified result for when the failure conditions are met, such as rolling back the stage",
											Optional:    true,
											Computed:    true,
											PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
												stringplanmodifier.UseStateForUnknown(),
											}, /*END PLAN MODIFIERS*/
										}, /*END ATTRIBUTE*/
										// Property: Rules
										"rules": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
											NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
												Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
													// Property: Commands
													"commands": schema.ListAttribute{ /*START ATTRIBUTE*/
														ElementType: types.StringType,
														Description: "The shell commands to run with your compute action in CodePipeline.",
														Optional:    true,
														Computed:    true,
														PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
															listplanmodifier.UseStateForUnknown(),
														}, /*END PLAN MODIFIERS*/
													}, /*END ATTRIBUTE*/
													// Property: Configuration
													"configuration": schema.StringAttribute{ /*START ATTRIBUTE*/
														CustomType:  jsontypes.NormalizedType{},
														Description: "The rule's configuration. These are key-value pairs that specify input values for a rule.",
														Optional:    true,
														Computed:    true,
														PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
															stringplanmodifier.UseStateForUnknown(),
														}, /*END PLAN MODIFIERS*/
													}, /*END ATTRIBUTE*/
													// Property: InputArtifacts
													"input_artifacts": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
														NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
															Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
																// Property: Name
																"name": schema.StringAttribute{ /*START ATTRIBUTE*/
																	Description: "The name of the artifact to be worked on (for example, \"My App\").",
																	Optional:    true,
																	Computed:    true,
																	Validators: []validator.String{ /*START VALIDATORS*/
																		fwvalidators.NotNullString(),
																	}, /*END VALIDATORS*/
																	PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
																		stringplanmodifier.UseStateForUnknown(),
																	}, /*END PLAN MODIFIERS*/
																}, /*END ATTRIBUTE*/
															}, /*END SCHEMA*/
														}, /*END NESTED OBJECT*/
														Optional: true,
														Computed: true,
														Validators: []validator.List{ /*START VALIDATORS*/
															listvalidator.UniqueValues(),
														}, /*END VALIDATORS*/
														PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
															listplanmodifier.UseStateForUnknown(),
														}, /*END PLAN MODIFIERS*/
													}, /*END ATTRIBUTE*/
													// Property: Name
													"name": schema.StringAttribute{ /*START ATTRIBUTE*/
														Description: "The rule declaration's name.",
														Optional:    true,
														Computed:    true,
														PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
															stringplanmodifier.UseStateForUnknown(),
														}, /*END PLAN MODIFIERS*/
													}, /*END ATTRIBUTE*/
													// Property: Region
													"region": schema.StringAttribute{ /*START ATTRIBUTE*/
														Description: "The rule declaration's AWS Region, such as us-east-1.",
														Optional:    true,
														Computed:    true,
														PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
															stringplanmodifier.UseStateForUnknown(),
														}, /*END PLAN MODIFIERS*/
													}, /*END ATTRIBUTE*/
													// Property: RoleArn
													"role_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
														Description: "The ARN of the IAM service role that performs the declared rule. This is assumed through the roleArn for the pipeline.",
														Optional:    true,
														Computed:    true,
														Validators: []validator.String{ /*START VALIDATORS*/
															stringvalidator.RegexMatches(regexp.MustCompile("arn:aws(-[\\w]+)*:iam::[0-9]{12}:role/.*"), ""),
														}, /*END VALIDATORS*/
														PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
															stringplanmodifier.UseStateForUnknown(),
														}, /*END PLAN MODIFIERS*/
													}, /*END ATTRIBUTE*/
													// Property: RuleTypeId
													"rule_type_id": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
														Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
															// Property: Category
															"category": schema.StringAttribute{ /*START ATTRIBUTE*/
																Description: "A category for the provider type for the rule.",
																Optional:    true,
																Computed:    true,
																PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
																	stringplanmodifier.UseStateForUnknown(),
																}, /*END PLAN MODIFIERS*/
															}, /*END ATTRIBUTE*/
															// Property: Owner
															"owner": schema.StringAttribute{ /*START ATTRIBUTE*/
																Description: "The creator of the rule being called. Only AWS is supported.",
																Optional:    true,
																Computed:    true,
																PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
																	stringplanmodifier.UseStateForUnknown(),
																}, /*END PLAN MODIFIERS*/
															}, /*END ATTRIBUTE*/
															// Property: Provider
															"provider": schema.StringAttribute{ /*START ATTRIBUTE*/
																Description: "The provider of the service being called by the rule.",
																Optional:    true,
																Computed:    true,
																PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
																	stringplanmodifier.UseStateForUnknown(),
																}, /*END PLAN MODIFIERS*/
															}, /*END ATTRIBUTE*/
															// Property: Version
															"version": schema.StringAttribute{ /*START ATTRIBUTE*/
																Description: "A string that describes the rule version.",
																Optional:    true,
																Computed:    true,
																PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
																	stringplanmodifier.UseStateForUnknown(),
																}, /*END PLAN MODIFIERS*/
															}, /*END ATTRIBUTE*/
														}, /*END SCHEMA*/
														Description: "Represents information about a rule type.",
														Optional:    true,
														Computed:    true,
														PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
															objectplanmodifier.UseStateForUnknown(),
														}, /*END PLAN MODIFIERS*/
													}, /*END ATTRIBUTE*/
												}, /*END SCHEMA*/
											}, /*END NESTED OBJECT*/
											Optional: true,
											Computed: true,
											Validators: []validator.List{ /*START VALIDATORS*/
												listvalidator.UniqueValues(),
											}, /*END VALIDATORS*/
											PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
												listplanmodifier.UseStateForUnknown(),
											}, /*END PLAN MODIFIERS*/
										}, /*END ATTRIBUTE*/
									}, /*END SCHEMA*/
								}, /*END NESTED OBJECT*/
								Optional: true,
								Computed: true,
								Validators: []validator.List{ /*START VALIDATORS*/
									listvalidator.UniqueValues(),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
									listplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: Result
							"result": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "The specified result for when the failure conditions are met, such as rolling back the stage",
								Optional:    true,
								Computed:    true,
								Validators: []validator.String{ /*START VALIDATORS*/
									stringvalidator.OneOf(
										"ROLLBACK",
										"RETRY",
									),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
									stringplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: RetryConfiguration
							"retry_configuration": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
								Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
									// Property: RetryMode
									"retry_mode": schema.StringAttribute{ /*START ATTRIBUTE*/
										Description: "The specified retry mode type for the given stage. FAILED_ACTIONS will retry only the failed actions. ALL_ACTIONS will retry both failed and successful",
										Optional:    true,
										Computed:    true,
										Validators: []validator.String{ /*START VALIDATORS*/
											stringvalidator.OneOf(
												"ALL_ACTIONS",
												"FAILED_ACTIONS",
											),
										}, /*END VALIDATORS*/
										PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
											stringplanmodifier.UseStateForUnknown(),
										}, /*END PLAN MODIFIERS*/
									}, /*END ATTRIBUTE*/
								}, /*END SCHEMA*/
								Description: "The configuration that specifies the retry configuration for a stage",
								Optional:    true,
								Computed:    true,
								PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
									objectplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
						Description: "The method to use when a stage has not completed successfully",
						Optional:    true,
						Computed:    true,
						PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
							objectplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: OnSuccess
					"on_success": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: Conditions
							"conditions": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
								NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
									Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
										// Property: Result
										"result": schema.StringAttribute{ /*START ATTRIBUTE*/
											Description: "The specified result for when the failure conditions are met, such as rolling back the stage",
											Optional:    true,
											Computed:    true,
											PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
												stringplanmodifier.UseStateForUnknown(),
											}, /*END PLAN MODIFIERS*/
										}, /*END ATTRIBUTE*/
										// Property: Rules
										"rules": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
											NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
												Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
													// Property: Commands
													"commands": schema.ListAttribute{ /*START ATTRIBUTE*/
														ElementType: types.StringType,
														Description: "The shell commands to run with your compute action in CodePipeline.",
														Optional:    true,
														Computed:    true,
														PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
															listplanmodifier.UseStateForUnknown(),
														}, /*END PLAN MODIFIERS*/
													}, /*END ATTRIBUTE*/
													// Property: Configuration
													"configuration": schema.StringAttribute{ /*START ATTRIBUTE*/
														CustomType:  jsontypes.NormalizedType{},
														Description: "The rule's configuration. These are key-value pairs that specify input values for a rule.",
														Optional:    true,
														Computed:    true,
														PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
															stringplanmodifier.UseStateForUnknown(),
														}, /*END PLAN MODIFIERS*/
													}, /*END ATTRIBUTE*/
													// Property: InputArtifacts
													"input_artifacts": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
														NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
															Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
																// Property: Name
																"name": schema.StringAttribute{ /*START ATTRIBUTE*/
																	Description: "The name of the artifact to be worked on (for example, \"My App\").",
																	Optional:    true,
																	Computed:    true,
																	Validators: []validator.String{ /*START VALIDATORS*/
																		fwvalidators.NotNullString(),
																	}, /*END VALIDATORS*/
																	PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
																		stringplanmodifier.UseStateForUnknown(),
																	}, /*END PLAN MODIFIERS*/
																}, /*END ATTRIBUTE*/
															}, /*END SCHEMA*/
														}, /*END NESTED OBJECT*/
														Optional: true,
														Computed: true,
														Validators: []validator.List{ /*START VALIDATORS*/
															listvalidator.UniqueValues(),
														}, /*END VALIDATORS*/
														PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
															listplanmodifier.UseStateForUnknown(),
														}, /*END PLAN MODIFIERS*/
													}, /*END ATTRIBUTE*/
													// Property: Name
													"name": schema.StringAttribute{ /*START ATTRIBUTE*/
														Description: "The rule declaration's name.",
														Optional:    true,
														Computed:    true,
														PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
															stringplanmodifier.UseStateForUnknown(),
														}, /*END PLAN MODIFIERS*/
													}, /*END ATTRIBUTE*/
													// Property: Region
													"region": schema.StringAttribute{ /*START ATTRIBUTE*/
														Description: "The rule declaration's AWS Region, such as us-east-1.",
														Optional:    true,
														Computed:    true,
														PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
															stringplanmodifier.UseStateForUnknown(),
														}, /*END PLAN MODIFIERS*/
													}, /*END ATTRIBUTE*/
													// Property: RoleArn
													"role_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
														Description: "The ARN of the IAM service role that performs the declared rule. This is assumed through the roleArn for the pipeline.",
														Optional:    true,
														Computed:    true,
														Validators: []validator.String{ /*START VALIDATORS*/
															stringvalidator.RegexMatches(regexp.MustCompile("arn:aws(-[\\w]+)*:iam::[0-9]{12}:role/.*"), ""),
														}, /*END VALIDATORS*/
														PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
															stringplanmodifier.UseStateForUnknown(),
														}, /*END PLAN MODIFIERS*/
													}, /*END ATTRIBUTE*/
													// Property: RuleTypeId
													"rule_type_id": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
														Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
															// Property: Category
															"category": schema.StringAttribute{ /*START ATTRIBUTE*/
																Description: "A category for the provider type for the rule.",
																Optional:    true,
																Computed:    true,
																PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
																	stringplanmodifier.UseStateForUnknown(),
																}, /*END PLAN MODIFIERS*/
															}, /*END ATTRIBUTE*/
															// Property: Owner
															"owner": schema.StringAttribute{ /*START ATTRIBUTE*/
																Description: "The creator of the rule being called. Only AWS is supported.",
																Optional:    true,
																Computed:    true,
																PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
																	stringplanmodifier.UseStateForUnknown(),
																}, /*END PLAN MODIFIERS*/
															}, /*END ATTRIBUTE*/
															// Property: Provider
															"provider": schema.StringAttribute{ /*START ATTRIBUTE*/
																Description: "The provider of the service being called by the rule.",
																Optional:    true,
																Computed:    true,
																PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
																	stringplanmodifier.UseStateForUnknown(),
																}, /*END PLAN MODIFIERS*/
															}, /*END ATTRIBUTE*/
															// Property: Version
															"version": schema.StringAttribute{ /*START ATTRIBUTE*/
																Description: "A string that describes the rule version.",
																Optional:    true,
																Computed:    true,
																PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
																	stringplanmodifier.UseStateForUnknown(),
																}, /*END PLAN MODIFIERS*/
															}, /*END ATTRIBUTE*/
														}, /*END SCHEMA*/
														Description: "Represents information about a rule type.",
														Optional:    true,
														Computed:    true,
														PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
															objectplanmodifier.UseStateForUnknown(),
														}, /*END PLAN MODIFIERS*/
													}, /*END ATTRIBUTE*/
												}, /*END SCHEMA*/
											}, /*END NESTED OBJECT*/
											Optional: true,
											Computed: true,
											Validators: []validator.List{ /*START VALIDATORS*/
												listvalidator.UniqueValues(),
											}, /*END VALIDATORS*/
											PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
												listplanmodifier.UseStateForUnknown(),
											}, /*END PLAN MODIFIERS*/
										}, /*END ATTRIBUTE*/
									}, /*END SCHEMA*/
								}, /*END NESTED OBJECT*/
								Optional: true,
								Computed: true,
								Validators: []validator.List{ /*START VALIDATORS*/
									listvalidator.UniqueValues(),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
									listplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
						Description: "The method to use when a stage has completed successfully",
						Optional:    true,
						Computed:    true,
						PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
							objectplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Description: "Represents information about a stage and its definition.",
			Required:    true,
			Validators: []validator.List{ /*START VALIDATORS*/
				listvalidator.UniqueValues(),
			}, /*END VALIDATORS*/
		}, /*END ATTRIBUTE*/
		// Property: Tags
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "Specifies the tags applied to the pipeline.",
		//	  "items": {
		//	    "additionalProperties": false,
		//	    "description": "A tag is a key-value pair that is used to manage the resource.",
		//	    "properties": {
		//	      "Key": {
		//	        "description": "The tag's key.",
		//	        "type": "string"
		//	      },
		//	      "Value": {
		//	        "description": "The tag's value.",
		//	        "type": "string"
		//	      }
		//	    },
		//	    "required": [
		//	      "Value",
		//	      "Key"
		//	    ],
		//	    "type": "object"
		//	  },
		//	  "type": "array",
		//	  "uniqueItems": false
		//	}
		"tags": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: Key
					"key": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The tag's key.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							fwvalidators.NotNullString(),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: Value
					"value": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The tag's value.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							fwvalidators.NotNullString(),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Description: "Specifies the tags applied to the pipeline.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
				listplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Triggers
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The trigger configuration specifying a type of event, such as Git tags, that starts the pipeline.",
		//	  "items": {
		//	    "additionalProperties": false,
		//	    "description": "Represents information about the specified trigger configuration, such as the filter criteria and the source stage for the action that contains the trigger.",
		//	    "properties": {
		//	      "GitConfiguration": {
		//	        "additionalProperties": false,
		//	        "description": "A type of trigger configuration for Git-based source actions.",
		//	        "properties": {
		//	          "PullRequest": {
		//	            "description": "The field where the repository event that will start the pipeline is specified as pull requests.",
		//	            "items": {
		//	              "additionalProperties": false,
		//	              "description": "The event criteria for the pull request trigger configuration, such as the lists of branches or file paths to include and exclude.",
		//	              "properties": {
		//	                "Branches": {
		//	                  "additionalProperties": false,
		//	                  "description": "The Git repository branches specified as filter criteria to start the pipeline.",
		//	                  "properties": {
		//	                    "Excludes": {
		//	                      "description": "The list of patterns of Git branches that, when a commit is pushed, are to be excluded from starting the pipeline.",
		//	                      "items": {
		//	                        "type": "string"
		//	                      },
		//	                      "type": "array",
		//	                      "uniqueItems": true
		//	                    },
		//	                    "Includes": {
		//	                      "description": "The list of patterns of Git branches that, when a commit is pushed, are to be included as criteria that starts the pipeline.",
		//	                      "items": {
		//	                        "type": "string"
		//	                      },
		//	                      "type": "array",
		//	                      "uniqueItems": true
		//	                    }
		//	                  },
		//	                  "type": "object"
		//	                },
		//	                "Events": {
		//	                  "description": "The field that specifies which pull request events to filter on (opened, updated, closed) for the trigger configuration.",
		//	                  "items": {
		//	                    "type": "string"
		//	                  },
		//	                  "type": "array",
		//	                  "uniqueItems": true
		//	                },
		//	                "FilePaths": {
		//	                  "additionalProperties": false,
		//	                  "description": "The Git repository file paths specified as filter criteria to start the pipeline.",
		//	                  "properties": {
		//	                    "Excludes": {
		//	                      "description": "The list of patterns of Git repository file paths that, when a commit is pushed, are to be excluded from starting the pipeline.",
		//	                      "items": {
		//	                        "type": "string"
		//	                      },
		//	                      "type": "array",
		//	                      "uniqueItems": true
		//	                    },
		//	                    "Includes": {
		//	                      "description": "The list of patterns of Git repository file paths that, when a commit is pushed, are to be included as criteria that starts the pipeline.",
		//	                      "items": {
		//	                        "type": "string"
		//	                      },
		//	                      "type": "array",
		//	                      "uniqueItems": true
		//	                    }
		//	                  },
		//	                  "type": "object"
		//	                }
		//	              },
		//	              "type": "object"
		//	            },
		//	            "type": "array",
		//	            "uniqueItems": true
		//	          },
		//	          "Push": {
		//	            "description": "The field where the repository event that will start the pipeline, such as pushing Git tags, is specified with details.",
		//	            "items": {
		//	              "additionalProperties": false,
		//	              "description": "The event criteria that specify when a specified repository event will start the pipeline for the specified trigger configuration, such as the lists of Git tags to include and exclude.",
		//	              "properties": {
		//	                "Branches": {
		//	                  "additionalProperties": false,
		//	                  "description": "The Git repository branches specified as filter criteria to start the pipeline.",
		//	                  "properties": {
		//	                    "Excludes": {
		//	                      "description": "The list of patterns of Git branches that, when a commit is pushed, are to be excluded from starting the pipeline.",
		//	                      "items": {
		//	                        "type": "string"
		//	                      },
		//	                      "type": "array",
		//	                      "uniqueItems": true
		//	                    },
		//	                    "Includes": {
		//	                      "description": "The list of patterns of Git branches that, when a commit is pushed, are to be included as criteria that starts the pipeline.",
		//	                      "items": {
		//	                        "type": "string"
		//	                      },
		//	                      "type": "array",
		//	                      "uniqueItems": true
		//	                    }
		//	                  },
		//	                  "type": "object"
		//	                },
		//	                "FilePaths": {
		//	                  "additionalProperties": false,
		//	                  "description": "The Git repository file paths specified as filter criteria to start the pipeline.",
		//	                  "properties": {
		//	                    "Excludes": {
		//	                      "description": "The list of patterns of Git repository file paths that, when a commit is pushed, are to be excluded from starting the pipeline.",
		//	                      "items": {
		//	                        "type": "string"
		//	                      },
		//	                      "type": "array",
		//	                      "uniqueItems": true
		//	                    },
		//	                    "Includes": {
		//	                      "description": "The list of patterns of Git repository file paths that, when a commit is pushed, are to be included as criteria that starts the pipeline.",
		//	                      "items": {
		//	                        "type": "string"
		//	                      },
		//	                      "type": "array",
		//	                      "uniqueItems": true
		//	                    }
		//	                  },
		//	                  "type": "object"
		//	                },
		//	                "Tags": {
		//	                  "additionalProperties": false,
		//	                  "description": "The Git tags specified as filter criteria for whether a Git tag repository event will start the pipeline.",
		//	                  "properties": {
		//	                    "Excludes": {
		//	                      "description": "The list of patterns of Git tags that, when pushed, are to be excluded from starting the pipeline.",
		//	                      "items": {
		//	                        "type": "string"
		//	                      },
		//	                      "type": "array",
		//	                      "uniqueItems": true
		//	                    },
		//	                    "Includes": {
		//	                      "description": "The list of patterns of Git tags that, when pushed, are to be included as criteria that starts the pipeline.",
		//	                      "items": {
		//	                        "type": "string"
		//	                      },
		//	                      "type": "array",
		//	                      "uniqueItems": true
		//	                    }
		//	                  },
		//	                  "type": "object"
		//	                }
		//	              },
		//	              "type": "object"
		//	            },
		//	            "type": "array",
		//	            "uniqueItems": true
		//	          },
		//	          "SourceActionName": {
		//	            "description": "The name of the pipeline source action where the trigger configuration, such as Git tags, is specified. The trigger configuration will start the pipeline upon the specified change only.",
		//	            "type": "string"
		//	          }
		//	        },
		//	        "required": [
		//	          "SourceActionName"
		//	        ],
		//	        "type": "object"
		//	      },
		//	      "ProviderType": {
		//	        "description": "The source provider for the event, such as connections configured for a repository with Git tags, for the specified trigger configuration.",
		//	        "enum": [
		//	          "CodeStarSourceConnection"
		//	        ],
		//	        "type": "string"
		//	      }
		//	    },
		//	    "required": [
		//	      "ProviderType"
		//	    ],
		//	    "type": "object"
		//	  },
		//	  "type": "array",
		//	  "uniqueItems": true
		//	}
		"triggers": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: GitConfiguration
					"git_configuration": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: PullRequest
							"pull_request": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
								NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
									Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
										// Property: Branches
										"branches": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
											Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
												// Property: Excludes
												"excludes": schema.ListAttribute{ /*START ATTRIBUTE*/
													ElementType: types.StringType,
													Description: "The list of patterns of Git branches that, when a commit is pushed, are to be excluded from starting the pipeline.",
													Optional:    true,
													Computed:    true,
													Validators: []validator.List{ /*START VALIDATORS*/
														listvalidator.UniqueValues(),
													}, /*END VALIDATORS*/
													PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
														listplanmodifier.UseStateForUnknown(),
													}, /*END PLAN MODIFIERS*/
												}, /*END ATTRIBUTE*/
												// Property: Includes
												"includes": schema.ListAttribute{ /*START ATTRIBUTE*/
													ElementType: types.StringType,
													Description: "The list of patterns of Git branches that, when a commit is pushed, are to be included as criteria that starts the pipeline.",
													Optional:    true,
													Computed:    true,
													Validators: []validator.List{ /*START VALIDATORS*/
														listvalidator.UniqueValues(),
													}, /*END VALIDATORS*/
													PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
														listplanmodifier.UseStateForUnknown(),
													}, /*END PLAN MODIFIERS*/
												}, /*END ATTRIBUTE*/
											}, /*END SCHEMA*/
											Description: "The Git repository branches specified as filter criteria to start the pipeline.",
											Optional:    true,
											Computed:    true,
											PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
												objectplanmodifier.UseStateForUnknown(),
											}, /*END PLAN MODIFIERS*/
										}, /*END ATTRIBUTE*/
										// Property: Events
										"events": schema.ListAttribute{ /*START ATTRIBUTE*/
											ElementType: types.StringType,
											Description: "The field that specifies which pull request events to filter on (opened, updated, closed) for the trigger configuration.",
											Optional:    true,
											Computed:    true,
											Validators: []validator.List{ /*START VALIDATORS*/
												listvalidator.UniqueValues(),
											}, /*END VALIDATORS*/
											PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
												listplanmodifier.UseStateForUnknown(),
											}, /*END PLAN MODIFIERS*/
										}, /*END ATTRIBUTE*/
										// Property: FilePaths
										"file_paths": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
											Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
												// Property: Excludes
												"excludes": schema.ListAttribute{ /*START ATTRIBUTE*/
													ElementType: types.StringType,
													Description: "The list of patterns of Git repository file paths that, when a commit is pushed, are to be excluded from starting the pipeline.",
													Optional:    true,
													Computed:    true,
													Validators: []validator.List{ /*START VALIDATORS*/
														listvalidator.UniqueValues(),
													}, /*END VALIDATORS*/
													PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
														listplanmodifier.UseStateForUnknown(),
													}, /*END PLAN MODIFIERS*/
												}, /*END ATTRIBUTE*/
												// Property: Includes
												"includes": schema.ListAttribute{ /*START ATTRIBUTE*/
													ElementType: types.StringType,
													Description: "The list of patterns of Git repository file paths that, when a commit is pushed, are to be included as criteria that starts the pipeline.",
													Optional:    true,
													Computed:    true,
													Validators: []validator.List{ /*START VALIDATORS*/
														listvalidator.UniqueValues(),
													}, /*END VALIDATORS*/
													PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
														listplanmodifier.UseStateForUnknown(),
													}, /*END PLAN MODIFIERS*/
												}, /*END ATTRIBUTE*/
											}, /*END SCHEMA*/
											Description: "The Git repository file paths specified as filter criteria to start the pipeline.",
											Optional:    true,
											Computed:    true,
											PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
												objectplanmodifier.UseStateForUnknown(),
											}, /*END PLAN MODIFIERS*/
										}, /*END ATTRIBUTE*/
									}, /*END SCHEMA*/
								}, /*END NESTED OBJECT*/
								Description: "The field where the repository event that will start the pipeline is specified as pull requests.",
								Optional:    true,
								Computed:    true,
								Validators: []validator.List{ /*START VALIDATORS*/
									listvalidator.UniqueValues(),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
									listplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: Push
							"push": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
								NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
									Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
										// Property: Branches
										"branches": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
											Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
												// Property: Excludes
												"excludes": schema.ListAttribute{ /*START ATTRIBUTE*/
													ElementType: types.StringType,
													Description: "The list of patterns of Git branches that, when a commit is pushed, are to be excluded from starting the pipeline.",
													Optional:    true,
													Computed:    true,
													Validators: []validator.List{ /*START VALIDATORS*/
														listvalidator.UniqueValues(),
													}, /*END VALIDATORS*/
													PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
														listplanmodifier.UseStateForUnknown(),
													}, /*END PLAN MODIFIERS*/
												}, /*END ATTRIBUTE*/
												// Property: Includes
												"includes": schema.ListAttribute{ /*START ATTRIBUTE*/
													ElementType: types.StringType,
													Description: "The list of patterns of Git branches that, when a commit is pushed, are to be included as criteria that starts the pipeline.",
													Optional:    true,
													Computed:    true,
													Validators: []validator.List{ /*START VALIDATORS*/
														listvalidator.UniqueValues(),
													}, /*END VALIDATORS*/
													PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
														listplanmodifier.UseStateForUnknown(),
													}, /*END PLAN MODIFIERS*/
												}, /*END ATTRIBUTE*/
											}, /*END SCHEMA*/
											Description: "The Git repository branches specified as filter criteria to start the pipeline.",
											Optional:    true,
											Computed:    true,
											PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
												objectplanmodifier.UseStateForUnknown(),
											}, /*END PLAN MODIFIERS*/
										}, /*END ATTRIBUTE*/
										// Property: FilePaths
										"file_paths": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
											Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
												// Property: Excludes
												"excludes": schema.ListAttribute{ /*START ATTRIBUTE*/
													ElementType: types.StringType,
													Description: "The list of patterns of Git repository file paths that, when a commit is pushed, are to be excluded from starting the pipeline.",
													Optional:    true,
													Computed:    true,
													Validators: []validator.List{ /*START VALIDATORS*/
														listvalidator.UniqueValues(),
													}, /*END VALIDATORS*/
													PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
														listplanmodifier.UseStateForUnknown(),
													}, /*END PLAN MODIFIERS*/
												}, /*END ATTRIBUTE*/
												// Property: Includes
												"includes": schema.ListAttribute{ /*START ATTRIBUTE*/
													ElementType: types.StringType,
													Description: "The list of patterns of Git repository file paths that, when a commit is pushed, are to be included as criteria that starts the pipeline.",
													Optional:    true,
													Computed:    true,
													Validators: []validator.List{ /*START VALIDATORS*/
														listvalidator.UniqueValues(),
													}, /*END VALIDATORS*/
													PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
														listplanmodifier.UseStateForUnknown(),
													}, /*END PLAN MODIFIERS*/
												}, /*END ATTRIBUTE*/
											}, /*END SCHEMA*/
											Description: "The Git repository file paths specified as filter criteria to start the pipeline.",
											Optional:    true,
											Computed:    true,
											PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
												objectplanmodifier.UseStateForUnknown(),
											}, /*END PLAN MODIFIERS*/
										}, /*END ATTRIBUTE*/
										// Property: Tags
										"tags": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
											Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
												// Property: Excludes
												"excludes": schema.ListAttribute{ /*START ATTRIBUTE*/
													ElementType: types.StringType,
													Description: "The list of patterns of Git tags that, when pushed, are to be excluded from starting the pipeline.",
													Optional:    true,
													Computed:    true,
													Validators: []validator.List{ /*START VALIDATORS*/
														listvalidator.UniqueValues(),
													}, /*END VALIDATORS*/
													PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
														listplanmodifier.UseStateForUnknown(),
													}, /*END PLAN MODIFIERS*/
												}, /*END ATTRIBUTE*/
												// Property: Includes
												"includes": schema.ListAttribute{ /*START ATTRIBUTE*/
													ElementType: types.StringType,
													Description: "The list of patterns of Git tags that, when pushed, are to be included as criteria that starts the pipeline.",
													Optional:    true,
													Computed:    true,
													Validators: []validator.List{ /*START VALIDATORS*/
														listvalidator.UniqueValues(),
													}, /*END VALIDATORS*/
													PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
														listplanmodifier.UseStateForUnknown(),
													}, /*END PLAN MODIFIERS*/
												}, /*END ATTRIBUTE*/
											}, /*END SCHEMA*/
											Description: "The Git tags specified as filter criteria for whether a Git tag repository event will start the pipeline.",
											Optional:    true,
											Computed:    true,
											PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
												objectplanmodifier.UseStateForUnknown(),
											}, /*END PLAN MODIFIERS*/
										}, /*END ATTRIBUTE*/
									}, /*END SCHEMA*/
								}, /*END NESTED OBJECT*/
								Description: "The field where the repository event that will start the pipeline, such as pushing Git tags, is specified with details.",
								Optional:    true,
								Computed:    true,
								Validators: []validator.List{ /*START VALIDATORS*/
									listvalidator.UniqueValues(),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
									listplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: SourceActionName
							"source_action_name": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "The name of the pipeline source action where the trigger configuration, such as Git tags, is specified. The trigger configuration will start the pipeline upon the specified change only.",
								Optional:    true,
								Computed:    true,
								Validators: []validator.String{ /*START VALIDATORS*/
									fwvalidators.NotNullString(),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
									stringplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
						Description: "A type of trigger configuration for Git-based source actions.",
						Optional:    true,
						Computed:    true,
						PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
							objectplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: ProviderType
					"provider_type": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The source provider for the event, such as connections configured for a repository with Git tags, for the specified trigger configuration.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.OneOf(
								"CodeStarSourceConnection",
							),
							fwvalidators.NotNullString(),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Description: "The trigger configuration specifying a type of event, such as Git tags, that starts the pipeline.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.List{ /*START VALIDATORS*/
				listvalidator.UniqueValues(),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
				listplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Variables
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A list that defines the pipeline variables for a pipeline resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9@\\-_]+.",
		//	  "items": {
		//	    "additionalProperties": false,
		//	    "description": "A variable declared at the pipeline level.",
		//	    "properties": {
		//	      "DefaultValue": {
		//	        "description": "The value of a pipeline-level variable.",
		//	        "type": "string"
		//	      },
		//	      "Description": {
		//	        "description": "The description of a pipeline-level variable. It's used to add additional context about the variable, and not being used at time when pipeline executes.",
		//	        "type": "string"
		//	      },
		//	      "Name": {
		//	        "description": "The name of a pipeline-level variable.",
		//	        "type": "string"
		//	      }
		//	    },
		//	    "required": [
		//	      "Name"
		//	    ],
		//	    "type": "object"
		//	  },
		//	  "type": "array",
		//	  "uniqueItems": true
		//	}
		"variables": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: DefaultValue
					"default_value": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The value of a pipeline-level variable.",
						Optional:    true,
						Computed:    true,
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: Description
					"description": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The description of a pipeline-level variable. It's used to add additional context about the variable, and not being used at time when pipeline executes.",
						Optional:    true,
						Computed:    true,
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: Name
					"name": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The name of a pipeline-level variable.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							fwvalidators.NotNullString(),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Description: "A list that defines the pipeline variables for a pipeline resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9@\\-_]+.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.List{ /*START VALIDATORS*/
				listvalidator.UniqueValues(),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
				listplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Version
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The version of the pipeline.",
		//	  "type": "string"
		//	}
		"version": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The version of the pipeline.",
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
	} /*END SCHEMA*/

	// Corresponds to CloudFormation primaryIdentifier.
	attributes["id"] = schema.StringAttribute{
		Description: "Uniquely identifies the resource.",
		Computed:    true,
		PlanModifiers: []planmodifier.String{
			stringplanmodifier.UseStateForUnknown(),
		},
	}

	schema := schema.Schema{
		Description: "The AWS::CodePipeline::Pipeline resource creates a CodePipeline pipeline that describes how software changes go through a release process.",
		Version:     1,
		Attributes:  attributes,
	}

	var opts generic.ResourceOptions

	opts = opts.WithCloudFormationTypeName("AWS::CodePipeline::Pipeline").WithTerraformTypeName("awscc_codepipeline_pipeline")
	opts = opts.WithTerraformSchema(schema)
	opts = opts.WithAttributeNameMap(map[string]string{
		"action_type_id":                    "ActionTypeId",
		"actions":                           "Actions",
		"artifact_store":                    "ArtifactStore",
		"artifact_stores":                   "ArtifactStores",
		"before_entry":                      "BeforeEntry",
		"blockers":                          "Blockers",
		"branches":                          "Branches",
		"category":                          "Category",
		"commands":                          "Commands",
		"conditions":                        "Conditions",
		"configuration":                     "Configuration",
		"default_value":                     "DefaultValue",
		"description":                       "Description",
		"disable_inbound_stage_transitions": "DisableInboundStageTransitions",
		"encryption_key":                    "EncryptionKey",
		"environment_variables":             "EnvironmentVariables",
		"events":                            "Events",
		"excludes":                          "Excludes",
		"execution_mode":                    "ExecutionMode",
		"file_paths":                        "FilePaths",
		"files":                             "Files",
		"git_configuration":                 "GitConfiguration",
		"id":                                "Id",
		"includes":                          "Includes",
		"input_artifacts":                   "InputArtifacts",
		"key":                               "Key",
		"location":                          "Location",
		"name":                              "Name",
		"namespace":                         "Namespace",
		"on_failure":                        "OnFailure",
		"on_success":                        "OnSuccess",
		"output_artifacts":                  "OutputArtifacts",
		"output_variables":                  "OutputVariables",
		"owner":                             "Owner",
		"pipeline_type":                     "PipelineType",
		"provider":                          "Provider",
		"provider_type":                     "ProviderType",
		"pull_request":                      "PullRequest",
		"push":                              "Push",
		"reason":                            "Reason",
		"region":                            "Region",
		"restart_execution_on_update":       "RestartExecutionOnUpdate",
		"result":                            "Result",
		"retry_configuration":               "RetryConfiguration",
		"retry_mode":                        "RetryMode",
		"role_arn":                          "RoleArn",
		"rule_type_id":                      "RuleTypeId",
		"rules":                             "Rules",
		"run_order":                         "RunOrder",
		"source_action_name":                "SourceActionName",
		"stage_name":                        "StageName",
		"stages":                            "Stages",
		"tags":                              "Tags",
		"timeout_in_minutes":                "TimeoutInMinutes",
		"triggers":                          "Triggers",
		"type":                              "Type",
		"value":                             "Value",
		"variables":                         "Variables",
		"version":                           "Version",
	})

	opts = opts.WithWriteOnlyPropertyPaths([]string{
		"/properties/RestartExecutionOnUpdate",
	})
	opts = opts.WithCreateTimeoutInMinutes(0).WithDeleteTimeoutInMinutes(0)

	opts = opts.WithUpdateTimeoutInMinutes(0)

	v, err := generic.NewResource(ctx, opts...)

	if err != nil {
		return nil, err
	}

	return v, nil
}
