// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// Code generated by generators/resource/main.go; DO NOT EDIT.

package quicksight

import (
	"context"
	"github.com/hashicorp/terraform-plugin-framework-validators/float64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/float64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/mapplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-provider-awscc/internal/generic"
	"github.com/hashicorp/terraform-provider-awscc/internal/registry"
	"regexp"
)

func init() {
	registry.AddResourceFactory("awscc_quicksight_data_set", dataSetResource)
}

// dataSetResource returns the Terraform awscc_quicksight_data_set resource.
// This Terraform resource corresponds to the CloudFormation AWS::QuickSight::DataSet resource.
func dataSetResource(ctx context.Context) (resource.Resource, error) {
	attributes := map[string]schema.Attribute{ /*START SCHEMA*/
		// Property: Arn
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "\u003cp\u003eThe Amazon Resource Name (ARN) of the resource.\u003c/p\u003e",
		//	  "type": "string"
		//	}
		"arn": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "<p>The Amazon Resource Name (ARN) of the resource.</p>",
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: AwsAccountId
		// CloudFormation resource type schema:
		//
		//	{
		//	  "maxLength": 12,
		//	  "minLength": 12,
		//	  "pattern": "^[0-9]{12}$",
		//	  "type": "string"
		//	}
		"aws_account_id": schema.StringAttribute{ /*START ATTRIBUTE*/
			Optional: true,
			Computed: true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.LengthBetween(12, 12),
				stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]{12}$"), ""),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
				stringplanmodifier.RequiresReplace(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: ColumnGroups
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "\u003cp\u003eGroupings of columns that work together in certain QuickSight features. Currently, only geospatial hierarchy is supported.\u003c/p\u003e",
		//	  "items": {
		//	    "description": "\u003cp\u003eGroupings of columns that work together in certain Amazon QuickSight features. This is\n            a variant type structure. For this structure to be valid, only one of the attributes can\n            be non-null.\u003c/p\u003e",
		//	    "properties": {
		//	      "GeoSpatialColumnGroup": {
		//	        "description": "\u003cp\u003eGeospatial column group that denotes a hierarchy.\u003c/p\u003e",
		//	        "properties": {
		//	          "Columns": {
		//	            "description": "\u003cp\u003eColumns in this hierarchy.\u003c/p\u003e",
		//	            "items": {
		//	              "maxLength": 128,
		//	              "minLength": 1,
		//	              "type": "string"
		//	            },
		//	            "maxItems": 16,
		//	            "minItems": 1,
		//	            "type": "array"
		//	          },
		//	          "CountryCode": {
		//	            "enum": [
		//	              "US"
		//	            ],
		//	            "type": "string"
		//	          },
		//	          "Name": {
		//	            "description": "\u003cp\u003eA display name for the hierarchy.\u003c/p\u003e",
		//	            "maxLength": 64,
		//	            "minLength": 1,
		//	            "type": "string"
		//	          }
		//	        },
		//	        "required": [
		//	          "Columns",
		//	          "Name"
		//	        ],
		//	        "type": "object"
		//	      }
		//	    },
		//	    "type": "object"
		//	  },
		//	  "maxItems": 8,
		//	  "minItems": 1,
		//	  "type": "array"
		//	}
		"column_groups": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: GeoSpatialColumnGroup
					"geo_spatial_column_group": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: Columns
							"columns": schema.ListAttribute{ /*START ATTRIBUTE*/
								ElementType: types.StringType,
								Description: "<p>Columns in this hierarchy.</p>",
								Required:    true,
								Validators: []validator.List{ /*START VALIDATORS*/
									listvalidator.SizeBetween(1, 16),
									listvalidator.ValueStringsAre(
										stringvalidator.LengthBetween(1, 128),
									),
								}, /*END VALIDATORS*/
							}, /*END ATTRIBUTE*/
							// Property: CountryCode
							"country_code": schema.StringAttribute{ /*START ATTRIBUTE*/
								Optional: true,
								Computed: true,
								Validators: []validator.String{ /*START VALIDATORS*/
									stringvalidator.OneOf(
										"US",
									),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
									stringplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: Name
							"name": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "<p>A display name for the hierarchy.</p>",
								Required:    true,
								Validators: []validator.String{ /*START VALIDATORS*/
									stringvalidator.LengthBetween(1, 64),
								}, /*END VALIDATORS*/
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
						Description: "<p>Geospatial column group that denotes a hierarchy.</p>",
						Optional:    true,
						Computed:    true,
						PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
							objectplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Description: "<p>Groupings of columns that work together in certain QuickSight features. Currently, only geospatial hierarchy is supported.</p>",
			Optional:    true,
			Computed:    true,
			Validators: []validator.List{ /*START VALIDATORS*/
				listvalidator.SizeBetween(1, 8),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
				listplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: ColumnLevelPermissionRules
		// CloudFormation resource type schema:
		//
		//	{
		//	  "items": {
		//	    "properties": {
		//	      "ColumnNames": {
		//	        "items": {
		//	          "type": "string"
		//	        },
		//	        "minItems": 1,
		//	        "type": "array"
		//	      },
		//	      "Principals": {
		//	        "items": {
		//	          "type": "string"
		//	        },
		//	        "maxItems": 100,
		//	        "minItems": 1,
		//	        "type": "array"
		//	      }
		//	    },
		//	    "type": "object"
		//	  },
		//	  "minItems": 1,
		//	  "type": "array"
		//	}
		"column_level_permission_rules": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: ColumnNames
					"column_names": schema.ListAttribute{ /*START ATTRIBUTE*/
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
						Validators: []validator.List{ /*START VALIDATORS*/
							listvalidator.SizeAtLeast(1),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
							listplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: Principals
					"principals": schema.ListAttribute{ /*START ATTRIBUTE*/
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
						Validators: []validator.List{ /*START VALIDATORS*/
							listvalidator.SizeBetween(1, 100),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
							listplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Optional: true,
			Computed: true,
			Validators: []validator.List{ /*START VALIDATORS*/
				listvalidator.SizeAtLeast(1),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
				listplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: ConsumedSpiceCapacityInBytes
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "\u003cp\u003eThe amount of SPICE capacity used by this dataset. This is 0 if the dataset isn't\n            imported into SPICE.\u003c/p\u003e",
		//	  "type": "number"
		//	}
		"consumed_spice_capacity_in_bytes": schema.Float64Attribute{ /*START ATTRIBUTE*/
			Description: "<p>The amount of SPICE capacity used by this dataset. This is 0 if the dataset isn't\n            imported into SPICE.</p>",
			Computed:    true,
			PlanModifiers: []planmodifier.Float64{ /*START PLAN MODIFIERS*/
				float64planmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: CreatedTime
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "\u003cp\u003eThe time that this dataset was created.\u003c/p\u003e",
		//	  "format": "string",
		//	  "type": "string"
		//	}
		"created_time": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "<p>The time that this dataset was created.</p>",
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: DataSetId
		// CloudFormation resource type schema:
		//
		//	{
		//	  "type": "string"
		//	}
		"data_set_id": schema.StringAttribute{ /*START ATTRIBUTE*/
			Optional: true,
			Computed: true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
				stringplanmodifier.RequiresReplace(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: DataSetUsageConfiguration
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "\u003cp\u003eThe dataset usage configuration for the dataset.\u003c/p\u003e",
		//	  "properties": {
		//	    "DisableUseAsDirectQuerySource": {
		//	      "type": "boolean"
		//	    },
		//	    "DisableUseAsImportedSource": {
		//	      "type": "boolean"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"data_set_usage_configuration": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: DisableUseAsDirectQuerySource
				"disable_use_as_direct_query_source": schema.BoolAttribute{ /*START ATTRIBUTE*/
					Optional: true,
					Computed: true,
					PlanModifiers: []planmodifier.Bool{ /*START PLAN MODIFIERS*/
						boolplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: DisableUseAsImportedSource
				"disable_use_as_imported_source": schema.BoolAttribute{ /*START ATTRIBUTE*/
					Optional: true,
					Computed: true,
					PlanModifiers: []planmodifier.Bool{ /*START PLAN MODIFIERS*/
						boolplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "<p>The dataset usage configuration for the dataset.</p>",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: FieldFolders
		// CloudFormation resource type schema:
		//
		//	{
		//	  "patternProperties": {
		//	    "": {
		//	      "properties": {
		//	        "Columns": {
		//	          "items": {
		//	            "type": "string"
		//	          },
		//	          "maxItems": 5000,
		//	          "minItems": 0,
		//	          "type": "array"
		//	        },
		//	        "Description": {
		//	          "maxLength": 500,
		//	          "minLength": 0,
		//	          "type": "string"
		//	        }
		//	      },
		//	      "type": "object"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"field_folders":           // Pattern: ""
		schema.MapNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: Columns
					"columns": schema.ListAttribute{ /*START ATTRIBUTE*/
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
						Validators: []validator.List{ /*START VALIDATORS*/
							listvalidator.SizeBetween(0, 5000),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
							listplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: Description
					"description": schema.StringAttribute{ /*START ATTRIBUTE*/
						Optional: true,
						Computed: true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.LengthBetween(0, 500),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Optional: true,
			Computed: true,
			PlanModifiers: []planmodifier.Map{ /*START PLAN MODIFIERS*/
				mapplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
			// FieldFolders is a write-only property.
		}, /*END ATTRIBUTE*/
		// Property: ImportMode
		// CloudFormation resource type schema:
		//
		//	{
		//	  "enum": [
		//	    "SPICE",
		//	    "DIRECT_QUERY"
		//	  ],
		//	  "type": "string"
		//	}
		"import_mode": schema.StringAttribute{ /*START ATTRIBUTE*/
			Optional: true,
			Computed: true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.OneOf(
					"SPICE",
					"DIRECT_QUERY",
				),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: IngestionWaitPolicy
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "\u003cp\u003eWait policy to use when creating/updating dataset. Default is to wait for SPICE ingestion to finish with timeout of 36 hours.\u003c/p\u003e",
		//	  "properties": {
		//	    "IngestionWaitTimeInHours": {
		//	      "default": 36,
		//	      "description": "\u003cp\u003eThe maximum time (in hours) to wait for Ingestion to complete. Default timeout is 36 hours.\n Applicable only when DataSetImportMode mode is set to SPICE and WaitForSpiceIngestion is set to true.\u003c/p\u003e",
		//	      "maximum": 36,
		//	      "minimum": 1,
		//	      "type": "number"
		//	    },
		//	    "WaitForSpiceIngestion": {
		//	      "default": true,
		//	      "description": "\u003cp\u003eWait for SPICE ingestion to finish to mark dataset creation/update successful. Default (true).\n  Applicable only when DataSetImportMode mode is set to SPICE.\u003c/p\u003e",
		//	      "type": "boolean"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"ingestion_wait_policy": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: IngestionWaitTimeInHours
				"ingestion_wait_time_in_hours": schema.Float64Attribute{ /*START ATTRIBUTE*/
					Description: "<p>The maximum time (in hours) to wait for Ingestion to complete. Default timeout is 36 hours.\n Applicable only when DataSetImportMode mode is set to SPICE and WaitForSpiceIngestion is set to true.</p>",
					Optional:    true,
					Computed:    true,
					Validators: []validator.Float64{ /*START VALIDATORS*/
						float64validator.Between(1.000000, 36.000000),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.Float64{ /*START PLAN MODIFIERS*/
						generic.Float64DefaultValue(36.000000),
						float64planmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: WaitForSpiceIngestion
				"wait_for_spice_ingestion": schema.BoolAttribute{ /*START ATTRIBUTE*/
					Description: "<p>Wait for SPICE ingestion to finish to mark dataset creation/update successful. Default (true).\n  Applicable only when DataSetImportMode mode is set to SPICE.</p>",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.Bool{ /*START PLAN MODIFIERS*/
						generic.BoolDefaultValue(true),
						boolplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "<p>Wait policy to use when creating/updating dataset. Default is to wait for SPICE ingestion to finish with timeout of 36 hours.</p>",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
			// IngestionWaitPolicy is a write-only property.
		}, /*END ATTRIBUTE*/
		// Property: LastUpdatedTime
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "\u003cp\u003eThe last time that this dataset was updated.\u003c/p\u003e",
		//	  "format": "string",
		//	  "type": "string"
		//	}
		"last_updated_time": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "<p>The last time that this dataset was updated.</p>",
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: LogicalTableMap
		// CloudFormation resource type schema:
		//
		//	{
		//	  "patternProperties": {
		//	    "": {
		//	      "description": "\u003cp\u003eA \u003ci\u003elogical table\u003c/i\u003e is a unit that joins and that data\n            transformations operate on. A logical table has a source, which can be either a physical\n            table or result of a join. When a logical table points to a physical table, the logical\n            table acts as a mutable copy of that physical table through transform operations.\u003c/p\u003e",
		//	      "properties": {
		//	        "Alias": {
		//	          "description": "\u003cp\u003eA display name for the logical table.\u003c/p\u003e",
		//	          "maxLength": 64,
		//	          "minLength": 1,
		//	          "type": "string"
		//	        },
		//	        "DataTransforms": {
		//	          "description": "\u003cp\u003eTransform operations that act on this logical table.\u003c/p\u003e",
		//	          "items": {
		//	            "description": "\u003cp\u003eA data transformation on a logical table. This is a variant type structure. For this\n            structure to be valid, only one of the attributes can be non-null.\u003c/p\u003e",
		//	            "properties": {
		//	              "CastColumnTypeOperation": {
		//	                "description": "\u003cp\u003eA transform operation that casts a column to a different type.\u003c/p\u003e",
		//	                "properties": {
		//	                  "ColumnName": {
		//	                    "description": "\u003cp\u003eColumn name.\u003c/p\u003e",
		//	                    "maxLength": 128,
		//	                    "minLength": 1,
		//	                    "type": "string"
		//	                  },
		//	                  "Format": {
		//	                    "description": "\u003cp\u003eWhen casting a column from string to datetime type, you can supply a string in a\n            format supported by Amazon QuickSight to denote the source data format.\u003c/p\u003e",
		//	                    "maxLength": 32,
		//	                    "minLength": 0,
		//	                    "type": "string"
		//	                  },
		//	                  "NewColumnType": {
		//	                    "enum": [
		//	                      "STRING",
		//	                      "INTEGER",
		//	                      "DECIMAL",
		//	                      "DATETIME"
		//	                    ],
		//	                    "type": "string"
		//	                  }
		//	                },
		//	                "required": [
		//	                  "ColumnName",
		//	                  "NewColumnType"
		//	                ],
		//	                "type": "object"
		//	              },
		//	              "CreateColumnsOperation": {
		//	                "description": "\u003cp\u003eA transform operation that creates calculated columns. Columns created in one such\n            operation form a lexical closure.\u003c/p\u003e",
		//	                "properties": {
		//	                  "Columns": {
		//	                    "description": "\u003cp\u003eCalculated columns to create.\u003c/p\u003e",
		//	                    "items": {
		//	                      "description": "\u003cp\u003eA calculated column for a dataset.\u003c/p\u003e",
		//	                      "properties": {
		//	                        "ColumnId": {
		//	                          "description": "\u003cp\u003eA unique ID to identify a calculated column. During a dataset update, if the column ID\n            of a calculated column matches that of an existing calculated column, Amazon QuickSight\n            preserves the existing calculated column.\u003c/p\u003e",
		//	                          "maxLength": 64,
		//	                          "minLength": 1,
		//	                          "type": "string"
		//	                        },
		//	                        "ColumnName": {
		//	                          "description": "\u003cp\u003eColumn name.\u003c/p\u003e",
		//	                          "maxLength": 128,
		//	                          "minLength": 1,
		//	                          "type": "string"
		//	                        },
		//	                        "Expression": {
		//	                          "description": "\u003cp\u003eAn expression that defines the calculated column.\u003c/p\u003e",
		//	                          "maxLength": 4096,
		//	                          "minLength": 1,
		//	                          "type": "string"
		//	                        }
		//	                      },
		//	                      "required": [
		//	                        "ColumnId",
		//	                        "ColumnName",
		//	                        "Expression"
		//	                      ],
		//	                      "type": "object"
		//	                    },
		//	                    "maxItems": 128,
		//	                    "minItems": 1,
		//	                    "type": "array"
		//	                  }
		//	                },
		//	                "required": [
		//	                  "Columns"
		//	                ],
		//	                "type": "object"
		//	              },
		//	              "FilterOperation": {
		//	                "description": "\u003cp\u003eA transform operation that filters rows based on a condition.\u003c/p\u003e",
		//	                "properties": {
		//	                  "ConditionExpression": {
		//	                    "description": "\u003cp\u003eAn expression that must evaluate to a Boolean value. Rows for which the expression\n            evaluates to true are kept in the dataset.\u003c/p\u003e",
		//	                    "maxLength": 4096,
		//	                    "minLength": 1,
		//	                    "type": "string"
		//	                  }
		//	                },
		//	                "required": [
		//	                  "ConditionExpression"
		//	                ],
		//	                "type": "object"
		//	              },
		//	              "ProjectOperation": {
		//	                "description": "\u003cp\u003eA transform operation that projects columns. Operations that come after a projection\n            can only refer to projected columns.\u003c/p\u003e",
		//	                "properties": {
		//	                  "ProjectedColumns": {
		//	                    "description": "\u003cp\u003eProjected columns.\u003c/p\u003e",
		//	                    "items": {
		//	                      "type": "string"
		//	                    },
		//	                    "maxItems": 2000,
		//	                    "minItems": 1,
		//	                    "type": "array"
		//	                  }
		//	                },
		//	                "required": [
		//	                  "ProjectedColumns"
		//	                ],
		//	                "type": "object"
		//	              },
		//	              "RenameColumnOperation": {
		//	                "description": "\u003cp\u003eA transform operation that renames a column.\u003c/p\u003e",
		//	                "properties": {
		//	                  "ColumnName": {
		//	                    "description": "\u003cp\u003eThe name of the column to be renamed.\u003c/p\u003e",
		//	                    "maxLength": 128,
		//	                    "minLength": 1,
		//	                    "type": "string"
		//	                  },
		//	                  "NewColumnName": {
		//	                    "description": "\u003cp\u003eThe new name for the column.\u003c/p\u003e",
		//	                    "maxLength": 128,
		//	                    "minLength": 1,
		//	                    "type": "string"
		//	                  }
		//	                },
		//	                "required": [
		//	                  "ColumnName",
		//	                  "NewColumnName"
		//	                ],
		//	                "type": "object"
		//	              },
		//	              "TagColumnOperation": {
		//	                "description": "\u003cp\u003eA transform operation that tags a column with additional information.\u003c/p\u003e",
		//	                "properties": {
		//	                  "ColumnName": {
		//	                    "description": "\u003cp\u003eThe column that this operation acts on.\u003c/p\u003e",
		//	                    "maxLength": 128,
		//	                    "minLength": 1,
		//	                    "type": "string"
		//	                  },
		//	                  "Tags": {
		//	                    "description": "\u003cp\u003eThe dataset column tag, currently only used for geospatial type tagging. .\u003c/p\u003e\n        \u003cnote\u003e\n            \u003cp\u003eThis is not tags for the AWS tagging feature. .\u003c/p\u003e\n        \u003c/note\u003e",
		//	                    "items": {
		//	                      "description": "\u003cp\u003eA tag for a column in a \u003ca\u003eTagColumnOperation\u003c/a\u003e structure. This is a\n            variant type structure. For this structure to be valid, only one of the attributes can\n            be non-null.\u003c/p\u003e",
		//	                      "properties": {
		//	                        "ColumnDescription": {
		//	                          "description": "\u003cp\u003eMetadata that contains a description for a column.\u003c/p\u003e",
		//	                          "properties": {
		//	                            "Text": {
		//	                              "description": "\u003cp\u003eThe text of a description for a column.\u003c/p\u003e",
		//	                              "maxLength": 500,
		//	                              "minLength": 0,
		//	                              "type": "string"
		//	                            }
		//	                          },
		//	                          "type": "object"
		//	                        },
		//	                        "ColumnGeographicRole": {
		//	                          "enum": [
		//	                            "COUNTRY",
		//	                            "STATE",
		//	                            "COUNTY",
		//	                            "CITY",
		//	                            "POSTCODE",
		//	                            "LONGITUDE",
		//	                            "LATITUDE",
		//	                            "POLITICAL1"
		//	                          ],
		//	                          "type": "string"
		//	                        }
		//	                      },
		//	                      "type": "object"
		//	                    },
		//	                    "maxItems": 16,
		//	                    "minItems": 1,
		//	                    "type": "array"
		//	                  }
		//	                },
		//	                "required": [
		//	                  "ColumnName",
		//	                  "Tags"
		//	                ],
		//	                "type": "object"
		//	              }
		//	            },
		//	            "type": "object"
		//	          },
		//	          "maxItems": 2048,
		//	          "minItems": 1,
		//	          "type": "array"
		//	        },
		//	        "Source": {
		//	          "description": "\u003cp\u003eInformation about the source of a logical table. This is a variant type structure. For\n            this structure to be valid, only one of the attributes can be non-null.\u003c/p\u003e",
		//	          "properties": {
		//	            "DataSetArn": {
		//	              "description": "\u003cp\u003eThe Amazon Resource Name (ARN) for the dataset.\u003c/p\u003e",
		//	              "type": "string"
		//	            },
		//	            "JoinInstruction": {
		//	              "description": "\u003cp\u003eJoin instruction.\u003c/p\u003e",
		//	              "properties": {
		//	                "LeftJoinKeyProperties": {
		//	                  "properties": {
		//	                    "UniqueKey": {
		//	                      "type": "boolean"
		//	                    }
		//	                  },
		//	                  "type": "object"
		//	                },
		//	                "LeftOperand": {
		//	                  "description": "\u003cp\u003eLeft operand.\u003c/p\u003e",
		//	                  "maxLength": 64,
		//	                  "minLength": 1,
		//	                  "pattern": "[0-9a-zA-Z-]*",
		//	                  "type": "string"
		//	                },
		//	                "OnClause": {
		//	                  "description": "\u003cp\u003eOn Clause.\u003c/p\u003e",
		//	                  "maxLength": 512,
		//	                  "minLength": 1,
		//	                  "type": "string"
		//	                },
		//	                "RightJoinKeyProperties": {
		//	                  "properties": {
		//	                    "UniqueKey": {
		//	                      "type": "boolean"
		//	                    }
		//	                  },
		//	                  "type": "object"
		//	                },
		//	                "RightOperand": {
		//	                  "description": "\u003cp\u003eRight operand.\u003c/p\u003e",
		//	                  "maxLength": 64,
		//	                  "minLength": 1,
		//	                  "pattern": "[0-9a-zA-Z-]*",
		//	                  "type": "string"
		//	                },
		//	                "Type": {
		//	                  "enum": [
		//	                    "INNER",
		//	                    "OUTER",
		//	                    "LEFT",
		//	                    "RIGHT"
		//	                  ],
		//	                  "type": "string"
		//	                }
		//	              },
		//	              "required": [
		//	                "LeftOperand",
		//	                "OnClause",
		//	                "RightOperand",
		//	                "Type"
		//	              ],
		//	              "type": "object"
		//	            },
		//	            "PhysicalTableId": {
		//	              "description": "\u003cp\u003ePhysical table ID.\u003c/p\u003e",
		//	              "maxLength": 64,
		//	              "minLength": 1,
		//	              "pattern": "[0-9a-zA-Z-]*",
		//	              "type": "string"
		//	            }
		//	          },
		//	          "type": "object"
		//	        }
		//	      },
		//	      "required": [
		//	        "Alias",
		//	        "Source"
		//	      ],
		//	      "type": "object"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"logical_table_map":       // Pattern: ""
		schema.MapNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: Alias
					"alias": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "<p>A display name for the logical table.</p>",
						Optional:    true,
						Computed:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.LengthBetween(1, 64),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: DataTransforms
					"data_transforms": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
						NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: CastColumnTypeOperation
								"cast_column_type_operation": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
									Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
										// Property: ColumnName
										"column_name": schema.StringAttribute{ /*START ATTRIBUTE*/
											Description: "<p>Column name.</p>",
											Required:    true,
											Validators: []validator.String{ /*START VALIDATORS*/
												stringvalidator.LengthBetween(1, 128),
											}, /*END VALIDATORS*/
										}, /*END ATTRIBUTE*/
										// Property: Format
										"format": schema.StringAttribute{ /*START ATTRIBUTE*/
											Description: "<p>When casting a column from string to datetime type, you can supply a string in a\n            format supported by Amazon QuickSight to denote the source data format.</p>",
											Optional:    true,
											Computed:    true,
											Validators: []validator.String{ /*START VALIDATORS*/
												stringvalidator.LengthBetween(0, 32),
											}, /*END VALIDATORS*/
											PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
												stringplanmodifier.UseStateForUnknown(),
											}, /*END PLAN MODIFIERS*/
										}, /*END ATTRIBUTE*/
										// Property: NewColumnType
										"new_column_type": schema.StringAttribute{ /*START ATTRIBUTE*/
											Required: true,
											Validators: []validator.String{ /*START VALIDATORS*/
												stringvalidator.OneOf(
													"STRING",
													"INTEGER",
													"DECIMAL",
													"DATETIME",
												),
											}, /*END VALIDATORS*/
										}, /*END ATTRIBUTE*/
									}, /*END SCHEMA*/
									Description: "<p>A transform operation that casts a column to a different type.</p>",
									Optional:    true,
									Computed:    true,
									PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
										objectplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: CreateColumnsOperation
								"create_columns_operation": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
									Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
										// Property: Columns
										"columns": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
											NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
												Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
													// Property: ColumnId
													"column_id": schema.StringAttribute{ /*START ATTRIBUTE*/
														Description: "<p>A unique ID to identify a calculated column. During a dataset update, if the column ID\n            of a calculated column matches that of an existing calculated column, Amazon QuickSight\n            preserves the existing calculated column.</p>",
														Required:    true,
														Validators: []validator.String{ /*START VALIDATORS*/
															stringvalidator.LengthBetween(1, 64),
														}, /*END VALIDATORS*/
													}, /*END ATTRIBUTE*/
													// Property: ColumnName
													"column_name": schema.StringAttribute{ /*START ATTRIBUTE*/
														Description: "<p>Column name.</p>",
														Required:    true,
														Validators: []validator.String{ /*START VALIDATORS*/
															stringvalidator.LengthBetween(1, 128),
														}, /*END VALIDATORS*/
													}, /*END ATTRIBUTE*/
													// Property: Expression
													"expression": schema.StringAttribute{ /*START ATTRIBUTE*/
														Description: "<p>An expression that defines the calculated column.</p>",
														Required:    true,
														Validators: []validator.String{ /*START VALIDATORS*/
															stringvalidator.LengthBetween(1, 4096),
														}, /*END VALIDATORS*/
													}, /*END ATTRIBUTE*/
												}, /*END SCHEMA*/
											}, /*END NESTED OBJECT*/
											Description: "<p>Calculated columns to create.</p>",
											Required:    true,
											Validators: []validator.List{ /*START VALIDATORS*/
												listvalidator.SizeBetween(1, 128),
											}, /*END VALIDATORS*/
										}, /*END ATTRIBUTE*/
									}, /*END SCHEMA*/
									Description: "<p>A transform operation that creates calculated columns. Columns created in one such\n            operation form a lexical closure.</p>",
									Optional:    true,
									Computed:    true,
									PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
										objectplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: FilterOperation
								"filter_operation": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
									Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
										// Property: ConditionExpression
										"condition_expression": schema.StringAttribute{ /*START ATTRIBUTE*/
											Description: "<p>An expression that must evaluate to a Boolean value. Rows for which the expression\n            evaluates to true are kept in the dataset.</p>",
											Required:    true,
											Validators: []validator.String{ /*START VALIDATORS*/
												stringvalidator.LengthBetween(1, 4096),
											}, /*END VALIDATORS*/
										}, /*END ATTRIBUTE*/
									}, /*END SCHEMA*/
									Description: "<p>A transform operation that filters rows based on a condition.</p>",
									Optional:    true,
									Computed:    true,
									PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
										objectplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: ProjectOperation
								"project_operation": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
									Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
										// Property: ProjectedColumns
										"projected_columns": schema.ListAttribute{ /*START ATTRIBUTE*/
											ElementType: types.StringType,
											Description: "<p>Projected columns.</p>",
											Required:    true,
											Validators: []validator.List{ /*START VALIDATORS*/
												listvalidator.SizeBetween(1, 2000),
											}, /*END VALIDATORS*/
										}, /*END ATTRIBUTE*/
									}, /*END SCHEMA*/
									Description: "<p>A transform operation that projects columns. Operations that come after a projection\n            can only refer to projected columns.</p>",
									Optional:    true,
									Computed:    true,
									PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
										objectplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: RenameColumnOperation
								"rename_column_operation": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
									Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
										// Property: ColumnName
										"column_name": schema.StringAttribute{ /*START ATTRIBUTE*/
											Description: "<p>The name of the column to be renamed.</p>",
											Required:    true,
											Validators: []validator.String{ /*START VALIDATORS*/
												stringvalidator.LengthBetween(1, 128),
											}, /*END VALIDATORS*/
										}, /*END ATTRIBUTE*/
										// Property: NewColumnName
										"new_column_name": schema.StringAttribute{ /*START ATTRIBUTE*/
											Description: "<p>The new name for the column.</p>",
											Required:    true,
											Validators: []validator.String{ /*START VALIDATORS*/
												stringvalidator.LengthBetween(1, 128),
											}, /*END VALIDATORS*/
										}, /*END ATTRIBUTE*/
									}, /*END SCHEMA*/
									Description: "<p>A transform operation that renames a column.</p>",
									Optional:    true,
									Computed:    true,
									PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
										objectplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
								// Property: TagColumnOperation
								"tag_column_operation": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
									Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
										// Property: ColumnName
										"column_name": schema.StringAttribute{ /*START ATTRIBUTE*/
											Description: "<p>The column that this operation acts on.</p>",
											Required:    true,
											Validators: []validator.String{ /*START VALIDATORS*/
												stringvalidator.LengthBetween(1, 128),
											}, /*END VALIDATORS*/
										}, /*END ATTRIBUTE*/
										// Property: Tags
										"tags": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
											NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
												Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
													// Property: ColumnDescription
													"column_description": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
														Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
															// Property: Text
															"text": schema.StringAttribute{ /*START ATTRIBUTE*/
																Description: "<p>The text of a description for a column.</p>",
																Optional:    true,
																Computed:    true,
																Validators: []validator.String{ /*START VALIDATORS*/
																	stringvalidator.LengthBetween(0, 500),
																}, /*END VALIDATORS*/
																PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
																	stringplanmodifier.UseStateForUnknown(),
																}, /*END PLAN MODIFIERS*/
															}, /*END ATTRIBUTE*/
														}, /*END SCHEMA*/
														Description: "<p>Metadata that contains a description for a column.</p>",
														Optional:    true,
														Computed:    true,
														PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
															objectplanmodifier.UseStateForUnknown(),
														}, /*END PLAN MODIFIERS*/
													}, /*END ATTRIBUTE*/
													// Property: ColumnGeographicRole
													"column_geographic_role": schema.StringAttribute{ /*START ATTRIBUTE*/
														Optional: true,
														Computed: true,
														Validators: []validator.String{ /*START VALIDATORS*/
															stringvalidator.OneOf(
																"COUNTRY",
																"STATE",
																"COUNTY",
																"CITY",
																"POSTCODE",
																"LONGITUDE",
																"LATITUDE",
																"POLITICAL1",
															),
														}, /*END VALIDATORS*/
														PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
															stringplanmodifier.UseStateForUnknown(),
														}, /*END PLAN MODIFIERS*/
													}, /*END ATTRIBUTE*/
												}, /*END SCHEMA*/
											}, /*END NESTED OBJECT*/
											Description: "<p>The dataset column tag, currently only used for geospatial type tagging. .</p>\n        <note>\n            <p>This is not tags for the AWS tagging feature. .</p>\n        </note>",
											Required:    true,
											Validators: []validator.List{ /*START VALIDATORS*/
												listvalidator.SizeBetween(1, 16),
											}, /*END VALIDATORS*/
										}, /*END ATTRIBUTE*/
									}, /*END SCHEMA*/
									Description: "<p>A transform operation that tags a column with additional information.</p>",
									Optional:    true,
									Computed:    true,
									PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
										objectplanmodifier.UseStateForUnknown(),
									}, /*END PLAN MODIFIERS*/
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
						}, /*END NESTED OBJECT*/
						Description: "<p>Transform operations that act on this logical table.</p>",
						Optional:    true,
						Computed:    true,
						Validators: []validator.List{ /*START VALIDATORS*/
							listvalidator.SizeBetween(1, 2048),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
							listplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: Source
					"source": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: DataSetArn
							"data_set_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "<p>The Amazon Resource Name (ARN) for the dataset.</p>",
								Optional:    true,
								Computed:    true,
								PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
									stringplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: JoinInstruction
							"join_instruction": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
								Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
									// Property: LeftJoinKeyProperties
									"left_join_key_properties": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
										Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
											// Property: UniqueKey
											"unique_key": schema.BoolAttribute{ /*START ATTRIBUTE*/
												Optional: true,
												Computed: true,
												PlanModifiers: []planmodifier.Bool{ /*START PLAN MODIFIERS*/
													boolplanmodifier.UseStateForUnknown(),
												}, /*END PLAN MODIFIERS*/
											}, /*END ATTRIBUTE*/
										}, /*END SCHEMA*/
										Optional: true,
										Computed: true,
										PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
											objectplanmodifier.UseStateForUnknown(),
										}, /*END PLAN MODIFIERS*/
									}, /*END ATTRIBUTE*/
									// Property: LeftOperand
									"left_operand": schema.StringAttribute{ /*START ATTRIBUTE*/
										Description: "<p>Left operand.</p>",
										Required:    true,
										Validators: []validator.String{ /*START VALIDATORS*/
											stringvalidator.LengthBetween(1, 64),
											stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-zA-Z-]*"), ""),
										}, /*END VALIDATORS*/
									}, /*END ATTRIBUTE*/
									// Property: OnClause
									"on_clause": schema.StringAttribute{ /*START ATTRIBUTE*/
										Description: "<p>On Clause.</p>",
										Required:    true,
										Validators: []validator.String{ /*START VALIDATORS*/
											stringvalidator.LengthBetween(1, 512),
										}, /*END VALIDATORS*/
									}, /*END ATTRIBUTE*/
									// Property: RightJoinKeyProperties
									"right_join_key_properties": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
										Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
											// Property: UniqueKey
											"unique_key": schema.BoolAttribute{ /*START ATTRIBUTE*/
												Optional: true,
												Computed: true,
												PlanModifiers: []planmodifier.Bool{ /*START PLAN MODIFIERS*/
													boolplanmodifier.UseStateForUnknown(),
												}, /*END PLAN MODIFIERS*/
											}, /*END ATTRIBUTE*/
										}, /*END SCHEMA*/
										Optional: true,
										Computed: true,
										PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
											objectplanmodifier.UseStateForUnknown(),
										}, /*END PLAN MODIFIERS*/
									}, /*END ATTRIBUTE*/
									// Property: RightOperand
									"right_operand": schema.StringAttribute{ /*START ATTRIBUTE*/
										Description: "<p>Right operand.</p>",
										Required:    true,
										Validators: []validator.String{ /*START VALIDATORS*/
											stringvalidator.LengthBetween(1, 64),
											stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-zA-Z-]*"), ""),
										}, /*END VALIDATORS*/
									}, /*END ATTRIBUTE*/
									// Property: Type
									"type": schema.StringAttribute{ /*START ATTRIBUTE*/
										Required: true,
										Validators: []validator.String{ /*START VALIDATORS*/
											stringvalidator.OneOf(
												"INNER",
												"OUTER",
												"LEFT",
												"RIGHT",
											),
										}, /*END VALIDATORS*/
									}, /*END ATTRIBUTE*/
								}, /*END SCHEMA*/
								Description: "<p>Join instruction.</p>",
								Optional:    true,
								Computed:    true,
								PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
									objectplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: PhysicalTableId
							"physical_table_id": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "<p>Physical table ID.</p>",
								Optional:    true,
								Computed:    true,
								Validators: []validator.String{ /*START VALIDATORS*/
									stringvalidator.LengthBetween(1, 64),
									stringvalidator.RegexMatches(regexp.MustCompile("[0-9a-zA-Z-]*"), ""),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
									stringplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
						Description: "<p>Information about the source of a logical table. This is a variant type structure. For\n            this structure to be valid, only one of the attributes can be non-null.</p>",
						Optional:    true,
						Computed:    true,
						PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
							objectplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Optional: true,
			Computed: true,
			PlanModifiers: []planmodifier.Map{ /*START PLAN MODIFIERS*/
				mapplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Name
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "\u003cp\u003eThe display name for the dataset.\u003c/p\u003e",
		//	  "maxLength": 128,
		//	  "minLength": 1,
		//	  "type": "string"
		//	}
		"name": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "<p>The display name for the dataset.</p>",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.LengthBetween(1, 128),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: OutputColumns
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "\u003cp\u003eThe list of columns after all transforms. These columns are available in templates,\n            analyses, and dashboards.\u003c/p\u003e",
		//	  "items": {
		//	    "description": "\u003cp\u003eOutput column.\u003c/p\u003e",
		//	    "properties": {
		//	      "Description": {
		//	        "description": "\u003cp\u003eA description for a column.\u003c/p\u003e",
		//	        "maxLength": 500,
		//	        "minLength": 0,
		//	        "type": "string"
		//	      },
		//	      "Name": {
		//	        "description": "\u003cp\u003eA display name for the dataset.\u003c/p\u003e",
		//	        "maxLength": 128,
		//	        "minLength": 1,
		//	        "type": "string"
		//	      },
		//	      "Type": {
		//	        "enum": [
		//	          "STRING",
		//	          "INTEGER",
		//	          "DECIMAL",
		//	          "DATETIME"
		//	        ],
		//	        "type": "string"
		//	      }
		//	    },
		//	    "type": "object"
		//	  },
		//	  "type": "array"
		//	}
		"output_columns": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: Description
					"description": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "<p>A description for a column.</p>",
						Computed:    true,
					}, /*END ATTRIBUTE*/
					// Property: Name
					"name": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "<p>A display name for the dataset.</p>",
						Computed:    true,
					}, /*END ATTRIBUTE*/
					// Property: Type
					"type": schema.StringAttribute{ /*START ATTRIBUTE*/
						Computed: true,
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Description: "<p>The list of columns after all transforms. These columns are available in templates,\n            analyses, and dashboards.</p>",
			Computed:    true,
			PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
				listplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Permissions
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "\u003cp\u003eA list of resource permissions on the dataset.\u003c/p\u003e",
		//	  "items": {
		//	    "description": "\u003cp\u003ePermission for the resource.\u003c/p\u003e",
		//	    "properties": {
		//	      "Actions": {
		//	        "description": "\u003cp\u003eThe IAM action to grant or revoke permissions on.\u003c/p\u003e",
		//	        "items": {
		//	          "type": "string"
		//	        },
		//	        "maxItems": 16,
		//	        "minItems": 1,
		//	        "type": "array"
		//	      },
		//	      "Principal": {
		//	        "description": "\u003cp\u003eThe Amazon Resource Name (ARN) of the principal. This can be one of the\n            following:\u003c/p\u003e\n        \u003cul\u003e\n            \u003cli\u003e\n                \u003cp\u003eThe ARN of an Amazon QuickSight user or group associated with a data source or dataset. (This is common.)\u003c/p\u003e\n            \u003c/li\u003e\n            \u003cli\u003e\n                \u003cp\u003eThe ARN of an Amazon QuickSight user, group, or namespace associated with an analysis, dashboard, template, or theme. (This is common.)\u003c/p\u003e\n            \u003c/li\u003e\n            \u003cli\u003e\n                \u003cp\u003eThe ARN of an AWS account root: This is an IAM ARN rather than a QuickSight\n                    ARN. Use this option only to share resources (templates) across AWS accounts.\n                    (This is less common.) \u003c/p\u003e\n            \u003c/li\u003e\n         \u003c/ul\u003e",
		//	        "maxLength": 256,
		//	        "minLength": 1,
		//	        "type": "string"
		//	      }
		//	    },
		//	    "required": [
		//	      "Actions",
		//	      "Principal"
		//	    ],
		//	    "type": "object"
		//	  },
		//	  "maxItems": 64,
		//	  "minItems": 1,
		//	  "type": "array"
		//	}
		"permissions": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: Actions
					"actions": schema.ListAttribute{ /*START ATTRIBUTE*/
						ElementType: types.StringType,
						Description: "<p>The IAM action to grant or revoke permissions on.</p>",
						Required:    true,
						Validators: []validator.List{ /*START VALIDATORS*/
							listvalidator.SizeBetween(1, 16),
						}, /*END VALIDATORS*/
					}, /*END ATTRIBUTE*/
					// Property: Principal
					"principal": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "<p>The Amazon Resource Name (ARN) of the principal. This can be one of the\n            following:</p>\n        <ul>\n            <li>\n                <p>The ARN of an Amazon QuickSight user or group associated with a data source or dataset. (This is common.)</p>\n            </li>\n            <li>\n                <p>The ARN of an Amazon QuickSight user, group, or namespace associated with an analysis, dashboard, template, or theme. (This is common.)</p>\n            </li>\n            <li>\n                <p>The ARN of an AWS account root: This is an IAM ARN rather than a QuickSight\n                    ARN. Use this option only to share resources (templates) across AWS accounts.\n                    (This is less common.) </p>\n            </li>\n         </ul>",
						Required:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.LengthBetween(1, 256),
						}, /*END VALIDATORS*/
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Description: "<p>A list of resource permissions on the dataset.</p>",
			Optional:    true,
			Computed:    true,
			Validators: []validator.List{ /*START VALIDATORS*/
				listvalidator.SizeBetween(1, 64),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
				listplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: PhysicalTableMap
		// CloudFormation resource type schema:
		//
		//	{
		//	  "patternProperties": {
		//	    "": {
		//	      "description": "\u003cp\u003eA view of a data source that contains information about the shape of the data in the\n            underlying source. This is a variant type structure. For this structure to be valid,\n            only one of the attributes can be non-null.\u003c/p\u003e",
		//	      "properties": {
		//	        "CustomSql": {
		//	          "description": "\u003cp\u003eA physical table type built from the results of the custom SQL query.\u003c/p\u003e",
		//	          "properties": {
		//	            "Columns": {
		//	              "description": "\u003cp\u003eThe column schema from the SQL query result set.\u003c/p\u003e",
		//	              "items": {
		//	                "description": "\u003cp\u003eMetadata for a column that is used as the input of a transform operation.\u003c/p\u003e",
		//	                "properties": {
		//	                  "Name": {
		//	                    "description": "\u003cp\u003eThe name of this column in the underlying data source.\u003c/p\u003e",
		//	                    "maxLength": 128,
		//	                    "minLength": 1,
		//	                    "type": "string"
		//	                  },
		//	                  "Type": {
		//	                    "enum": [
		//	                      "STRING",
		//	                      "INTEGER",
		//	                      "DECIMAL",
		//	                      "DATETIME",
		//	                      "BIT",
		//	                      "BOOLEAN",
		//	                      "JSON"
		//	                    ],
		//	                    "type": "string"
		//	                  }
		//	                },
		//	                "required": [
		//	                  "Name",
		//	                  "Type"
		//	                ],
		//	                "type": "object"
		//	              },
		//	              "maxItems": 2048,
		//	              "minItems": 1,
		//	              "type": "array"
		//	            },
		//	            "DataSourceArn": {
		//	              "description": "\u003cp\u003eThe Amazon Resource Name (ARN) of the data source.\u003c/p\u003e",
		//	              "type": "string"
		//	            },
		//	            "Name": {
		//	              "description": "\u003cp\u003eA display name for the SQL query result.\u003c/p\u003e",
		//	              "maxLength": 128,
		//	              "minLength": 1,
		//	              "type": "string"
		//	            },
		//	            "SqlQuery": {
		//	              "description": "\u003cp\u003eThe SQL query.\u003c/p\u003e",
		//	              "maxLength": 65536,
		//	              "minLength": 1,
		//	              "type": "string"
		//	            }
		//	          },
		//	          "required": [
		//	            "Columns",
		//	            "DataSourceArn",
		//	            "Name",
		//	            "SqlQuery"
		//	          ],
		//	          "type": "object"
		//	        },
		//	        "RelationalTable": {
		//	          "description": "\u003cp\u003eA physical table type for relational data sources.\u003c/p\u003e",
		//	          "properties": {
		//	            "Catalog": {
		//	              "description": "\u003cp\u003eThe catalog associated with a table.\u003c/p\u003e",
		//	              "maxLength": 256,
		//	              "minLength": 0,
		//	              "type": "string"
		//	            },
		//	            "DataSourceArn": {
		//	              "description": "\u003cp\u003eThe Amazon Resource Name (ARN) for the data source.\u003c/p\u003e",
		//	              "type": "string"
		//	            },
		//	            "InputColumns": {
		//	              "description": "\u003cp\u003eThe column schema of the table.\u003c/p\u003e",
		//	              "items": {
		//	                "description": "\u003cp\u003eMetadata for a column that is used as the input of a transform operation.\u003c/p\u003e",
		//	                "properties": {
		//	                  "Name": {
		//	                    "description": "\u003cp\u003eThe name of this column in the underlying data source.\u003c/p\u003e",
		//	                    "maxLength": 128,
		//	                    "minLength": 1,
		//	                    "type": "string"
		//	                  },
		//	                  "Type": {
		//	                    "enum": [
		//	                      "STRING",
		//	                      "INTEGER",
		//	                      "DECIMAL",
		//	                      "DATETIME",
		//	                      "BIT",
		//	                      "BOOLEAN",
		//	                      "JSON"
		//	                    ],
		//	                    "type": "string"
		//	                  }
		//	                },
		//	                "required": [
		//	                  "Name",
		//	                  "Type"
		//	                ],
		//	                "type": "object"
		//	              },
		//	              "maxItems": 2048,
		//	              "minItems": 1,
		//	              "type": "array"
		//	            },
		//	            "Name": {
		//	              "description": "\u003cp\u003eThe name of the relational table.\u003c/p\u003e",
		//	              "maxLength": 64,
		//	              "minLength": 1,
		//	              "type": "string"
		//	            },
		//	            "Schema": {
		//	              "description": "\u003cp\u003eThe schema name. This name applies to certain relational database engines.\u003c/p\u003e",
		//	              "maxLength": 64,
		//	              "minLength": 0,
		//	              "type": "string"
		//	            }
		//	          },
		//	          "required": [
		//	            "DataSourceArn",
		//	            "InputColumns",
		//	            "Name"
		//	          ],
		//	          "type": "object"
		//	        },
		//	        "S3Source": {
		//	          "description": "\u003cp\u003eA physical table type for as S3 data source.\u003c/p\u003e",
		//	          "properties": {
		//	            "DataSourceArn": {
		//	              "description": "\u003cp\u003eThe amazon Resource Name (ARN) for the data source.\u003c/p\u003e",
		//	              "type": "string"
		//	            },
		//	            "InputColumns": {
		//	              "description": "\u003cp\u003eA physical table type for as S3 data source.\u003c/p\u003e",
		//	              "items": {
		//	                "description": "\u003cp\u003eMetadata for a column that is used as the input of a transform operation.\u003c/p\u003e",
		//	                "properties": {
		//	                  "Name": {
		//	                    "description": "\u003cp\u003eThe name of this column in the underlying data source.\u003c/p\u003e",
		//	                    "maxLength": 128,
		//	                    "minLength": 1,
		//	                    "type": "string"
		//	                  },
		//	                  "Type": {
		//	                    "enum": [
		//	                      "STRING",
		//	                      "INTEGER",
		//	                      "DECIMAL",
		//	                      "DATETIME",
		//	                      "BIT",
		//	                      "BOOLEAN",
		//	                      "JSON"
		//	                    ],
		//	                    "type": "string"
		//	                  }
		//	                },
		//	                "required": [
		//	                  "Name",
		//	                  "Type"
		//	                ],
		//	                "type": "object"
		//	              },
		//	              "maxItems": 2048,
		//	              "minItems": 1,
		//	              "type": "array"
		//	            },
		//	            "UploadSettings": {
		//	              "description": "\u003cp\u003eInformation about the format for a source file or files.\u003c/p\u003e",
		//	              "properties": {
		//	                "ContainsHeader": {
		//	                  "description": "\u003cp\u003eWhether the file has a header row, or the files each have a header row.\u003c/p\u003e",
		//	                  "type": "boolean"
		//	                },
		//	                "Delimiter": {
		//	                  "description": "\u003cp\u003eThe delimiter between values in the file.\u003c/p\u003e",
		//	                  "maxLength": 1,
		//	                  "minLength": 1,
		//	                  "type": "string"
		//	                },
		//	                "Format": {
		//	                  "enum": [
		//	                    "CSV",
		//	                    "TSV",
		//	                    "CLF",
		//	                    "ELF",
		//	                    "XLSX",
		//	                    "JSON"
		//	                  ],
		//	                  "type": "string"
		//	                },
		//	                "StartFromRow": {
		//	                  "description": "\u003cp\u003eA row number to start reading data from.\u003c/p\u003e",
		//	                  "minimum": 1,
		//	                  "type": "number"
		//	                },
		//	                "TextQualifier": {
		//	                  "enum": [
		//	                    "DOUBLE_QUOTE",
		//	                    "SINGLE_QUOTE"
		//	                  ],
		//	                  "type": "string"
		//	                }
		//	              },
		//	              "type": "object"
		//	            }
		//	          },
		//	          "required": [
		//	            "DataSourceArn",
		//	            "InputColumns"
		//	          ],
		//	          "type": "object"
		//	        }
		//	      },
		//	      "type": "object"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"physical_table_map":      // Pattern: ""
		schema.MapNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: CustomSql
					"custom_sql": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: Columns
							"columns": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
								NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
									Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
										// Property: Name
										"name": schema.StringAttribute{ /*START ATTRIBUTE*/
											Description: "<p>The name of this column in the underlying data source.</p>",
											Required:    true,
											Validators: []validator.String{ /*START VALIDATORS*/
												stringvalidator.LengthBetween(1, 128),
											}, /*END VALIDATORS*/
										}, /*END ATTRIBUTE*/
										// Property: Type
										"type": schema.StringAttribute{ /*START ATTRIBUTE*/
											Required: true,
											Validators: []validator.String{ /*START VALIDATORS*/
												stringvalidator.OneOf(
													"STRING",
													"INTEGER",
													"DECIMAL",
													"DATETIME",
													"BIT",
													"BOOLEAN",
													"JSON",
												),
											}, /*END VALIDATORS*/
										}, /*END ATTRIBUTE*/
									}, /*END SCHEMA*/
								}, /*END NESTED OBJECT*/
								Description: "<p>The column schema from the SQL query result set.</p>",
								Required:    true,
								Validators: []validator.List{ /*START VALIDATORS*/
									listvalidator.SizeBetween(1, 2048),
								}, /*END VALIDATORS*/
							}, /*END ATTRIBUTE*/
							// Property: DataSourceArn
							"data_source_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "<p>The Amazon Resource Name (ARN) of the data source.</p>",
								Required:    true,
							}, /*END ATTRIBUTE*/
							// Property: Name
							"name": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "<p>A display name for the SQL query result.</p>",
								Required:    true,
								Validators: []validator.String{ /*START VALIDATORS*/
									stringvalidator.LengthBetween(1, 128),
								}, /*END VALIDATORS*/
							}, /*END ATTRIBUTE*/
							// Property: SqlQuery
							"sql_query": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "<p>The SQL query.</p>",
								Required:    true,
								Validators: []validator.String{ /*START VALIDATORS*/
									stringvalidator.LengthBetween(1, 65536),
								}, /*END VALIDATORS*/
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
						Description: "<p>A physical table type built from the results of the custom SQL query.</p>",
						Optional:    true,
						Computed:    true,
						PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
							objectplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: RelationalTable
					"relational_table": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: Catalog
							"catalog": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "<p>The catalog associated with a table.</p>",
								Optional:    true,
								Computed:    true,
								Validators: []validator.String{ /*START VALIDATORS*/
									stringvalidator.LengthBetween(0, 256),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
									stringplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
							// Property: DataSourceArn
							"data_source_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "<p>The Amazon Resource Name (ARN) for the data source.</p>",
								Required:    true,
							}, /*END ATTRIBUTE*/
							// Property: InputColumns
							"input_columns": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
								NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
									Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
										// Property: Name
										"name": schema.StringAttribute{ /*START ATTRIBUTE*/
											Description: "<p>The name of this column in the underlying data source.</p>",
											Required:    true,
											Validators: []validator.String{ /*START VALIDATORS*/
												stringvalidator.LengthBetween(1, 128),
											}, /*END VALIDATORS*/
										}, /*END ATTRIBUTE*/
										// Property: Type
										"type": schema.StringAttribute{ /*START ATTRIBUTE*/
											Required: true,
											Validators: []validator.String{ /*START VALIDATORS*/
												stringvalidator.OneOf(
													"STRING",
													"INTEGER",
													"DECIMAL",
													"DATETIME",
													"BIT",
													"BOOLEAN",
													"JSON",
												),
											}, /*END VALIDATORS*/
										}, /*END ATTRIBUTE*/
									}, /*END SCHEMA*/
								}, /*END NESTED OBJECT*/
								Description: "<p>The column schema of the table.</p>",
								Required:    true,
								Validators: []validator.List{ /*START VALIDATORS*/
									listvalidator.SizeBetween(1, 2048),
								}, /*END VALIDATORS*/
							}, /*END ATTRIBUTE*/
							// Property: Name
							"name": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "<p>The name of the relational table.</p>",
								Required:    true,
								Validators: []validator.String{ /*START VALIDATORS*/
									stringvalidator.LengthBetween(1, 64),
								}, /*END VALIDATORS*/
							}, /*END ATTRIBUTE*/
							// Property: Schema
							"schema": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "<p>The schema name. This name applies to certain relational database engines.</p>",
								Optional:    true,
								Computed:    true,
								Validators: []validator.String{ /*START VALIDATORS*/
									stringvalidator.LengthBetween(0, 64),
								}, /*END VALIDATORS*/
								PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
									stringplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
						Description: "<p>A physical table type for relational data sources.</p>",
						Optional:    true,
						Computed:    true,
						PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
							objectplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
					// Property: S3Source
					"s3_source": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: DataSourceArn
							"data_source_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "<p>The amazon Resource Name (ARN) for the data source.</p>",
								Required:    true,
							}, /*END ATTRIBUTE*/
							// Property: InputColumns
							"input_columns": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
								NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
									Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
										// Property: Name
										"name": schema.StringAttribute{ /*START ATTRIBUTE*/
											Description: "<p>The name of this column in the underlying data source.</p>",
											Required:    true,
											Validators: []validator.String{ /*START VALIDATORS*/
												stringvalidator.LengthBetween(1, 128),
											}, /*END VALIDATORS*/
										}, /*END ATTRIBUTE*/
										// Property: Type
										"type": schema.StringAttribute{ /*START ATTRIBUTE*/
											Required: true,
											Validators: []validator.String{ /*START VALIDATORS*/
												stringvalidator.OneOf(
													"STRING",
													"INTEGER",
													"DECIMAL",
													"DATETIME",
													"BIT",
													"BOOLEAN",
													"JSON",
												),
											}, /*END VALIDATORS*/
										}, /*END ATTRIBUTE*/
									}, /*END SCHEMA*/
								}, /*END NESTED OBJECT*/
								Description: "<p>A physical table type for as S3 data source.</p>",
								Required:    true,
								Validators: []validator.List{ /*START VALIDATORS*/
									listvalidator.SizeBetween(1, 2048),
								}, /*END VALIDATORS*/
							}, /*END ATTRIBUTE*/
							// Property: UploadSettings
							"upload_settings": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
								Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
									// Property: ContainsHeader
									"contains_header": schema.BoolAttribute{ /*START ATTRIBUTE*/
										Description: "<p>Whether the file has a header row, or the files each have a header row.</p>",
										Optional:    true,
										Computed:    true,
										PlanModifiers: []planmodifier.Bool{ /*START PLAN MODIFIERS*/
											boolplanmodifier.UseStateForUnknown(),
										}, /*END PLAN MODIFIERS*/
									}, /*END ATTRIBUTE*/
									// Property: Delimiter
									"delimiter": schema.StringAttribute{ /*START ATTRIBUTE*/
										Description: "<p>The delimiter between values in the file.</p>",
										Optional:    true,
										Computed:    true,
										Validators: []validator.String{ /*START VALIDATORS*/
											stringvalidator.LengthBetween(1, 1),
										}, /*END VALIDATORS*/
										PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
											stringplanmodifier.UseStateForUnknown(),
										}, /*END PLAN MODIFIERS*/
									}, /*END ATTRIBUTE*/
									// Property: Format
									"format": schema.StringAttribute{ /*START ATTRIBUTE*/
										Optional: true,
										Computed: true,
										Validators: []validator.String{ /*START VALIDATORS*/
											stringvalidator.OneOf(
												"CSV",
												"TSV",
												"CLF",
												"ELF",
												"XLSX",
												"JSON",
											),
										}, /*END VALIDATORS*/
										PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
											stringplanmodifier.UseStateForUnknown(),
										}, /*END PLAN MODIFIERS*/
									}, /*END ATTRIBUTE*/
									// Property: StartFromRow
									"start_from_row": schema.Float64Attribute{ /*START ATTRIBUTE*/
										Description: "<p>A row number to start reading data from.</p>",
										Optional:    true,
										Computed:    true,
										Validators: []validator.Float64{ /*START VALIDATORS*/
											float64validator.AtLeast(1.000000),
										}, /*END VALIDATORS*/
										PlanModifiers: []planmodifier.Float64{ /*START PLAN MODIFIERS*/
											float64planmodifier.UseStateForUnknown(),
										}, /*END PLAN MODIFIERS*/
									}, /*END ATTRIBUTE*/
									// Property: TextQualifier
									"text_qualifier": schema.StringAttribute{ /*START ATTRIBUTE*/
										Optional: true,
										Computed: true,
										Validators: []validator.String{ /*START VALIDATORS*/
											stringvalidator.OneOf(
												"DOUBLE_QUOTE",
												"SINGLE_QUOTE",
											),
										}, /*END VALIDATORS*/
										PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
											stringplanmodifier.UseStateForUnknown(),
										}, /*END PLAN MODIFIERS*/
									}, /*END ATTRIBUTE*/
								}, /*END SCHEMA*/
								Description: "<p>Information about the format for a source file or files.</p>",
								Optional:    true,
								Computed:    true,
								PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
									objectplanmodifier.UseStateForUnknown(),
								}, /*END PLAN MODIFIERS*/
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
						Description: "<p>A physical table type for as S3 data source.</p>",
						Optional:    true,
						Computed:    true,
						PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
							objectplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Optional: true,
			Computed: true,
			PlanModifiers: []planmodifier.Map{ /*START PLAN MODIFIERS*/
				mapplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: RowLevelPermissionDataSet
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "\u003cp\u003eThe row-level security configuration for the dataset.\u003c/p\u003e",
		//	  "properties": {
		//	    "Arn": {
		//	      "description": "\u003cp\u003eThe Amazon Resource Name (ARN) of the permission dataset.\u003c/p\u003e",
		//	      "type": "string"
		//	    },
		//	    "FormatVersion": {
		//	      "enum": [
		//	        "VERSION_1",
		//	        "VERSION_2"
		//	      ],
		//	      "type": "string"
		//	    },
		//	    "Namespace": {
		//	      "description": "\u003cp\u003eThe namespace associated with the row-level permissions dataset.\u003c/p\u003e",
		//	      "maxLength": 64,
		//	      "minLength": 0,
		//	      "pattern": "^[a-zA-Z0-9._-]*$",
		//	      "type": "string"
		//	    },
		//	    "PermissionPolicy": {
		//	      "enum": [
		//	        "GRANT_ACCESS",
		//	        "DENY_ACCESS"
		//	      ],
		//	      "type": "string"
		//	    }
		//	  },
		//	  "required": [
		//	    "Arn",
		//	    "PermissionPolicy"
		//	  ],
		//	  "type": "object"
		//	}
		"row_level_permission_data_set": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: Arn
				"arn": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "<p>The Amazon Resource Name (ARN) of the permission dataset.</p>",
					Required:    true,
				}, /*END ATTRIBUTE*/
				// Property: FormatVersion
				"format_version": schema.StringAttribute{ /*START ATTRIBUTE*/
					Optional: true,
					Computed: true,
					Validators: []validator.String{ /*START VALIDATORS*/
						stringvalidator.OneOf(
							"VERSION_1",
							"VERSION_2",
						),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: Namespace
				"namespace": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "<p>The namespace associated with the row-level permissions dataset.</p>",
					Optional:    true,
					Computed:    true,
					Validators: []validator.String{ /*START VALIDATORS*/
						stringvalidator.LengthBetween(0, 64),
						stringvalidator.RegexMatches(regexp.MustCompile("^[a-zA-Z0-9._-]*$"), ""),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: PermissionPolicy
				"permission_policy": schema.StringAttribute{ /*START ATTRIBUTE*/
					Required: true,
					Validators: []validator.String{ /*START VALIDATORS*/
						stringvalidator.OneOf(
							"GRANT_ACCESS",
							"DENY_ACCESS",
						),
					}, /*END VALIDATORS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "<p>The row-level security configuration for the dataset.</p>",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Tags
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "\u003cp\u003eContains a map of the key-value pairs for the resource tag or tags assigned to the dataset.\u003c/p\u003e",
		//	  "items": {
		//	    "description": "\u003cp\u003eThe key or keys of the key-value pairs for the resource tag or tags assigned to the\n            resource.\u003c/p\u003e",
		//	    "properties": {
		//	      "Key": {
		//	        "description": "\u003cp\u003eTag key.\u003c/p\u003e",
		//	        "maxLength": 128,
		//	        "minLength": 1,
		//	        "type": "string"
		//	      },
		//	      "Value": {
		//	        "description": "\u003cp\u003eTag value.\u003c/p\u003e",
		//	        "maxLength": 256,
		//	        "minLength": 1,
		//	        "type": "string"
		//	      }
		//	    },
		//	    "required": [
		//	      "Key",
		//	      "Value"
		//	    ],
		//	    "type": "object"
		//	  },
		//	  "maxItems": 200,
		//	  "minItems": 1,
		//	  "type": "array"
		//	}
		"tags": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: Key
					"key": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "<p>Tag key.</p>",
						Required:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.LengthBetween(1, 128),
						}, /*END VALIDATORS*/
					}, /*END ATTRIBUTE*/
					// Property: Value
					"value": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "<p>Tag value.</p>",
						Required:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.LengthBetween(1, 256),
						}, /*END VALIDATORS*/
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Description: "<p>Contains a map of the key-value pairs for the resource tag or tags assigned to the dataset.</p>",
			Optional:    true,
			Computed:    true,
			Validators: []validator.List{ /*START VALIDATORS*/
				listvalidator.SizeBetween(1, 200),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
				listplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
	} /*END SCHEMA*/

	attributes["id"] = schema.StringAttribute{
		Description: "Uniquely identifies the resource.",
		Computed:    true,
		PlanModifiers: []planmodifier.String{
			stringplanmodifier.UseStateForUnknown(),
		},
	}

	schema := schema.Schema{
		Description: "Definition of the AWS::QuickSight::DataSet Resource Type.",
		Version:     1,
		Attributes:  attributes,
	}

	var opts generic.ResourceOptions

	opts = opts.WithCloudFormationTypeName("AWS::QuickSight::DataSet").WithTerraformTypeName("awscc_quicksight_data_set")
	opts = opts.WithTerraformSchema(schema)
	opts = opts.WithSyntheticIDAttribute(true)
	opts = opts.WithAttributeNameMap(map[string]string{
		"actions":                            "Actions",
		"alias":                              "Alias",
		"arn":                                "Arn",
		"aws_account_id":                     "AwsAccountId",
		"cast_column_type_operation":         "CastColumnTypeOperation",
		"catalog":                            "Catalog",
		"column_description":                 "ColumnDescription",
		"column_geographic_role":             "ColumnGeographicRole",
		"column_groups":                      "ColumnGroups",
		"column_id":                          "ColumnId",
		"column_level_permission_rules":      "ColumnLevelPermissionRules",
		"column_name":                        "ColumnName",
		"column_names":                       "ColumnNames",
		"columns":                            "Columns",
		"condition_expression":               "ConditionExpression",
		"consumed_spice_capacity_in_bytes":   "ConsumedSpiceCapacityInBytes",
		"contains_header":                    "ContainsHeader",
		"country_code":                       "CountryCode",
		"create_columns_operation":           "CreateColumnsOperation",
		"created_time":                       "CreatedTime",
		"custom_sql":                         "CustomSql",
		"data_set_arn":                       "DataSetArn",
		"data_set_id":                        "DataSetId",
		"data_set_usage_configuration":       "DataSetUsageConfiguration",
		"data_source_arn":                    "DataSourceArn",
		"data_transforms":                    "DataTransforms",
		"delimiter":                          "Delimiter",
		"description":                        "Description",
		"disable_use_as_direct_query_source": "DisableUseAsDirectQuerySource",
		"disable_use_as_imported_source":     "DisableUseAsImportedSource",
		"expression":                         "Expression",
		"field_folders":                      "FieldFolders",
		"filter_operation":                   "FilterOperation",
		"format":                             "Format",
		"format_version":                     "FormatVersion",
		"geo_spatial_column_group":           "GeoSpatialColumnGroup",
		"import_mode":                        "ImportMode",
		"ingestion_wait_policy":              "IngestionWaitPolicy",
		"ingestion_wait_time_in_hours":       "IngestionWaitTimeInHours",
		"input_columns":                      "InputColumns",
		"join_instruction":                   "JoinInstruction",
		"key":                                "Key",
		"last_updated_time":                  "LastUpdatedTime",
		"left_join_key_properties":           "LeftJoinKeyProperties",
		"left_operand":                       "LeftOperand",
		"logical_table_map":                  "LogicalTableMap",
		"name":                               "Name",
		"namespace":                          "Namespace",
		"new_column_name":                    "NewColumnName",
		"new_column_type":                    "NewColumnType",
		"on_clause":                          "OnClause",
		"output_columns":                     "OutputColumns",
		"permission_policy":                  "PermissionPolicy",
		"permissions":                        "Permissions",
		"physical_table_id":                  "PhysicalTableId",
		"physical_table_map":                 "PhysicalTableMap",
		"principal":                          "Principal",
		"principals":                         "Principals",
		"project_operation":                  "ProjectOperation",
		"projected_columns":                  "ProjectedColumns",
		"relational_table":                   "RelationalTable",
		"rename_column_operation":            "RenameColumnOperation",
		"right_join_key_properties":          "RightJoinKeyProperties",
		"right_operand":                      "RightOperand",
		"row_level_permission_data_set":      "RowLevelPermissionDataSet",
		"s3_source":                          "S3Source",
		"schema":                             "Schema",
		"source":                             "Source",
		"sql_query":                          "SqlQuery",
		"start_from_row":                     "StartFromRow",
		"tag_column_operation":               "TagColumnOperation",
		"tags":                               "Tags",
		"text":                               "Text",
		"text_qualifier":                     "TextQualifier",
		"type":                               "Type",
		"unique_key":                         "UniqueKey",
		"upload_settings":                    "UploadSettings",
		"value":                              "Value",
		"wait_for_spice_ingestion":           "WaitForSpiceIngestion",
	})

	opts = opts.WithWriteOnlyPropertyPaths([]string{
		"/properties/FieldFolders",
		"/properties/IngestionWaitPolicy",
	})
	opts = opts.WithCreateTimeoutInMinutes(0).WithDeleteTimeoutInMinutes(0)

	opts = opts.WithUpdateTimeoutInMinutes(0)

	v, err := generic.NewResource(ctx, opts...)

	if err != nil {
		return nil, err
	}

	return v, nil
}
