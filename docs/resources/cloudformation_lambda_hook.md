---
page_title: "awscc_cloudformation_lambda_hook Resource - terraform-provider-awscc"
subcategory: ""
description: |-
  This is a CloudFormation resource for the first-party AWS::Hooks::LambdaHook.
---

# awscc_cloudformation_lambda_hook (Resource)

This is a CloudFormation resource for the first-party AWS::Hooks::LambdaHook.

## Example Usage

```terraform
data "aws_caller_identity" "current" {}
data "aws_region" "current" {}

data "archive_file" "lambda_zip" {
  type        = "zip"
  output_path = "/tmp/lambda_hook_function.zip"
  source {
    content  = <<EOF
import json
import logging

logger = logging.getLogger()
logger.setLevel(logging.INFO)

def lambda_handler(event, context):
    """
    CloudFormation Lambda Hook handler
    Processes CloudFormation stack operation events
    """
    logger.info(f"Received CloudFormation hook event: {json.dumps(event)}")
    
    # Extract hook details
    hook_type = event.get('HookType', 'Unknown')
    stack_name = event.get('StackName', 'Unknown')
    operation = event.get('Operation', 'Unknown')
    
    logger.info(f"Processing {hook_type} hook for stack: {stack_name}, operation: {operation}")
    
    # Hook logic - validate or monitor the operation
    # For this example, we'll just log and allow all operations
    
    response = {
        'Status': 'SUCCESS',
        'Message': f'Hook processed successfully for stack {stack_name}'
    }
    
    logger.info(f"Hook response: {json.dumps(response)}")
    return response
EOF
    filename = "lambda_function.py"
  }
}

resource "awscc_iam_role" "lambda_role" {
  role_name = "cloudformation-lambda-hook-function-role"
  assume_role_policy_document = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "lambda.amazonaws.com"
        }
      }
    ]
  })

  managed_policy_arns = [
    "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
  ]

  tags = [{
    key   = "Modified By"
    value = "AWSCC"
  }]
}

# Lambda function for the hook
resource "aws_lambda_function" "hook_function" {
  filename      = data.archive_file.lambda_zip.output_path
  function_name = "cloudformation-lambda-hook-processor"
  role          = awscc_iam_role.lambda_role.arn
  handler       = "lambda_function.lambda_handler"
  runtime       = "python3.11"
  timeout       = 60

  source_code_hash = data.archive_file.lambda_zip.output_base64sha256

}

# IAM role for CloudFormation Lambda Hook execution
resource "awscc_iam_role" "hook_execution_role" {
  role_name = "cloudformation-lambda-hook-execution-role"
  assume_role_policy_document = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "hooks.cloudformation.amazonaws.com"
        }
      }
    ]
  })

  tags = [{
    key   = "Modified By"
    value = "AWSCC"
  }]
}

# IAM policy for hook execution role
resource "awscc_iam_role_policy" "hook_execution_policy" {
  role_name   = awscc_iam_role.hook_execution_role.role_name
  policy_name = "CloudFormationLambdaHookExecutionPolicy"
  policy_document = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "lambda:InvokeFunction"
        ]
        Resource = aws_lambda_function.hook_function.arn
      },
      {
        Effect = "Allow"
        Action = [
          "logs:CreateLogGroup",
          "logs:CreateLogStream",
          "logs:PutLogEvents"
        ]
        Resource = "arn:aws:logs:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:*"
      }
    ]
  })
}

# CloudFormation Lambda Hook
resource "awscc_cloudformation_lambda_hook" "example" {
  alias           = "CCAPI::TEST::Hooks"
  execution_role  = awscc_iam_role.hook_execution_role.arn
  failure_mode    = "WARN"
  lambda_function = aws_lambda_function.hook_function.arn
  hook_status     = "ENABLED"

  target_operations = ["CLOUD_CONTROL"]

  # Target specific resource types and operations
  target_filters = {
    actions = [
      "CREATE",
      "UPDATE",
      "DELETE"
    ]
    invocation_points = [
      "PRE_PROVISION"
    ]
    target_names = [
      "AWS::S3::Bucket",
      "AWS::EC2::Instance",
      "AWS::Lambda::Function"
    ]
  }

}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `alias` (String) The typename alias for the hook.
- `execution_role` (String) The execution role ARN assumed by Hooks to invoke Lambda.
- `failure_mode` (String) Attribute to specify CloudFormation behavior on hook failure.
- `lambda_function` (String) Amazon Resource Name (ARN), Partial ARN, name, version, or alias of the Lambda function to invoke with this hook.
- `target_operations` (List of String) Which operations should this Hook run against? Resource changes, stacks or change sets.

### Optional

- `hook_status` (String) Attribute to specify which stacks this hook applies to or should get invoked for
- `stack_filters` (Attributes) Filters to allow hooks to target specific stack attributes (see [below for nested schema](#nestedatt--stack_filters))
- `target_filters` (Attributes) Attribute to specify which targets should invoke the hook (see [below for nested schema](#nestedatt--target_filters))

### Read-Only

- `hook_arn` (String) The Amazon Resource Name (ARN) of the activated hook
- `id` (String) Uniquely identifies the resource.

<a id="nestedatt--stack_filters"></a>
### Nested Schema for `stack_filters`

Optional:

- `filtering_criteria` (String) Attribute to specify the filtering behavior. ANY will make the Hook pass if one filter matches. ALL will make the Hook pass if all filters match
- `stack_names` (Attributes) List of stack names as filters (see [below for nested schema](#nestedatt--stack_filters--stack_names))
- `stack_roles` (Attributes) List of stack roles that are performing the stack operations. (see [below for nested schema](#nestedatt--stack_filters--stack_roles))

<a id="nestedatt--stack_filters--stack_names"></a>
### Nested Schema for `stack_filters.stack_names`

Optional:

- `exclude` (Set of String) List of stack names that the hook is going to be excluded from
- `include` (Set of String) List of stack names that the hook is going to target


<a id="nestedatt--stack_filters--stack_roles"></a>
### Nested Schema for `stack_filters.stack_roles`

Optional:

- `exclude` (Set of String) List of stack roles that the hook is going to be excluded from
- `include` (Set of String) List of stack roles that the hook is going to target



<a id="nestedatt--target_filters"></a>
### Nested Schema for `target_filters`

Optional:

- `actions` (Set of String) List of actions that the hook is going to target
- `invocation_points` (Set of String) List of invocation points that the hook is going to target
- `target_names` (Set of String) List of type names that the hook is going to target
- `targets` (Attributes List) List of hook targets (see [below for nested schema](#nestedatt--target_filters--targets))

<a id="nestedatt--target_filters--targets"></a>
### Nested Schema for `target_filters.targets`

Optional:

- `action` (String) Target actions are the type of operation hooks will be executed at.
- `invocation_point` (String) Invocation points are the point in provisioning workflow where hooks will be executed.
- `target_name` (String) Type name of hook target. Hook targets are the destination where hooks will be invoked against.

## Import

Import is supported using the following syntax:

The [`terraform import` command](https://developer.hashicorp.com/terraform/cli/commands/import) can be used, for example:

```shell
$ terraform import awscc_cloudformation_lambda_hook.example "hook_arn"
```
